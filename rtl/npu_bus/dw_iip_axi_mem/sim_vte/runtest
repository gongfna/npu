#!/opt/synopsys/coretools/K-2015.06-SP5/linux64/dware/bin/snpsperl

BEGIN { @INC = ( "/opt/synopsys/coretools/K-2015.06-SP5/linux64/dware/lib" ); }
require 5.004;
# -------------------------------------------------------------------------
#
#
#                      (C) COPYRIGHT 2001-2011 SYNOPSYS INC.
#                             ALL RIGHTS RESERVED
#
#
# File    : runtest
# Author  : Joe Mc Cann
# Created : Thu Jan 17 13:39:08 GMT 2002
# Abstract: User interface script to coreKit simulation system
#           This script is used by all Amba DesignWare macrocells to
#           simulations on unpacked coreKits.
#
# -------------------------------------------------------------------------
# Revision: $Id: //dwh/DW_ocb/bin/main/pkg/perl/runtest#75 $
# -------------------------------------------------------------------------

use 5.004;            # -- Insist on Perl version 5.004 or newer for safety
use strict;           # -- Follow rigid variable/subroutine declarations
use File::Basename;   # -- Compute the containing directory of this script
use lib (dirname $0); # -- and use it as the search path for any .pm modules
use Getopt::Long;     # -- Command-line Options decoder with long options
$| = 1;               # -- Flush output stream continuously for readability

my $Pgm = (basename $0);                # -- store program name
my $Invoke = join(' ',($Pgm,@ARGV));    # -- store program arguments
my $Version = ' $Revision: #75 $ ';    # -- set program revision number
my $platform = `uname`; chop $platform; # -- store the host platform

# -- Extract the name of the top level module
my $ModName;
&fetch_module_name();


#
# Convert new RCE supported arguments to runtest into the expected args.
# This must be replaced but works for testing the new code. This section
# will be skipped if old style arguments are detected.
#
my $argIndex;
my $newDumpEnabled = 0;
my $newClockDefault = 1;
my $newTimeoutDefault = 1;
my $newView = "RTL";
my $newNetlistDir = "";
my $newTechLib = "";
my @newARGV = ();
for ($argIndex = 0; $argIndex <= $#ARGV; $argIndex += 2) {
  $_ = $ARGV[$argIndex];
  SWITCH: {
    /^--simulator$/ && do { @newARGV = (); last SWITCH; };

    /^--AllTests$/ && do {
      last SWITCH;
    };
    /^--test$/ && do {
      push @newARGV, $ARGV[$argIndex];
      push @newARGV, $ARGV[$argIndex + 1];
      last SWITCH;
    };
    /^--SimChoice$/ && do {
      push @newARGV, "--simulator";
      my $simulator = $ARGV[$argIndex + 1];
      $simulator =~ tr/A-Z/a-z/;
      push @newARGV, $simulator;
      last SWITCH;
    };
    /^--DumpEnabled$/ && do {
      $newDumpEnabled = $ARGV[$argIndex + 1];
      last SWITCH;
    };
    /^--DumpDepth$/ && do {
      if ($newDumpEnabled) {
        push @newARGV, "--dump_depth";
        push @newARGV, $ARGV[$argIndex + 1];
      }
      last SWITCH;
    };
    /^--ClockDefault$/ && do {
      $newClockDefault = $ARGV[$argIndex + 1];
      last SWITCH;
    };
    /^--ClockPeriod$/ && do {
      if (!$newClockDefault) {
        push @newARGV, "--period";
        push @newARGV, $ARGV[$argIndex + 1];
      }
      last SWITCH;
    };
    /^--Clock2Period$/ && do {
      push @newARGV, "--period2";
      push @newARGV, $ARGV[$argIndex + 1];
      last SWITCH;
    };
    /^--TimeoutDefault$/ && do {
      $newTimeoutDefault = $ARGV[$argIndex + 1];
      last SWITCH;
    };
    /^--TimeoutCycles$/ && do {
      if (!$newTimeoutDefault) {
        push @newARGV, "--timeout";
        push @newARGV, $ARGV[$argIndex + 1];
      }
      last SWITCH;
    };
    /^--ClockRatio$/ && do {
      push @newARGV, "--clock_ratio";
      push @newARGV, $ARGV[$argIndex + 1];
      last SWITCH;
    };
    /^--DesignView$/ && do {
      $newView = $ARGV[$argIndex + 1];
      if ($newView eq "RTL") {
        push @newARGV, "--rtl"
      }
      last SWITCH;
    };
    /^--TechLib$/ && do {
      $newTechLib = $ARGV[$argIndex + 1];
      last SWITCH;
    };
    /^--TechFile$/ && do {
      if ($newView eq "GateLevel") {
        push @newARGV, "--lib_dir";
        push @newARGV, $newTechLib;
        push @newARGV, "--lib_file";
        push @newARGV, "$newTechLib/$ARGV[$argIndex + 1]";
      }
      last SWITCH;
    };
    /^--NetlistDir$/ && do {
      $newNetlistDir = $ARGV[$argIndex + 1];
      last SWITCH;
    };
    /^--NetlistFile$/ && do {
      if ($newView eq "RTL") {
        push @newARGV, "--rtl_dir";
        push @newARGV, $newNetlistDir;
      } else {
        push @newARGV, "--netlist";
        push @newARGV, "$newNetlistDir/$ARGV[$argIndex + 1]";
      }
      last SWITCH;
    };
    /^--coverage$/ && do {
      push @newARGV, "--coverage";
      last SWITCH;
    };
    /^--MTIIncludePath$/ && do {
      last SWITCH;
    };
    # Unknown argument.
    push @newARGV, $ARGV[$argIndex];
    $argIndex--;
  }
}

if ($#newARGV >= 0) {
  # Found arguments to convert. This is a new-style invocation.
  ###print STDERR "** Replacing: @ARGV\n";
  @ARGV = @newARGV;
  ###print STDERR "** With: @ARGV\n";
}


# -- Options decoding - first define Globals and useful defaults
# -- Whenever <coreKit> appears in these variables, the relative
# -- path to the coreKit install directory  will be substituted

# -- Options: Global

my $Pretend;
my $ShowHelp;
my $ShowVersion;
my $Verbose;

# -- Options: What design to simulate

my $DesignName       = $ModName;
my $RtlSim;                             # Simulate netlist by default
my $Netlist          = "<coreKit>/gtech/qmap/db/$DesignName.v";
my $SdfFile;                            # No SDF by default
my $SdfLevel         = "max";
my $RtlDir           = "<coreKit>/src";
my $LibDir           = "";
my $LibFile;

# -- Options: How to simulate:

my $Simulator        = "vcs";
my $use64bitSimulator;
my $SystemVerilogCompile = 0;
my $sixtyfourbitswitch = "";
my $LogFile          = "test.log";      # in test subdirectory
my $ResultFile       = "test.result";   # in test subdirectory
my $DumpDepth;
my $DumpFile         = "test.vcd";      # in test subdirectory
my $Coverage;
my $VeraDebugLevel   = 0;

# -- Options: What stimulus to provide:

my $Test;
my $TestbenchDir     = "<coreKit>/sim/testbench";
my $MTIWorkDir       = "<coreKit>/scratch";
my $VeraDir          = "<coreKit>/sim/vera";
my $Period           = 100;
my $Period2          = 100;
my $Timeout;
my $EnCovMon         = 0;
my $designware_home = "";
my $GenerateMCDFile  = 0;

# -- Options: Additional simulation parameters

my $ApbClockRatio    = 1;

# -- Options: Vera Compilation 

my $VeraForceCompile     = 0;  # Do not force Vera recompilation by default
my $VeraForceCompileMain = 1;  # Force Vera recompilation of the main program by default

# -- Usage help text

my $Usage = <<EndOfUsage;

Usage:   $Pgm [ options ]
Purpose: Run coreKit simulations.

Options: Global:

  --help                    Print  this  usage  message

  --version                 Print  program  version  number

  --verbose                 Be  verbose

  --pretend                 Build  scripts  only,  don\'t  run


Options: What design to simulate:


  --DesignView <view>       Choose input to simulator.  Choices
                            are:  RTL, GTECH or GateLevel 

  --NetlistDir <netlist_dir> 
                            Run netlist simulations using 
                            directory <netlist_dir>

  --NetlistFile <netlist_file> 
                            Run simulations using netlist
                            <netlist_file>.  Only needed for
                            non-RTL simulations
 

  --lib_dir <dir1>[,...]    Comma-separated list of directories
                            containing  libraries  for  netlist
                            ( including  gtech )    simulations
                            Default is
                            \"$LibDir\"

  --lib_file <file1>[,...]  Comma-separated   list  of   files
                            containing libraries  for  netlist
                            ( including  gtech )   simulations


Options: How to simulate:


  --SimChoice <sim>         Run with  chosen  simulator. <sim>
                            can be one of:  < VCS | Verilog_XL 
                            |   MTI_Verilog  |   NC_Verilog  >

  --log_file <logfile>      Direct   simulation   stdout    to
                            <logfile>, default  is \"$LogFile\"

  --result_file <resfile>   Record   simulation   result    to
                            <resfile>, default is \"$ResultFile\"

  --DumpDepth <depth>       Enable  creation  of  value-change
                            dump  ( VCD+ )  file  to  a  depth
                            of  < depth > ( 0 = all  signals )

  --dump_file <filename>    Name    of   VCD+   output    file
                            ( default : $DumpFile )

  --coverage                Turn on coverage recording options


Options: What stimulus to provide:


  --test <test-obj-file>    Select  which  directory to obtain
                            test   stimulus   files   from

  --testbench <tbdir>       Select     directory    to    load
                            testbench     from,   default   is
                            \"$TestbenchDir\"

  --vera_dir <veradir>      Look for VERA objects in <veradir>,
                            default is \"$VeraDir\"

  --ClockPeriod <period>    Simulation   clock  period (in ns).
                            ( default: specified in testbench )

  --Clock2Period <period2>  Simulation   clock  period (in ns).
                            ( default: specified in testbench )

  --TimeoutCycles <cycles>  Number  of clock cycles   until   a
                            runaway  simulation  is  terminated
                            Default    is    something   large,
                            specified   in    the    individual
                            testbench

  --enable_covmon <0, 1>    Select if the AHB  and APB coverage
                            monitors  are   enabled   for   the
                            simulation run.


Options: Additional simulation parameters:


  --ClockRatio N            Specify    the     APB CLOCK_RATIO
                            parameter value (default $ApbClockRatio)

EndOfUsage


# Options decoding - call GetOptions here

GetOptions (  'help|h'                   => \$ShowHelp
            , 'version|v'                => \$ShowVersion
            , 'verbose|V'                => \$Verbose
            , 'pretend|n'                => \$Pretend

            , 'rtl'                      => \$RtlSim
            , 'netlist|g=s'              => \$Netlist
            , 'sdf=s'                    => \$SdfFile
            , 'sdf_level=s'              => \$SdfLevel
            , 'rtl_dir=s'                => \$RtlDir
            , 'lib_dir=s'                => \$LibDir
            , 'lib_file=s'               => \$LibFile

            , 'simulator|s=s'            => \$Simulator
            , 'log_file|logfile=s'       => \$LogFile
            , 'result_file|resultfile=s' => \$ResultFile
            , 'dump_depth|depth|waves=i' => \$DumpDepth
            , 'dump_file|dumpfile=s'     => \$DumpFile
            , 'coverage'                 => \$Coverage
            , 'vera_debug_level=i'       => \$VeraDebugLevel
       	    , 'test_sv=i'                => \$SystemVerilogCompile
      	    , '64bit|64'                 => \$use64bitSimulator
            , 'test=s'                   => \$Test
            , 'testbench=s'              => \$TestbenchDir
            , 'vera_dir=s'               => \$VeraDir
            , 'period=f'                 => \$Period
            , 'period2=f'                => \$Period2
            , 'timeout=i'                => \$Timeout
            , 'enable_covmon=i'          => \$EnCovMon
            , 'GenerateMCDFile=i'        => \$GenerateMCDFile	    
            , 'clock_ratio=i'            => \$ApbClockRatio
            , 'VeraForceCompile=i'       => \$VeraForceCompile
            , 'VeraForceCompileMain=i'   => \$VeraForceCompileMain
           ) or die "$Pgm: $Usage";

if ( $ShowHelp )    { print STDERR $Usage; exit 0; }
if ( $ShowVersion ) { print STDERR "$Pgm: version $Version\n"; exit 0; }


# -/ ==================================================================
# -/
# -/                          MAIN PROGRAM
# -/
# -/ ==================================================================

# -/ ------------------------------------------------------
# -/ declare global varables
# -/ ------------------------------------------------------
my $Summary;
my $Cwd;
my $coreKit;
my $configDirName;
my $ccparams_file;
my %ccparams;
my $simcommand;
my $plusargs;
my $testbench;
my $bus;


# -/ ------------------------------------------------------
# -/ global varables for vera compilation 
# -/ ------------------------------------------------------
my $vera_home              = "";
my $vera_vro_cache         = "";
my $vera_vmc_version       = "";
my @vera_include_list      = "";

# -/ ------------------------------------------------------
# -/ 1. Sanity Checks and Preparation
# -/ ------------------------------------------------------
#&sanity_checks();
&run_dw_vip_setup();
&preparation();

# -/ ------------------------------------------------------
# -/ 2. Parse cc_constants file and store in hash
# -/ ------------------------------------------------------
&parse_cc_constants();


# -/ ------------------------------------------------------
# -/ 2. Manage MCD file 
# -/ ------------------------------------------------------
&manageMCDFile();

# -/ ------------------------------------------------------
# -/ 4. Create the simulation command file
# -/ ------------------------------------------------------
&generate_sim_command();

# -/ ------------------------------------------------------
# -/ 5. Create vera plusarg file
# -/ ------------------------------------------------------
# fk  &generate_vera_plusargs();

# -/ ------------------------------------------------------
# -/ 6. Create over-ride cc_constants file
# -/ ------------------------------------------------------
unless ($DesignName eq 'DW_ahb') {
  unless ($DesignName eq 'DW_ahb_h2h') {
     unless ($DesignName eq 'DW_axi') {
     &generate_cc_constants();
     }
  }
}

# -/ ------------------------------------------------------
# -/ 7. Vera compile
# -/ ------------------------------------------------------
# fk &compile_check_environment();
# fk &compile_vera($Test);
# fk &generate_vrl();
# fk &generate_vshell($Simulator);

# -/ ------------------------------------------------------
# -/ 7. Run simulation
# -/ ------------------------------------------------------
&run_sim();

# -/ ------------------------------------------------------
# -/ 8. Postprocess - generate result logs
# -/ ------------------------------------------------------
&postprocess();



# -/ ==================================================================
# -/
# -/                          SUBROUTINES
# -/
# -/ ==================================================================

sub sanity_checks() {

  # -/ --------------------------------------------------------------
  # -/ Function used to check input arguments
  # -/ to ensure legal options.
  # -/ --------------------------------------------------------------

  die "$Pgm: ERROR - --rtl and --sdf are mutually exclusive\n" 
    if ( $RtlSim and $SdfFile and $SdfFile ne "");

  if ($RtlSim and $Simulator ne "vcs") {
    `dc_shell -checkout "DesignWare-BUSIP-Source" -x "quit"`;
    if ($?) {
      die "\n$Pgm: ERROR - Unable to perform an RTL simulation using $Simulator!\n".
	  "$Pgm: Non-VCS RTL simulations require a DesignWare-BUSIP-Source licence.\n\n";
    }
  }

  die "$Pgm: ERROR - No test specified to run - need -test <testdir>\n" unless (defined $Test);
}


sub preparation() {

  # -/ --------------------------------------------------------------
  # -/ Function used to prepare for the
  # -/ simulation run.
  # -/ --------------------------------------------------------------

  print STDERR "\n\n+------------------------+\n| Testbench Preparation  |".
               "\n+------------------------+\n\n";
  print STDERR "(this section of runtest.log supplied by runtest script)\n\n";

  # -- Keep a safe copy of the Invoke command line for a summary later,
  # -- delete some less useful parts of it
  $Summary = $Invoke." ...";
  $Summary =~ s/--rtl-dir\s+\S+\s*//g;
  $Summary =~ s/--timeout\s+\S+\s*//g;
  $Summary =~ s/(--test\s+\S+)\s*/sprintf("%-24s",$1) /ge;

  $Invoke =~ s/ --/\\\n            --/g;
  print STDERR "$Pgm: To recreate the run from this point for debug, do the following\n";
  print STDERR "$Pgm:    % cd ".`pwd`;
  print STDERR "$Pgm:    % $Invoke\n\n";

  chdir "./$Test" or die "$Pgm: ERROR - Cannot cd to test subdirectory ./$Test";
  print STDERR "$Pgm: Changed Directory to ./$Test - look here for detailed logfiles/waves/results\n";

  # -- If it's midnight, wait a moment to avoid licensing problems
  my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
  sleep 120 if ($hour == 23 and $min == 59);
  sleep 60 if ($hour == 0 and $min == 0);

  # -- Set $Cwd now and we will use that as a reference point
  $Cwd = `pwd`; chomp $Cwd;
  $coreKit = (dirname (dirname $Cwd));

  $RtlDir = convertPath($RtlDir);
#FK  $VeraDir = convertPath($VeraDir);
  $Netlist = convertPath($Netlist);
  $SdfFile = convertPath($SdfFile);
  $DumpFile = convertPath($DumpFile);
  $TestbenchDir = convertPath($TestbenchDir);
  $Test = convertPath($Test);

  $configDirName = (basename $coreKit);
  $ccparams_file = "<coreKit>/../${configDirName}/src/${DesignName}_cc_constants.v";
  $ccparams_file = convertPath($ccparams_file);

  print STDERR "\n$Pgm: coreKit in file:".(dirname (dirname $Cwd))."\n";
  print STDERR "$Pgm: runtest in file:".(dirname $Cwd)."\n";
  print STDERR "$Pgm: test is in file:$Cwd\n";

  # -- Simulator option should be case-insensitive - force to lower-case
  $Simulator = lc($Simulator);

  # -- Choose wave format
  if ( $DumpFile =~ /\.(vcd|vpd)$/ ) {
    if (($Simulator eq "vcs") or ($Simulator eq "vcsi")) {
      $DumpFile =~ s/\.vcd$/\.vpd/;
    } else {
      $DumpFile =~ s/\.vpd$/\.vcd/;
    }
  } else {
    die "$Pgm: ERROR - Waves file extension not correct - should be XXXX.vcd or XXXX.vpd\n";
  }

  # -- Simulation Source
  $testbench = "$TestbenchDir/test_${DesignName}.v";
  
}



sub parse_cc_constants() {

  # -/ --------------------------------------------------------------
  # -/ This function parses the cc_constants file of the design
  # -/ storing the parameter values into a hash
  # -/ --------------------------------------------------------------

  print STDERR "$Pgm: Using ${DesignName} configuration specified in file:".
               " \n$Pgm:   file:".(dirname (dirname $Cwd))."/".(basename $RtlDir).
               "/${DesignName}_cc_constants.v\n";

  open(CCPARAMS,"< $ccparams_file") || die "$Pgm: ERROR - Can't open $ccparams_file ($!)\n";
  while (<CCPARAMS>) {
    if (/^\`define\s+(\S+)\s+(.+)/) {
      my ($param,$value) = ($1,$2);
      # -- Got param - convert it from verilog `define format number to a string
      # -- containing a vera-format number of the same radix e.g. NN`bXXXX -> 0xXXXX
      $value =~ s/^([0-9]*)\'h([0-9a-fA-F]+)$/0x$2/;
      $value =~ s/^([0-9]*)\'d[0]*([0-9]+)$/$2/;
      $value =~ s/^([0-9]*)\'o([0-7]+)$/0$2/;
      $value =~ s/^([0-9]*)\'b([0-1]+)$/0b$2/;
      $ccparams{$param} = $value;
    }
  }
  close CCPARAMS || die "$Pgm: ERROR - Failed to close $ccparams_file after read ($!)\n";

}

# this should be now obsolete
sub generate_vrl_file() {

  # -/ --------------------------------------------------------------
  # -/ Function to create our test_XXX.vrl file which lists all
  # -/ .vro's required by this test or simulation. Rather than
  # -/ include all the .vros from all the libraries, we parse our
  # -/ code to look for all the #include XXXX.vrh directives and list
  # -/ those which have corresponding .vro's in our library search
  # -/ path. This is a crude but effective method; there may be
  # -/ exceptions from time to time which need hard-coded.
  # -/ --------------------------------------------------------------

  my @vera_files = ("test.vrh");
  my @vera_search_path = (".","$VeraDir/include","$TestbenchDir");
  my %already_parsed;
  my %vrl_entries;
  $vrl_entries{'./test.vro'}=1;
  foreach my $vera_file (@vera_files) {
    open(VERA,"<$vera_file") || die "$Pgm: ERROR - Can't open $vera_file for reading ($!)\n";
    while (<VERA>) {
      if ( / ^ \s* [\#\`] \s* include \s* [\"<]? ([^\">\s]+) /x ) {
	my ($included_file) = grep -e, map "$_/$1", @vera_search_path ;
	if ( $included_file and not $already_parsed{$included_file}++ ) {
	  push @vera_files, $included_file;
	  next unless ($included_file =~ /.vrh/);
	  $included_file =~ s-/include/-/lib/-;
	  $included_file =~ s-.vrh-.vro-;
	  $vrl_entries{$included_file} = 1;
	}
      }
    }
  }

  my $vrl_file  = "test_${DesignName}.vrl";
  my $program = 0;
  open (VRL,">$vrl_file") || die "$Pgm: ERROR - Can't open $vrl_file for writing ($!)\n";

  foreach (sort keys %vrl_entries) {
    print VRL $_."\n";
    if($_ eq "../testbench/test_${DesignName}.vro") { $program = 1; }
  }
  print VRL "../testbench/test_${DesignName}.vro" unless($program);
  close VRL || die "$Pgm: ERROR - Failed to close $vrl_file after write ($!)\n";

}


sub generate_sim_command() {

  # -/ --------------------------------------------------------------
  # -/ This function is used to generate a simulation command file
  # -/ "test.sim_command", and a vera plusargs file "config.ini"
  # -/ --------------------------------------------------------------

  my $bin1;
  my $bin2;
  my $file_missing;
  ($bin1, $bus, $bin2) = split('_', $DesignName);
  if($bus eq 'amba') {
    if($ccparams{'ICT_ON_APB'}) {
      $bus = 'apb';
    } else {
      $bus = 'ahb';
    }
  }

  # -- Open file for writing
if (($Simulator eq "vcs") or ($Simulator eq "vcsi") or ($Simulator eq "mti_verilog") or ($Simulator eq "verilog_xl") or ($Simulator eq "nc_verilog")) {

  $simcommand = "test.sim_command";
  print STDERR "$Pgm: Creating simulation command file: \n$Pgm:   file:$Cwd/$simcommand\n";
  open(SCF,">$simcommand") or
    die "$Pgm: ERROR -  couldn't open simulation command file $simcommand for write\n";

  # -- print header to file
  printf SCF "// -----------------------------------------------------------------------\n";
  printf SCF "// Simulation Control file produced by %s - do not edit\n",$Pgm;
  printf SCF "// -----------------------------------------------------------------------\n";
  printf SCF "\n";
  
  # -- VCS command
  if(($Simulator eq "vcs") or ($Simulator eq "vcsi")) { 
    printf SCF "-sverilog\n";
    printf SCF "+vcs+lic+wait\n";
    printf SCF "-notice\n";
  }

  
  # -- Misc commands
  printf SCF "+v2k\n";  
  printf SCF "+nowarnTFNPC\n";
  printf SCF "+nowarnLIBNOU\n";
  printf SCF "+nowarnCUVWSI\n";
  printf SCF "+nowarnCUVMPW\n";
  printf SCF "+nowarnBIGWBS\n";
  printf SCF "+nowarnCSINFI\n";
  printf SCF "+warn=noPCWM\n";
  printf SCF "+warn=noPHNE\n";
  printf SCF "+warn=noIWNF\n";
  printf SCF "+libext+.v+.V\n";
  printf SCF "+sdfverbose\n";
  printf SCF "+neg_tchk\n";
  printf SCF "+plusarg_save\n";
  printf SCF "+enable_coverage=$EnCovMon\n";

  if ($Period) {
    ## mb ## if ($DesignName eq "DW_ahb_h2h") {
    ## mb ##   printf SCF "+define+A_CLK_PERIOD=$Period\n";
    ## mb ## } else {
      printf SCF "+define+PERIOD=$Period\n";
    ## mb ## }
  }
  if ($Period2) {
    ## mb ## if ($DesignName eq "DW_ahb_h2h") {
    ## mb ##   printf SCF "+define+B_CLK_PERIOD=$Period2\n";
    ## mb ## } else {
      printf SCF "+define+PERIOD2=$Period2\n";
    ## mb ## }
  }

  if ($Timeout) {
    printf SCF "+define+TIMEOUT=".($Period * $Timeout)."\n";
  }
  printf SCF "+define+DEBUG_LEVEL=$VeraDebugLevel\n";
  if ($Coverage) {
    printf SCF "+define+CODE_COVERAGE\n";
  }

  # -- RTL or Netlist simulation
  if ($RtlSim) {
    printf SCF "+define+RTL\n";
    printf SCF "+delay_mode_zero\n";
  } else {
    printf SCF "+define+NETLIST\n";
  }

  # -- common to all apb designs
#fk  unless($DesignName eq "DW_ahb") {
#fk    printf SCF "+define+APB_CLK_RATIO=$ApbClockRatio\n";
#fk  }

  # The DW_ahb_dmac needs conditional instantiation of certain testbench components.
  # However, the CC params that control this are always defined, so we need to create
  # new ones if required
  if ($DesignName eq "DW_ahb_dmac") {
    if ($ccparams{'DMAH_M1_AHB_LITE'} eq 1) {
      printf SCF "+define+M1_AHB_LITE\n";
    }
    if ($ccparams{'DMAH_M2_AHB_LITE'} eq 1) {
      printf SCF "+define+M2_AHB_LITE\n";
    }
    if ($ccparams{'DMAH_M3_AHB_LITE'} eq 1) {
      printf SCF "+define+M3_AHB_LITE\n";
    }
    if ($ccparams{'DMAH_M4_AHB_LITE'} eq 1) {
      printf SCF "+define+M4_AHB_LITE\n";
    }
    if ($ccparams{'DMAH_NUM_HS_INT'} ne 0) {
      printf SCF "+define+NUM_HS_NZ\n";
    }  
    if ($ccparams{'DMAH_NUM_MASTER_INT'} eq 2) {
      printf SCF "+define+NUM_MI_GE2\n";
    }      
    if ($ccparams{'DMAH_NUM_MASTER_INT'} eq 3) {
      printf SCF "+define+NUM_MI_GE2 +define+NUM_MI_GE3\n";
    }  
    if ($ccparams{'DMAH_NUM_MASTER_INT'} eq 4) {
      printf SCF "+define+NUM_MI_GE2 +define+NUM_MI_GE3 +define+NUM_MI_GE4\n";
    }            
  }

 
  # -- SDF annotation
  if ($SdfFile) {
    if(($Simulator eq "vcs") or ($Simulator eq "vcsi")) { 
      printf SCF "+csdf+precompile\n";
      printf SCF "+define+SDF_FILE=\"\"$SdfFile\"\"\n";
      if($SdfLevel eq 'max') {
	printf SCF "+define+SDF_LEVEL=\"\"MAXIMUM\"\"\n";
      } elsif($SdfLevel eq 'typ') {
	printf SCF "+define+SDF_LEVEL=\"\"TYPICAL\"\"\n";
      } else {
	printf SCF "+define+SDF_LEVEL=\"\"MINIMUM\"\"\n";
      }
    } else {
      printf SCF "+define+SDF_FILE=\\\"$SdfFile\\\"\n";
    }
  }

  # -- Dump file control
  if (defined $DumpDepth) {
    printf SCF "\n// What waves to record\n\n";
    if((($Simulator eq "vcs") or ($Simulator eq "vcsi")) and ($DumpFile =~ /\.vpd$/)) { 
      printf SCF "+vpdfile+$DumpFile\n";
      printf SCF "+vpdports\n"; # Include ports info
    } elsif (($Simulator eq "vcs") or ($Simulator eq "vcsi")) { 
      printf SCF "+define+DUMP_FILE=\"\"$DumpFile\"\"\n";
    } else {
      printf SCF "+define+DUMP_FILE=\\\"$DumpFile\\\"\n";
    }
    printf SCF "+define+DUMP_DEPTH=$DumpDepth\n";
  } else {
    printf SCF "\n// Waves recording not enabled - no --dump-depth N specified\n\n";
  }

  # -- define a macro if it is a netlist
  if (!($newView eq "RTL")) {
    printf SCF "\n// Tell the testbench that we have a netlist\n\n";
    printf SCF "+define+GATE_LEVEL_NETLIST\n";
  }

  # -- Construct the library switches from $LibDir and $LibFile
  # -- $LibDir, obtained from --lib-dir, is a space-separated list of directories.
  # -- We'll make a $libswitches by prepending "-y " to each of the directories.
  my $file_missing=0;

  my @libdirs = split(",",$LibDir);
  if ($newView eq "GTECH") {
    if (exists $ENV{SYNOPSYS}) {
      if ($ENV{SYNOPSYS} ne "" && (-d "$ENV{SYNOPSYS}/packages/gtech/src_ver")) {
          push @libdirs,"$ENV{SYNOPSYS}/packages/gtech/src_ver";
      } else {
        print STDERR "\n$Pgm: ERROR - Env variable \$SYNOPSYS is not correctly set - ($ENV{SYNOPSYS})";
        print STDERR "\n              Unable to find required directory - \$SYNOPSYS/packages/gtech/src_ver";
        print STDERR "\n              If using SYNOPSYS Synthesis Tools, set Env variable \$SYNOPSYS to a valid location.";
        print STDERR "\n              If NOT using SYNOPSYS Synthesis Tools, unset Env variable \$SYNOPSYS.\n";
        die "\n$Pgm: FATAL - $file_missing required files/directories missing. $Pgm terminating\n";
      }
    } else {
      print STDERR "\n$Pgm: WARNING - Env variable \$SYNOPSYS is not set for this GTECH simulation";
      print STDERR "\n                Unable to auto set path to GTECH libs.";
      print STDERR "\n                If using SYNOPSYS Synthesis Tools, set Env variable \$SYNOPSYS to a valid location.";
      print STDERR "\n                If NOT using SYNOPSYS Synthesis Tools, pass valid gtech lib path on runtest command line\n";
    }
  }

  if (exists $ccparams{'USE_FOUNDATION'}) {
    if ($ccparams{'USE_FOUNDATION'} eq 1) {
      if (exists $ENV{SYNOPSYS}) {
        if ( $ENV{SYNOPSYS} ne "" && (-d "$ENV{SYNOPSYS}/dw/sim_ver")) {
          push @libdirs,"$ENV{SYNOPSYS}/dw/sim_ver";
        } else {
          print STDERR "\n$Pgm: ERROR - Design parameter USE_FOUNDATION==1 and Env variable \$SYNOPSYS is not correctly set - ($ENV{SYNOPSYS})";
          print STDERR "\n              Unable to find required directory - \$SYNOPSYS/dw/sim_ver";
          print STDERR "\n              Set Env variable \$SYNOPSYS to a valid location.";
          die "\n$Pgm: FATAL - $file_missing required files/directories missing. $Pgm terminating\n";
        }
      } else {
        print STDERR "\n$Pgm: ERROR - Design parameter USE_FOUNDATION==1 and Env variable \$SYNOPSYS is not set";
        print STDERR "\n              Unable to find required directory - \$SYNOPSYS/dw/sim_ver";
        print STDERR "\n              Set Env variable \$SYNOPSYS to a valid location.";
        die "\n$Pgm: FATAL - $file_missing required files/directories missing. $Pgm terminating\n";
      }
    }
  }

  my $libswitch= "";
  foreach (@libdirs) {
    $_ = convertPath($_);
    printf SCF "-y $_\n";
    unless (-d "$_") {
      $file_missing++;
      print STDERR "\n$Pgm: ERROR - directory $_ is required but missing.\n";
    }
  }

  printf SCF "\n\n// By default the GTECH models use a unit delay. Depending on the frequency\n";
  printf SCF "// of the design this can cause problems. Using zero delay instead\n\n";
  printf SCF "+define+GTECH_default_delay=0\n";

  # -- $LibFile, obtained from --lib-file, is a space-separated list of files.
  # -- We'll add to $libswitches by appending "-v " to each of the files
  if ($LibFile) {
    my @libfiles = split(",",$LibFile);
    foreach(@libfiles) {
      $_ = convertPath($_);
      printf SCF "-v $_\n";
      unless (-e "$_") {
	$file_missing++;
	print STDERR "\n$Pgm: ERROR - file $_ is required but missing.\n";
      }
    }
  }

  # -- The main list of source files is retrieved from the source directory and
  # -- provided to the simulator command line in correct order.
  # -- Other verilog is included or instantiated and should not need explicit
  # -- mention on the command line.
  #
  # -- NOTE: The order of the +incdir+ and -y options is important because the
  # -- local test directory has to be able to override eg DW_ahb_cc_constants.v
  printf SCF "\n// -----------------------------------------------------------------------\n";
  printf SCF "// Simulation Source files and include directories\n";
  printf SCF "// -----------------------------------------------\n\n";


# FK - For DW_axi in tb.lst file.

#    printf SCF "$testbench\n\n";
  

#fk
  if ($DesignName eq 'DW_axi') {     
    printf SCF "+incdir+../../scratch/include/verilog/\n";
    printf SCF "-f $TestbenchDir/tb.lst\n";    
  }
  
  
  if ($RtlSim) {
    print SCF "-f $RtlDir/$DesignName.lst\n";
    #open(FILELIST,"< $RtlDir/$DesignName.lst")
    #  or die "$Pgm: ERROR - Can't open $RtlDir/$DesignName.lst to retrieve source file list\n";
    #while (<FILELIST>) {
    #  print SCF $_;
    #}
    #close FILELIST;
  } else {
    printf SCF "$Netlist\n\n";
  }



  printf SCF "+incdir+.\n";
  printf SCF "-y .\n\n";
  printf SCF "+incdir+$RtlDir\n";
  printf SCF "-y $RtlDir\n\n";
  printf SCF "+incdir+$TestbenchDir\n";
  printf SCF "-y $TestbenchDir\n\n";

  if ($DesignName eq 'DW_ahb') {
    # do nothing
#FK
  } elsif ($DesignName eq 'DW_axi') {
    # do nothing  
  }
  elsif ($DesignName eq 'DW_apb') {
    # -- Source files & directories for DW_apb design
    printf SCF "./DW_ahb_cc_constants.v\n\n";
    printf SCF "$TestbenchDir/ahb/src/ahb_wrapper.v\n\n";
    printf SCF "+incdir+$TestbenchDir/ahb/src\n";
    printf SCF "-y $TestbenchDir/ahb/src\n\n";
    
  }
  elsif ($DesignName eq "DW_ahb_dmac") {
    printf SCF "-f $TestbenchDir/ahb.lst\n\n";
    printf SCF " $TestbenchDir/dpsram_model.v\n\n";    
  }
  elsif ($DesignName eq "DW_ahb_h2h") {
    printf SCF "$TestbenchDir/ahb_wrapper.v\n\n";
  }
  elsif ($bus eq 'apb') {
    # -- Source files & directories for APB peripheral designs
    printf SCF "$TestbenchDir/ahb/src/DW_ahb_cc_constants.v\n\n";
    printf SCF "$TestbenchDir/ahb/src/ahb_wrapper.v\n\n";
    printf SCF "+incdir+$TestbenchDir/ahb/src\n";
    printf SCF "-y $TestbenchDir/ahb/src\n\n";
    printf SCF "./DW_apb_cc_constants.v\n\n";
    printf SCF "$TestbenchDir/apb/src/apb_wrapper.v\n\n";
    printf SCF "+incdir+$TestbenchDir/apb/src\n";
    printf SCF "-y $TestbenchDir/apb/src\n\n";
  }
  elsif ($bus eq 'ahb') {
    # -- Source files & directories for AHB peripheral designs
    printf SCF "./DW_ahb_cc_constants.v\n\n";
    printf SCF "$TestbenchDir/ahb/src/ahb_wrapper.v\n\n";
    printf SCF "+incdir+$TestbenchDir/ahb/src\n";
    printf SCF "-y $TestbenchDir/ahb/src\n\n";
  }

  
  close SCF or die "$Pgm: ERROR - failed to close command file $simcommand after write\n";
  die "$Pgm: FATAL - $file_missing required files/directories missing. $Pgm terminating\n" if $file_missing;
 }
#########################
# VHDL sim command file #  
#########################
  my $vhdlcommandfile = "vera.ini";
  if (($Simulator eq "mti_vhdl") or ($Simulator eq "nc_vhdl") or ($Simulator eq "scirocco")) {
    print STDERR "$Pgm: Creating VHDL vera simulation params file: \n:$Pgm: file: $Cwd/$vhdlcommandfile\n";
    open (DCF,">$vhdlcommandfile") or die "$Pgm: ERROR - couldn't open vhdl vera simulation params file $vhdlcommandfile for write\n";

    printf DCF "// -----------------------------------------------------------------------\n";
    printf DCF "// VHDL Simulation Control file produced by %s - do not edit\n",$vhdlcommandfile,$Pgm;
    printf DCF "// -----------------------------------------------------------------------\n";
    printf DCF "\n";
    printf DCF "warn=noPCWM\n";
    printf DCF "libext.v.V\n";
    printf DCF "sdfverbose\n";
    printf DCF "neg_tchk\n";
    printf DCF "plusarg_save\n";
    printf DCF "vera_pload=./test_${DesignName}.proj\n";
    if ($Period) {
      printf DCF "PERIOD=".$Period."\n";
    }
    if ($Period2) {
      printf DCF "PERIOD2=".$Period2."\n";
    }
    if ($Timeout) {
      printf DCF "TIMEOUT=".($Period * $Timeout)."\n";
    }
    unless($DesignName eq "DW_ahb") {
      printf DCF "APB_CLK_RATIO=$ApbClockRatio\n";
    }
    printf DCF "netlist=1\n";
    printf DCF "enable_coverage=0\n";
    
    if ($DesignName eq "DW_ahb") {
      printf DCF "ahb_cc_filename=$ccparams_file\n\n";
    } elsif ($DesignName eq "DW_apb") {
      print DCF "apb_cc_filename=$ccparams_file\n";
      print DCF "ahb_cc_filename=./DW_ahb_cc_constants.v\n";
      printf DCF "apb_clk_ratio=$ApbClockRatio\n";
    } elsif ($DesignName eq "DW_ahb_dmac") {
      printf DCF "cc_filename=$ccparams_file\n\n";
    } elsif ($bus eq "apb") {
      printf DCF "apb_periph_cc_filename=$ccparams_file\n\n";
      printf DCF "apb_cc_filename=./DW_apb_cc_constants.v\n";
      printf DCF "ahb_cc_filename=../testbench/ahb/src/DW_ahb_cc_constants.v\n\n";
    } elsif ($bus eq "ahb") {
      printf DCF "ahb_periph_cc_filename=$ccparams_file\n\n";
      printf DCF "ahb_cc_filename=./DW_ahb_cc_constants.v\n\n";
    } 
    close DCF or die  "$Pgm : ERROR - failed to close command file $vhdlcommandfile after write\n";
  }

  # VHDL library setup files - simulator specific
  if ($Simulator eq "nc_vhdl") {
    # set up cds.lib file for NC_VHDL
    my $cds_inst = $ENV{CDS_INST_DIR} or die "CDS_INST_DIR environment variable not set!\n";
    my $nc_cdslib_file = "cds.lib";
    print STDERR "$Pgm: Creating NC_VHDL library map file: \n$Pgm: file:$Cwd/$nc_cdslib_file\n";
    open (NCL, ">$nc_cdslib_file") or die "$Pgm: ERROR - couldn't oipen nc_vhdl library map file $nc_cdslib_file for writing\n";
    printf NCL "DEFINE std $cds_inst/tools/inca/files/STD\n";
    printf NCL "DEFINE synopsys ../../scratch/ncvhdl_workdir/synopsys\n";
    printf NCL "DEFINE ieee ../../scratch/ncvhdl_workdir/ieee\n";
    printf NCL "DEFINE dware ../../scratch/ncvhdl_workdir/dware\n";
    printf NCL "DEFINE gtech ../../scratch/ncvhdl_workdir/gtech\n";
    printf NCL "DEFINE ahb_inst ../../scratch/ncvhdl_workdir/ahb_inst\n";
    printf NCL "DEFINE apb_inst ../../scratch/ncvhdl_workdir/apb_inst\n";
    printf NCL "DEFINE dut_inst ../../scratch/ncvhdl_workdir/dut_inst\n";
    printf NCL "DEFINE cmp_source ../../scratch/ncvhdl_workdir/cmp_source\n";
    close NCL or die "$Pgm: ERROR - failed to close NC_VHDL library map file $nc_cdslib_file after writing\n";

  # Also set up hdl.var
    my $nc_hdlvar_file = "hdl.var";
    print STDERR "$Pgm: Creating NC_VHDL Work Library file: \n$Pgm: file:$Cwd/$nc_hdlvar_file\n";
    open (NCV,">$nc_hdlvar_file") or die "$Pgm: ERROR - couldn't open nc_vhdl Work Library file $nc_hdlvar_file for writing!\n";
    printf NCV "softinclude $cds_inst/tools/inca/files/hdl.var\n";
    printf NCV "DEFINE WORK cmp_source\n";
    close NCV or die "$Pgm: ERROR - failed to close NC_VHDL Work Lib file $nc_hdlvar_file after writing.\n";

    my $nc_tclinp_file = "tcl.inp";
    print STDERR "$Pgm: Creating NC_VHDL TCL cmd input file: \n$Pgm:   file:$Cwd/$nc_tclinp_file\n";
    open(NCT,">$nc_tclinp_file") or die "$Pgm: ERROR -  couldn't open nc_vhdl tcl cmd input file $nc_tclinp_file for write\n";
    if ($newDumpEnabled == 1) {
      printf NCT "call vcdfile ./$DumpFile -t ns\n";
      printf NCT "call vcdaddscope : \n";
    }
    printf NCT "run\n";
    close NCT or die "$Pgm: ERROR - failed to close nc_vhdl tcl cmd input file $nc_tclinp_file after write\n";
  }

  if($Simulator eq "scirocco") {
    my $int_synopsys_sim = $ENV{SYNOPSYS_SIM};
    my $int_synopsys = $ENV{SYNOPSYS};
  
    my $sro_vsssetup_file = ".synopsys_vss.setup";
    print STDERR "$Pgm: Creating scirocco setup file: \n$Pgm:   file:$Cwd/$sro_vsssetup_file\n";
    open(SRV,">$sro_vsssetup_file") or die "$Pgm: ERROR -  couldn't open scirocco setup file $sro_vsssetup_file for write\n";
    printf SRV "WORK              > $DesignName\n";
    printf SRV "$DesignName       : ../../scratch/scirocco_workdir\n";
    printf SRV "SYNOPSYS          : $int_synopsys_sim/packages/synopsys/lib\n";
    printf SRV "IEEE              : $int_synopsys_sim/packages/IEEE/lib\n";
    printf SRV "GTECH             : $int_synopsys_sim/packages/gtech/lib\n";
    printf SRV "DWARE             : $int_synopsys_sim/packages/dware/lib\n";
    printf SRV "\n";
    printf SRV "TIMEBASE          = NS\n";
    close SRV or die "$Pgm: ERROR - failed to close scirocco setup file $sro_vsssetup_file after write\n";
    die "$Pgm: FATAL - $file_missing required files/directories missing. $Pgm terminating\n" if $file_missing;
   
    my $sro_runinc_file = "sro_run.inc";
    print STDERR "$Pgm: Creating scirocco run include file: \n$Pgm:   file:$Cwd/$sro_runinc_file\n";
    open(SRR,">$sro_runinc_file") or die "$Pgm: ERROR -  couldn't open scirocco run include $sro_runinc_file for write\n";
    if ($newDumpEnabled == 1) {
      if ($DumpFile =~ /\.vpd$/) {
        printf SRR "dump -vpd -o $DumpFile /test_${DesignName}/U_*/*'PORTS \n";
      } else {
        printf SRR "dump -vcd -o $DumpFile /test_${DesignName}/U_*/*'PORTS \n";
      }
    }
    printf SRR "run\n";
    close SRR or die "$Pgm: ERROR - failed to close scirocco run include $sro_runinc_file after write\n";
    die "$Pgm: FATAL - $file_missing required files/directories missing. $Pgm terminating\n" if $file_missing;
  }
  
}



sub generate_vera_plusargs() {

  # -/ --------------------------------------------------------------
  # -/ Function to generate the vera plusargs for the simulation
  # -/ the plusargs are written to a file called "config.ini"
  # -/ --------------------------------------------------------------

  my $file_missing=0;
  
  # -- Open file for writing
  $plusargs = "config.ini";
  print STDERR "$Pgm: Creating plusargs simulation file: \n$Pgm:   file:$Cwd/$plusargs\n";
  open(VPF,">$plusargs") or
    die "$Pgm: ERROR -  couldn't open plusargs simulation file $plusargs for write\n";

  # -- print header to file
  printf VPF "// -----------------------------------------------------------------------\n";
  printf VPF "// Vera plusarg simulation file produced by %s - do not edit\n",$Pgm;
  printf VPF "// -----------------------------------------------------------------------\n";
  printf VPF "\n";
  printf VPF "+nowarnTFNPC\n";
  printf VPF "+nowarnTFMPC\n";
  printf VPF "+nowarnTMREN\n";
  printf VPF "+nowarnLDSNN\n";
  printf VPF "+nowarnOPTCHK\n";
  printf VPF "+nowarnLIBNOU\n";

  printf VPF "+debug_level=$VeraDebugLevel\n";

  # -- Plusargs common to all designs
  printf VPF "+vera_pload=test_${DesignName}.proj\n";
  if ($Period)  { printf VPF "+PERIOD=$Period\n"; }
  if ($Period)  { printf VPF "+PERIOD2=$Period2\n"; }
  if ($Timeout) { printf VPF "+TIMEOUT=".($Period * $Timeout)."\n"; }

 printf VPF "+enable_coverage=$EnCovMon\n";
  if ($RtlSim) {
    printf VPF "+netlist=0\n";
  } else {
    printf VPF "+netlist=1\n";
  }

  if($DesignName eq "DW_ahb") {

    # -- Plusargs for the DW_ahb design
    printf VPF "+ahb_cc_filename=$ccparams_file\n\n";
  }
  elsif($DesignName eq "DW_apb") {

    # -- Plusargs for the DW_apb design
    print  VPF "+apb_cc_filename=$ccparams_file\n";
    print  VPF "+ahb_cc_filename=./DW_ahb_cc_constants.v\n";
    printf VPF "+apb_clk_ratio=$ApbClockRatio\n";
  }
  elsif ($DesignName eq "DW_ahb_dmac") {
    printf VPF "+cc_filename=$ccparams_file\n\n";
  }
  elsif($bus eq "apb") {

    # -- Plusargs for APB peripherals
    printf VPF "+apb_periph_cc_filename=$ccparams_file\n\n";
    printf VPF "+apb_cc_filename=./DW_apb_cc_constants.v\n";
    printf VPF "+ahb_cc_filename=../testbench/ahb/src/DW_ahb_cc_constants.v\n\n";
  }
  elsif($bus eq "ahb") {

    # -- Plusargs for AHB peripherals
    printf VPF "+ahb_periph_cc_filename=$ccparams_file\n\n";
    printf VPF "+ahb_cc_filename=./DW_ahb_cc_constants.v\n\n";
  }

  close VPF or die "$Pgm: ERROR - failed to close command file $plusargs after write\n";
  die "$Pgm: FATAL - $file_missing required files/directories missing. $Pgm terminating\n" if $file_missing;

}


sub generate_cc_constants() {

  # -/ --------------------------------------------------------------
  # -/ This function is used to generate a cc_constants file for the
  # -/ DW_ahb or DW_apb designs. The file generated by this function
  # -/ takes presedence over the existing cc_constants file.
  # -/ --------------------------------------------------------------

  if($DesignName eq 'DW_apb') {

    # -- Bridge start and end address params from DW_apb_cc_constants.v
    # -- This script assumes these params already validated in cC plugin
    # -- ie (1) EA>SA, (2) (EA-SA) is legal, (3) (SA+(0x100000000-EA))>=4k
    #
    # -- Calculate where 1k slots for arbiter, slave (2 regions) should go

    my ($arbiter,$slave_r1,$slave_r2);
    my $apb_start = eval($ccparams{'R0_APB_SA'});
    if ($apb_start  >= 4096) {
      ($arbiter, $slave_r1, $slave_r2) = (0x00000000,0x00000400,0x00000c00);
    } elsif ($apb_start >= 2048) {
      ($arbiter, $slave_r1, $slave_r2) = (0x00000000,0x00000400,0xfffffc00);
    } elsif ($apb_start == 1024) {
      ($arbiter, $slave_r1, $slave_r2) = (0x00000000,0xfffff400,0xfffffc00);
    } elsif ($apb_start == 0) {
      ($arbiter, $slave_r1, $slave_r2) = (0xfffff000,0xfffff400,0xfffffc00);
    } else {
      die "$Pgm: Illegal value $apb_start for Apb start address R0_APB_SA";
    }

    # -- Generate an override DW_ahb_cc_constants file in the local directory.
    # -- This makes the DW_ahb instance in the testbench match up with the
    # -- unpacked configuration of the DW_apb under test in the databus width,
    # -- endiannenss and slave decode address region areas

    print STDERR "$Pgm: Creating override DW_ahb_cc_constants file: \n$Pgm:   file:$Cwd/DW_ahb_cc_constants.v\n";

    my $DW_ahb_default_params = "$TestbenchDir/ahb/src/DW_ahb_cc_constants.v";
    my $DW_ahb_override_params = "./DW_ahb_cc_constants.v";
    open(AHB_DEFAULT_PARAMS,"< $DW_ahb_default_params") || die "$Pgm: ERROR - Can't open $DW_ahb_default_params ($!)\n";
    open(AHB_OVERRIDE_PARAMS,"> $DW_ahb_override_params") || die "$Pgm: ERROR - Can't open $DW_ahb_override_params ($!)\n";
    while (<AHB_DEFAULT_PARAMS>) {
      if (/^\s*\`define\s+AHB_DATA_WIDTH\s+/) {
	printf AHB_OVERRIDE_PARAMS "`define AHB_DATA_WIDTH %0d\n",$ccparams{'AHB_DATA_WIDTH'};
      } elsif (/^\s*\`define\s+BIG_ENDIAN\s+/) {
	printf AHB_OVERRIDE_PARAMS "`define BIG_ENDIAN %d\n",$ccparams{'BIG_ENDIAN'};
      } elsif (/^\s*\`define\s+R1_N_SA_0\s+/) {
	printf AHB_OVERRIDE_PARAMS "`define R1_N_SA_0 32'h%08x\n",$arbiter;
      } elsif (/^\s*\`define\s+R1_N_EA_0\s+/) {
	printf AHB_OVERRIDE_PARAMS "`define R1_N_EA_0 32'h%08x\n",$arbiter+1023;
      } elsif (/^\s*\`define\s+R1_N_SA_2\s+/) {
	printf AHB_OVERRIDE_PARAMS "`define R1_N_SA_2 32'h%08x\n",$slave_r1;
      } elsif (/^\s*\`define\s+R1_N_EA_2\s+/) {
	printf AHB_OVERRIDE_PARAMS "`define R1_N_EA_2 32'h%08x\n",$slave_r1+1023;
      } elsif (/^\s*\`define\s+R2_N_SA_2\s+/) {
	printf AHB_OVERRIDE_PARAMS "`define R2_N_SA_2 32'h%08x\n",$slave_r2;
      } elsif (/^\s*\`define\s+R2_N_EA_2\s+/) {
	printf AHB_OVERRIDE_PARAMS "`define R2_N_EA_2 32'h%08x\n",$slave_r2+1023;
      } elsif (/^\s*\`define\s+R1_N_SA_1\s+/) {
	printf AHB_OVERRIDE_PARAMS "`define R1_N_SA_1 32'h%08x\n",eval($ccparams{'R0_APB_SA'});
      } elsif (/^\s*\`define\s+R1_N_EA_1\s+/) {
	printf AHB_OVERRIDE_PARAMS "`define R1_N_EA_1 32'h%08x\n",eval($ccparams{'R0_APB_EA'});
      } else {
	print AHB_OVERRIDE_PARAMS $_;
      }
    }
    close AHB_DEFAULT_PARAMS || die "$Pgm: ERROR - Failed to close $DW_ahb_default_params after read ($!)\n";
    close AHB_OVERRIDE_PARAMS || die "$Pgm: ERROR - Failed to close $DW_ahb_override_params after write ($!)\n";
  }
  elsif ($DesignName eq "DW_ahb_dmac") {
    # Loop round all the AHB peripherals and open their cc_params files.
    # Change the parameters of interest, and write to a new file.  Then copy
    # this file back to overwrite the original
    my $AhbNumber;
    foreach $AhbNumber (1..5){
      my $DW_ahb_original_params = "$TestbenchDir/ahb".$AhbNumber."/src/DW_ahb_cc_constants.v";
      my $DW_ahb_new_params = "$TestbenchDir/ahb".$AhbNumber."/src/DW_ahb_cc_constants.v_new";

      open(AHB_ORIGINAL_PARAMS,"< $DW_ahb_original_params") || die "$Pgm: ERROR - Can't open $DW_ahb_original_params ($!)\n";
      open(AHB_NEW_PARAMS,"> $DW_ahb_new_params") || die "$Pgm: ERROR - Can't open $DW_ahb_new_params ($!)\n";

      while (<AHB_ORIGINAL_PARAMS>) {
	if (/^\s*\`define\s+AHB_DATA_WIDTH\s+/) {
	  # Deal with the data width parameters,  The source for the new value depends on which 
	  # AHB bus we are dealing with
	  # AHB5 is the command bus, and this is parameterised with DMAH_S_DATA_WIDTH
	  if($AhbNumber == 5){
	    printf AHB_NEW_PARAMS "`define AHB_DATA_WIDTH %0d\n",$ccparams{'DMAH_S_HDATA_WIDTH'};
	  }
	  elsif($AhbNumber == 1){
	    # AHB1 is the bus with 15 slaves.  This is attached to master interface 1, but can 
	    # be randomly connected (by the Vera) to any other interface that has the same data
	    # width and AHB Lite setting
	    printf AHB_NEW_PARAMS "`define AHB_DATA_WIDTH %0d\n",$ccparams{'DMAH_M1_HDATA_WIDTH'};
	  }
	  elsif($AhbNumber == 2){
	    printf AHB_NEW_PARAMS "`define AHB_DATA_WIDTH %0d\n",$ccparams{'DMAH_M2_HDATA_WIDTH'};
	  }
	  elsif($AhbNumber == 3){
	    printf AHB_NEW_PARAMS "`define AHB_DATA_WIDTH %0d\n",$ccparams{'DMAH_M3_HDATA_WIDTH'};
	  }
	  elsif($AhbNumber == 4){
	    printf AHB_NEW_PARAMS "`define AHB_DATA_WIDTH %0d\n",$ccparams{'DMAH_M4_HDATA_WIDTH'};
	  }
	}
	elsif (/^\s*\`define\s+BIG_ENDIAN\s+/) {
	  printf AHB_NEW_PARAMS "`define BIG_ENDIAN %0d\n",$ccparams{'DMAH_BIG_ENDIAN'};
	}
	else {
	  print AHB_NEW_PARAMS $_;
	}
      }
      close AHB_ORIGINAL_PARAMS || die "$Pgm: ERROR - Failed to close $DW_ahb_original_params after read ($!)\n";
      close AHB_NEW_PARAMS || die "$Pgm: ERROR - Failed to close $DW_ahb_new_params after write ($!)\n";
      # Now move the new param file back to the original one
      system("mv -f $DW_ahb_new_params $DW_ahb_original_params");
    }

    # Now do it all again for the ahb lite busses.  There are only 4 of them
    foreach $AhbNumber (1..4){
      my $DW_ahb_original_params = "$TestbenchDir/ahb_lite".$AhbNumber."/src/DW_ahb_cc_constants.v";
      my $DW_ahb_new_params = "$TestbenchDir/ahb_lite".$AhbNumber."/src/DW_ahb_cc_constants.v_new";

      open(AHB_ORIGINAL_PARAMS,"< $DW_ahb_original_params") || die "$Pgm: ERROR - Can't open $DW_ahb_original_params ($!)\n";
      open(AHB_NEW_PARAMS,"> $DW_ahb_new_params") || die "$Pgm: ERROR - Can't open $DW_ahb_new_params ($!)\n";

      while (<AHB_ORIGINAL_PARAMS>) {
	if (/^\s*\`define\s+AHB_DATA_WIDTH\s+/) {
	  # Deal with the data width parameters,  The source for the new value depends on which 
	  # AHB bus we are dealing with
	  # AHB5 is the command bus, and this is parameterised with DMAH_S_DATA_WIDTH
	  if($AhbNumber == 5){
	    printf AHB_NEW_PARAMS "`define AHB_DATA_WIDTH %0d\n",$ccparams{'DMAH_S_HDATA_WIDTH'};
	  }
	  elsif($AhbNumber == 1){
	    # AHB1 is the bus with 15 slaves.  This is attached to master interface 1, but can 
	    # be randomly connected (by the Vera) to any other interface that has the same data
	    # width and AHB Lite setting
	    printf AHB_NEW_PARAMS "`define AHB_DATA_WIDTH %0d\n",$ccparams{'DMAH_M1_HDATA_WIDTH'};
	  }
	  elsif($AhbNumber == 2){
	    printf AHB_NEW_PARAMS "`define AHB_DATA_WIDTH %0d\n",$ccparams{'DMAH_M2_HDATA_WIDTH'};
	  }
	  elsif($AhbNumber == 3){
	    printf AHB_NEW_PARAMS "`define AHB_DATA_WIDTH %0d\n",$ccparams{'DMAH_M3_HDATA_WIDTH'};
	  }
	  elsif($AhbNumber == 4){
	    printf AHB_NEW_PARAMS "`define AHB_DATA_WIDTH %0d\n",$ccparams{'DMAH_M4_HDATA_WIDTH'};
	  }
	}
	elsif (/^\s*\`define\s+BIG_ENDIAN\s+/) {
	  printf AHB_NEW_PARAMS "`define BIG_ENDIAN %0d\n",$ccparams{'DMAH_BIG_ENDIAN'};
	}
	else {
	  print AHB_NEW_PARAMS $_;
	}
      }
      close AHB_ORIGINAL_PARAMS || die "$Pgm: ERROR - Failed to close $DW_ahb_original_params after read ($!)\n";
      close AHB_NEW_PARAMS || die "$Pgm: ERROR - Failed to close $DW_ahb_new_params after write ($!)\n";
      # Now move the new param file back to the original one
      system("mv -f $DW_ahb_new_params $DW_ahb_original_params");
    }
  }
  elsif($bus eq 'apb') {

    # -- Generate an override DW_apb_cc_constants file in the local
    # -- directory.This makes the DW_apb instance in the testbench
    # -- match up with the unpacked configuration of the peripheral
    # -- under test in the databus width, endiannenss and slave decode
    # -- address region areas

    print STDERR "$Pgm: Creating override DW_apb_cc_constants file: \n$Pgm:   file:$Cwd/DW_apb_cc_constants.v\n";
    my $DW_apb_default_params = "$TestbenchDir/apb/src/DW_apb_cc_constants.v";
    my $DW_apb_override_params = "./DW_apb_cc_constants.v";
    open(APB_DEFAULT_PARAMS,"< $DW_apb_default_params") || die "$Pgm: ERROR - Can't open $DW_apb_default_params ($!)\n";
    open(APB_OVERRIDE_PARAMS,"> $DW_apb_override_params") || die "$Pgm: ERROR - Can't open $DW_apb_override_params ($!)\n";
    while (<APB_DEFAULT_PARAMS>) {
      if (/^\s*\`define\s+APB_DATA_WIDTH\s+/) {
	printf APB_OVERRIDE_PARAMS "`define APB_DATA_WIDTH %0d\n",$ccparams{'APB_DATA_WIDTH'};
      } else {
	print APB_OVERRIDE_PARAMS $_;
      }
    }
    close APB_DEFAULT_PARAMS || die "$Pgm: ERROR - Failed to close $DW_apb_default_params after read ($!)\n";
    close APB_OVERRIDE_PARAMS || die "$Pgm: ERROR - Failed to close $DW_apb_override_params after write ($!)\n";
  }
  elsif($bus eq 'ahb') {

    # -- Generate an override DW_ahb_cc_constants file in the local
    # -- directory. This makes the DW_ahb instance in the testbench
    # -- match up with the unpacked configuration of the peripheral
    # -- under test in the databus width, endiannenss and slave
    # -- decode address region areas

    print STDERR "$Pgm: Creating override DW_ahb_cc_constants file: \n$Pgm:   file:$Cwd/DW_ahb_cc_constants.v\n";
    my $DW_ahb_default_params = "$TestbenchDir/ahb/src/DW_ahb_cc_constants.v";
    my $DW_ahb_override_params = "./DW_ahb_cc_constants.v";
    open(AHB_DEFAULT_PARAMS,"< $DW_ahb_default_params") || die "$Pgm: ERROR - Can't open $DW_ahb_default_params ($!)\n";
    open(AHB_OVERRIDE_PARAMS,"> $DW_ahb_override_params") || die "$Pgm: ERROR - Can't open $DW_ahb_override_params ($!)\n";
    while (<AHB_DEFAULT_PARAMS>) {
      if (/^\s*\`define\s+AHB_DATA_WIDTH\s+/) {
	printf AHB_OVERRIDE_PARAMS "`define AHB_DATA_WIDTH %0d\n",$ccparams{'AHB_DATA_WIDTH'};
      } elsif (/^\s*\`define\s+BIG_ENDIAN\s+/) {
	printf AHB_OVERRIDE_PARAMS "`define BIG_ENDIAN %0d\n",$ccparams{'BIG_ENDIAN'};
      } else {
	print AHB_OVERRIDE_PARAMS $_;
      }
    }
    close AHB_DEFAULT_PARAMS || die "$Pgm: ERROR - Failed to close $DW_ahb_default_params after read ($!)\n";
    close AHB_OVERRIDE_PARAMS || die "$Pgm: ERROR - Failed to close $DW_ahb_override_params after write ($!)\n";
  }




}

sub run_sim() {

  # -/ --------------------------------------------------------------
  # -/ This function generates and run the simulation command line
  # -/ for the selected simulator.
  # -/ --------------------------------------------------------------

  # -- Clean old log/wave/result files
  foreach (($DumpFile,$LogFile,$ResultFile)) {
    unlink($_) if (-e $_);
  }

  # -- Generate command script
  my @Commands;
  if ($Simulator eq "vcs" and $platform eq "HP-UX") { 
    my $CoverageFlags = ($Coverage) ? "-cm line+cond+fsm+assert -cm_hier ../cm_hier_config" : "";
    my $PlatformFlags = "-Mupdate=1";
# fk   @Commands = ("vcs -PP $PlatformFlags $CoverageFlags -vera_dbind -f $simcommand -f $plusargs",
# fk                "/bin/rm -fr *.o",
# fk                "./simv",
# fk                "rm -f simv");
    @Commands = ("vcs -Xbymod=4 -PP -vera $PlatformFlags $CoverageFlags  -f $simcommand ",
                 "./simv",
                 "rm -f simv");
  } elsif ($Simulator eq "vcs") { 
    my $CoverageFlags = ($Coverage) ? "-cm line+cond+fsm+assert -cm_hier ../cm_hier_config" : "";
    my $PlatformFlags = "-R";
    if ($use64bitSimulator) {
      $PlatformFlags .= " -full64";
    }
# fk    @Commands = ("vcs -PP $PlatformFlags $CoverageFlags -vera_dbind -f $simcommand -f $plusargs",
# fk                 "rm -f simv");
    @Commands = ("vcs -Xbymod=4 -PP -vera $PlatformFlags $CoverageFlags  -f $simcommand ",
                 "rm -f simv");

  } elsif ($Simulator eq "vcsi") { 
    my $CoverageFlags = ($Coverage) ? "-cm line+cond+fsm+assert -cm_hier ../cm_hier_config" : "";
    my $PlatformFlags = "-R";
    if ($use64bitSimulator) { $PlatformFlags .= " -full64"; }
    @Commands = ("vcsi -Xbymod=4 -PP -vera $PlatformFlags $CoverageFlags  -f $simcommand ",
                 "rm -f simv");

  } elsif ($Simulator eq "mti_verilog") {
    @Commands = ("/bin/rm -rf ./work_axi",
                 "vlib ./work_axi",
                 "vlog -work work_axi -f $simcommand -v $ENV{SYNOPSYS}/packages/gtech/src_ver/gtech_lib.v",
                 "vsim -c -pli ../veriuser.so -lib ./work_axi -do \"set IterationLimit 500000;run -all;quit\" +nowarnTFMPC +nowarnPCDPC test_${DesignName}");
  } elsif ($Simulator eq "verilog_xl") { 
    @Commands = ("../vera_xl -x -f $simcommand");
  } elsif ($Simulator eq "nc_verilog") { 
    if ($use64bitSimulator) {
       $sixtyfourbitswitch = "-64bit";
    }
# cg    @Commands = ("rm -f hdl.var cds.lib ncsim.args libpli.so libpli.sl",
# cg                 "ln -s ../libpli.so .",
# cg                 "ln -s ../libpli.sl .",
# cg                 "ncprep +overwrite -f $simcommand -f $plusargs",
# cg                 "ncvlog -f ncvlog.args",
# cg                 "../vera_ncelab -f ncelab.args -access +rw",
# cg                 "../vera_ncsim -hdlvar hdl.var -cdslib cds.lib -f ncsim.args");
    @Commands = ("rm -f hdl.var cds.lib ncsim.args libpli.so libpli.sl",
                 "ln -s ../libpli.so .",
                 "ln -s ../libpli.sl .",
                 "ncprep +nclicqueue +overwrite -f $simcommand",
                 "ncvlog $sixtyfourbitswitch -f ncvlog.args",
                 "ncelab $sixtyfourbitswitch -f ncelab.args -access +rw",
                 "ncsim -LICQUEUE $sixtyfourbitswitch -hdlvar hdl.var -cdslib cds.lib -f ncsim.args");
  } elsif ($Simulator eq "scirocco") { 
      if (!(-e "../../scratch/scirocco_workdir")) {
        system("mkdir ../../scratch/scirocco_workdir");
      }
      @Commands = ("make -f Makefile_sro_gtech",
                   "scs test_${DesignName}_conf",
                   "scsim -include ./sro_run.inc");
  } elsif ($Simulator eq "mti_vhdl") {
#      if (!(-e "../../scratch/mti_workdir")) {
#        system("mkdir -p ../../scratch/mti_workdir");
#      }
      my $DW_LIB_MTI_PATH = "/usr/bin";
      if (`type vsim` =~ /.* (.*)\/bin\/.*/ ) {
        $DW_LIB_MTI_PATH = $1;
      } else {
        die "$Pgm: ERROR - Cannot find the std directory in the MTI path $DW_LIB_MTI_PATH.\n";
      }
      my $MtiRunCommand;
      if ($newDumpEnabled == 1) {
        $MtiRunCommand = "vsim -c -lib $MTIWorkDir/mti_workdir -do \"set IterationLimit 500000;vcd file ./$DumpFile; vcd add -r *; run -a; quit \" test_${DesignName}";
      } else {
        $MtiRunCommand = "vsim -c -lib $MTIWorkDir/mti_workdir -do \"set IterationLimit 500000;run -a; quit \" test_${DesignName}";
      }
     @Commands = ("vlib $MTIWorkDir/mti_workdir",
                  "vmap GTECH $MTIWorkDir/mti_workdir",
                  "vmap DWARE $MTIWorkDir/mti_workdir",
                  "vmap IEEE $MTIWorkDir/mti_workdir",
                  "vmap SYNOPSYS $MTIWorkDir/mti_workdir",
                  "make -f ./Makefile_mti_gtech DW_LIB_MTI_PATH=$DW_LIB_MTI_PATH",
                  "$MtiRunCommand");
   } elsif ($Simulator eq "nc_vhdl") {
      if (!(-e "../../scratch/ncvhdl_workdir")) {
        system("mkdir ../../scratch/ncvhdl_workdir");
      }
      if (!(-e "../../scratch/ncvhdl_workdir/synopsys")) {
        system("mkdir ../../scratch/ncvhdl_workdir/synopsys");
      }
      if (!(-e "../../scratch/ncvhdl_workdir/ieee")) {
        system("mkdir ../../scratch/ncvhdl_workdir/ieee");
      }
      if (!(-e "../../scratch/ncvhdl_workdir/dware")) {
        system("mkdir ../../scratch/ncvhdl_workdir/dware");
      }
      if (!(-e "../../scratch/ncvhdl_workdir/gtech")) {
        system("mkdir ../../scratch/ncvhdl_workdir/gtech");
      }
      if (!(-e "../../scratch/ncvhdl_workdir/ahb_inst")) {
        system("mkdir ../../scratch/ncvhdl_workdir/ahb_inst");
      }
      if (!(-e "../../scratch/ncvhdl_workdir/apb_inst")) {
        system("mkdir ../../scratch/ncvhdl_workdir/apb_inst");
      }
      if (!(-e "../../scratch/ncvhdl_workdir/dut_inst")) {
        system("mkdir ../../scratch/ncvhdl_workdir/dut_inst");
      }
      if (!(-e "../../scratch/ncvhdl_workdir/cmp_source")) {
        system("mkdir ../../scratch/ncvhdl_workdir/cmp_source");
      }

      @Commands = ("make -f ./Makefile_ncvhdl_gtech",
                   "ncelab -V93 test_${DesignName}:test_${DesignName}_ARCH -MESSAGES",
                   "ncsim  -input ./tcl.inp test_${DesignName}:test_${DesignName}_ARCH -MESSAGES");


  } else {
    die "$Pgm: ERROR - Unknown simulator $Simulator not yet supported.\n";
  }
  
 
  my $cmd_file = "test.startsim";
  print STDERR "$Pgm: Creating simulation start script $Test/$cmd_file containing:\n";
  open(CMD,">$cmd_file") or die "$Pgm: ERROR - can't write startsim script \"$cmd_file\"\n";
  foreach my $cmd (@Commands) {
    print CMD "$cmd\n";
    print STDERR "$Pgm:    % $cmd\n";
  }
  close(CMD);

  # -- make command file executable
  system("chmod ugo+rx $cmd_file");

  # -- exit if you only want the scripts
  exit(0) if $Pretend;

  # -- print header and start time
  my $startdate = `date`; chomp $startdate;
  print STDERR "$Pgm: Running $Test/$cmd_file at $startdate\n";

  print STDERR "\n\n+------------------------+\n| Simulation Execution   |\n+------------------------+\n\n";
  print STDERR "(this section of runtest.log supplied by $Test/$cmd_file script)\n\n\n";

  # -- run command file
  my_system("./$cmd_file < /dev/null 2>&1 | tee $LogFile");

  # -- print end time and tail
  my $enddate = `date`; chomp $enddate;
  print STDERR "\n\n\n+--------------------+\n| Simulation Results |\n+--------------------+\n\n";
  print STDERR "$Pgm: Completed simulation at $enddate\n";
  print STDERR "$Pgm: The above simulation output was also saved to $LogFile : \n$Pgm:   file:$Cwd/$LogFile\n";

}


sub postprocess() {

  my $errorConditions = "";
  my $errorExceptions = "";
  my $errorFile = "../html_extraction_config_file";
  my @configFileContents = ();
  open (CF, "<${errorFile}");
  @configFileContents = <CF>;
  close(CF);
  chomp(@configFileContents);
  foreach (@configFileContents) {
    if (/errorConditions:"(.*?)"/) {
      $errorConditions = $1;
    }
    if (/errorExceptions:"(.*?)"/) {
      $errorExceptions = $1;
    }
  }
  # -/ --------------------------------------------------------------
  # -/ This function parses the simulation log files and reports a
  # -/ test pass or fail status
  # -/ --------------------------------------------------------------
  `/bin/rm -rf passed failed timeout`;
  `/bin/rm -fr ../passed/$Test`;
  `/bin/rm -fr ../timeout/$Test`;
  `/bin/rm -fr ../failed/$Test`;

  open (RESULT,">$ResultFile") || die "$Pgm: ERROR: can't open result file $ResultFile for write\n";
  my $result;
  if(check_completed() & ! check_errors()) {
    `touch passed`;
    `touch ../passed/$Test`;
    $result = "PASSED";
    if(&check_warnings()) {
      if (&check_illegal_prog()) {
        $result .= " (WARNINGS and ILLEGAL PROGRAMMING)";
      } else {
        $result .= " (WARNINGS)";
      }
    } else {
      if (&check_illegal_prog()) {
        $result .= " (ILLEGAL PROGRAMMING)";
      }
    }
  `/bin/rm -rf simv simv.daidir csrc`;
  } else {
    $result = "FAILED";
    if(&check_timeouts()) {
      $result .= " (TIMEOUT)";
      `touch timeout`;
      `touch ../timeout/$Test`;
    } else {
      `touch failed`;
      system("egrep -i  \"$errorConditions\" test.log | egrep -iv \"$errorExceptions\" | head -1 > ../failed/$Test");
    }
  }
  print RESULT "$result \n";

  close RESULT || die "$Pgm: ERROR: can't close result file $ResultFile after write\n";
  print STDERR "$Pgm: Final result in ${Test}/${ResultFile} - Result is \"$result\"\n\n";
  printf STDERR "Result:  %-19s  Test: $Summary\n\n","\"$result\"";

}

sub convertPath($ ) {

  # -/ --------------------------------------------------------------
  # -/ ConvertPath(path) determine the absolute root of the current
  # -/ and converts the supplied dirpath/filepath to relative to the
  # -/ test directory where the simulation is being run.
  # -/ All default file locations are calculated relative to the
  # -/ test directory, so we need to adjust those provided from the
  # -/ invoking directory and migrate any absolute ones to relative
  # -/ if possible.
  # -/
  # -/ This script is assumed to be located in $coreKit/sim and we
  # -/ have now chdir'ed one level further down into a Test
  # -/ subdirectory so to find the coreKit we go two levels up using
  # -/ (dirname(dirname $Cwd))
  # -/
  # -/ The routine also removes duplicate or trailing slashes to keep
  # -/ VCS happy Note - the routine also promises to convert <undef>
  # -/ to <undef>
  # -/ --------------------------------------------------------------

  my $path = shift;
  return undef unless defined($path);
  $path =~ s|^<coreKit>/|$coreKit/|;
  $path =~ s|^$coreKit/sim/|../|;
  $path =~ s|^$coreKit/|../../|;
  $path =~ s|//|/|g;
  $path =~ s|/$||;
  return $path;
}


sub check_errors() {

  # -/ --------------------------------------------------------------
  # -/ look through log files for for lines with the word 'error' or
  # -/ 'fatal' in their first N characters, ie chances are they are
  # -/ error messages of some form. This is a strict and safe
  # -/ catch-all and may match on completely innocent lines.
  # -/ --------------------------------------------------------------

  my $errorConditions = "";
  my $errorExceptions = "";
  #my $errorFile = "../simulation_analysis_config_file";
  my $errorFile = "../html_extraction_config_file";
  my @configFileContents = ();
  open (CF, "<${errorFile}");
  @configFileContents = <CF>;
  close(CF);
  chomp(@configFileContents);
  foreach (@configFileContents) {
    if (/errorConditions:"(.*?)"/) {
      $errorConditions = $1;
    }
    if (/errorExceptions:"(.*?)"/) {
      $errorExceptions = $1;
    }
  }
  my $rv = 0;
  my $errors = 0;
  my @errors = "";

#  @errors = `egrep -i \"error|fatal\" $LogFile | grep -v Region: | grep -v -i \"errors: 0\" | grep -v -i \"Total error\" | grep -v -i vca_error |  grep -v -i "ErrorStop"  | grep -iv "strerror" | grep -iv "warning" | grep -iv \"m_envStatusError\" | grep -iv \"PROTO_ERROR\" | grep -iv "librterrorinf.so"`;
  @errors = `egrep -i  \"$errorConditions\" $LogFile | egrep -iv \"$errorExceptions\"`;
  foreach(@errors) { $errors++; }

  # -/ --------------------------------------------------------------
  # -/ Catch vcs warnings that should be considered failures.
  # -/ i.e. could be a failure to a third party tool.
  # -/ --------------------------------------------------------------
  my $error_warnings = 0;

 # This is a compile time warning - So code like ( in X2H )
 #         if (`X2H_AXI_ADDR_WIDTH == 64)
 #            mhaddr  =  mhaddr_reg;
 #          else
 #            mhaddr  = {{(64-`X2H_AXI_ADDR_WIDTH){1'b0}},mhaddr_reg};
 # will still give a warning when `X2H_AXI_ADDR_WIDTH == 64
 # as the compiler seems to parse both
 # branches of the if statement regardless of the X2H_AXI_ADDR_WIDTH
 # value. This may be new to VCS 2006.06! and is causing sims to fail

 # my @error_warnings = `egrep -i \"ZONMCM\" $LogFile`;
   my @error_warnings;

  foreach(@error_warnings) { $error_warnings++; }

  if (($errors > 0) || ($error_warnings > 0)) {
    $rv = 1;
  }

  return $rv;

}


sub check_warnings() {

  # -/ --------------------------------------------------------------
  # -/ Find warnings other than:
  # -/ a. runtest warnings
  # -/ b. inout coercion
  # -/ --------------------------------------------------------------

  my $warnings = 0;
  my @warnings = `grep -i warn $LogFile | grep -v runtest | grep -v coercing | grep -v \"WARNING - VERA MEMORY model\" | grep -v \"ACC/CLI capabilities have been enabled\" | grep -v "Total warnings: 0"`;
  foreach(@warnings) { $warnings++; }
  return $warnings;

}

sub check_illegal_prog() {

  # -/ --------------------------------------------------------------
  # -/ Finds illegal programming:
  # -/ --------------------------------------------------------------

  my $illegal_prog = 0;
  my @illegal_prog = `grep ILLEGAL_PROG $LogFile`;
  foreach(@illegal_prog) { $illegal_prog++; }
  return $illegal_prog;

}


sub check_timeouts() {

  # -/ -------------------------------------------------------------- 
  # -/ Find timeout and return N
  # -/ --------------------------------------------------------------

  my $timeouts = 0;
  my @timeouts = `grep TIMEOUT $LogFile | grep -v "+TIMEOUT"`;
  foreach(@timeouts) { $timeouts++; }
  return $timeouts;

}


sub check_completed() {

  # -/ --------------------------------------------------------------
  # -/ Find completion message and return true/false
  # -/ --------------------------------------------------------------

  my @completed = `grep "User test stimulus has completed" $LogFile`;
  if($#completed >= 0) {
    return 1;
  } else {
    return 0;
  }

}

sub manageMCDFile() {
    # This subroutine creates a 'vmt_mcd.cfg' file in the test directory if required.
    # First step is to always remove any old vmt_mcd.cfg file
    `rm -fr vmt_mcd.cfg`;
    # If GenerateMCDFile is 1, create the .cfg file
    if ($GenerateMCDFile == 1) {
      `touch vmt_mcd.cfg`;
    }
}

sub my_system($) {

  # -/ --------------------------------------------------------------
  # -/ my_system() - a system call with success/fail check plus
  # -/ Pretend/Verbose support
  # -/ --------------------------------------------------------------

  my $cmd = shift;

  if($Pretend or $Verbose) {
    printf STDERR "$Pgm: running \"$cmd\"\n";
  }
  unless ($Pretend) {
    system($cmd);
    die "$Pgm: ERROR - command \"$cmd\" failed, exit code $?\n" if($?);
  }

}


sub check_array_param($$) {

  # -/ --------------------------------------------------------------
  # -/ Check to see if a particular item is a member of a set
  # -/ Currently supported sets are: Positive Integers. Support could
  # -/ easily be added for negative integers and collatable character
  # -/ strings if required. Set syntax consists of a string containing
  # -/ any combination of comma-separated lists and hyphen separated
  # -/ ranges, eg "1" or "1,2" or "0-15" or "0-3,5,8,11-15"
  # -/ The empty set is denoted by a zero-length string ""
  # -/ --------------------------------------------------------------

  my $item = shift;
  my $set = shift;

  # -- Remove any surplus whitespace 
  $set =~ s/\s+//g;

  # -- Split the set into comma-separated chunks first of all
  my @set = split( /,/, $set);

  # -- Loop on each chunk
  foreach my $chunk (@set) {

    # -- Is it a range or a single item
    if ($chunk =~ /([0-9]+)-([0-9]+)/) {

      # -- Range - Check that it is a valid range
      die "$Pgm: ERROR - Invalid set range \"$chunk\" in set \"$set\"\n" if ($2 < $1);

      # -- Range - return true if item is within range
      return 1 if (($item >= $1) and ($item <= $2));
    } elsif ($chunk =~ /[0-9]+/) {

      # -- return true if item matches
      return 1 if ($chunk == $item);
    } elsif ($chunk ne '') {
      die "$Pgm: ERROR - Invalid set argument \"$chunk\" in set \"$set\"\n";
    }
  }
  # -- return false if we got to the end without a match
  return 0;

}


sub convert_define_radix($) {
  
  # -/ --------------------------------------------------------------
  # -/ Convert a string containing a verilog `define format number to
  # -/ a string containing a vera-format number of the same radix e.g.
  # -/ NN`bXXXX -> 0xXXXX
  # -/ Do not do any other checking for validity
  # -/ --------------------------------------------------------------

  my $value_str = shift;
  $value_str =~ s/^([0-9]*)\'h([0-9a-fA-F]+)$/0x$2/;
  $value_str =~ s/^([0-9]*)\'d[0]*([0-9]+)$/$2/;
  $value_str =~ s/^([0-9]*)\'o([0-7]+)$/0$2/;
  $value_str =~ s/^([0-9]*)\'b([0-1]+)$/0b$2/;
  return $value_str;

}
			 
sub fetch_module_name() {

  # -/ --------------------------------------------------------------
  # -/ This function grabs the name of the top level design module.
  # -/ Since there is more than one file here now we elimate the shell
  # -/ h2h has named files as _input.v and _strings.v eliminate these
  # -/ --------------------------------------------------------------

  my $waste;

  $ModName = `echo ./testbench/*.v`;
  chomp $ModName;
  $ModName = (basename $ModName);
  $ModName =~ s/test_//;
  $ModName =~ s/_shell//;
  $ModName =~ s/_input//;
  $ModName =~ s/_strings//;
  ($ModName, $waste) = split ('.v', $ModName);

}

# End


# -/ ==================================================================
# -/
# -/                          SUBROUTINES
# -/                        Vera Compilation
# -/
# -/ ==================================================================

sub run_dw_vip_setup {

   #
   # check if dw_vip_setup has been called already
   #

   system("which vera > vera_version.tmp");
   if(!(-f ".vera_version_prev"))
   {
   system("which vera > .vera_version_prev");
   }

   system("date");
   my $designware_home = "";

   my $vmtFileName = "vmt_version";
   my $vmt_version = "";
   my @vmtFileContents;

   if (defined $ENV{'DESIGNWARE_HOME'} ) {
     $designware_home = $ENV{'DESIGNWARE_HOME'};
   } else {
     print "ERROR: DESIGNWARE_HOME is not defined.\n";
     compile_exit(2);
   }
   if (!(-e "${designware_home}/bin/dw_vip_setup")) {
     print "ERROR:  dw_vip_setup script not found.  Check setting of DESIGNWARE_HOME.\n";
     compile_exit(2);
   }

   #
   # Check if VRO_CACHE_DIR is defined.
   #
   unless(defined $ENV{'VRO_CACHE_DIR'}) {
     #    
     # Check if DESIGNWARE_HOME is a writable location
     if(system("touch $designware_home/vip/xx_dwh_writable.xx > /dev/null 2>&1")) {
       print "\nWARNING: Env variable VRO_CACHE_DIR is not defined and DESIGNWARE_HOME is not writable\n";
       print "         Setting Env variable VRO_CACHE_DIR to $ENV{VERA_VRO_CACHE} - compiled vip will be placed here\n";
       $ENV{VRO_CACHE_DIR} = $ENV{VERA_VRO_CACHE};
     } else {
       system("\rm -rf $designware_home/vip/xx_dwh_writable.xx");
     }
   }

   if (!(-e "$vmtFileName")) {
     print "ERROR: vmt_version file missing!\n";
     compile_exit(2);
   } else {
   # open the file
     open(VMT_VERSION, "<$vmtFileName");
     @vmtFileContents = <VMT_VERSION>;
     close(VMT_VERSION);
     chomp(@vmtFileContents);
     $vmt_version = $vmtFileContents[0];
   }

   printf STDERR "\n - VIP/VMT Version Information\n";
   printf STDERR "   - vmt_version:\n     - $vmt_version\n";
   printf STDERR "   - vip_model_list:\n";
   my @models = `cat ./vmt_model_list`;
   foreach(@models) { printf STDERR "     - $_"; }
   printf STDERR "\n";
   
   if(-f "../scratch/.dw_vip.cfg")
   {
      # filter .dw_vip.cfg to get a model list file
      system("grep '^%MOD' ../scratch/.dw_vip.cfg | sed 's:%MOD ::' | sed 's:amba:-v:' > vmt_model_list.tmp");

      # compare with the actual model list file
      if(system("diff vera_version.tmp .vera_version_prev  > vera_version.diff"))
      {
         printf STDERR "calling dw_vip_setup to refresh headers in ../scratch \n";
         system("$designware_home/bin/dw_vip_setup -path ../scratch -vmt $vmt_version -a -m vmt_model_list");
         system("which vera > .vera_version_prev");
         $VeraForceCompile = 1;
      }
      elsif(system("diff vmt_model_list.tmp vmt_model_list > vmt_model_list.diff"))
      {
         printf STDERR "calling dw_vip_setup to refresh headers in ../scratch \n";
         system("$designware_home/bin/dw_vip_setup -path ../scratch -vmt $vmt_version -a -m vmt_model_list");
         system("which vera > .vera_version_prev");
      }
      else
      {
         printf STDERR "skipping dw_vip_setup call. Headers already in ../scratch\n";
      }
   }
   else
   {
      printf STDERR "calling dw_vip_setup to create headers in ../scratch \n";
      if (system("$designware_home/bin/dw_vip_setup -path ../scratch -vmt $vmt_version -a -m vmt_model_list"))
      {
        system("which vera > .vera_version_prev");
        compile_exit(2);
      }
   }
   system("rm -f vmt_model_list.*");
   system("rm -f vera_version.tmp");
   system("rm -f vera_version.diff");
   system("date");
}


sub compile_vera {

    my ( $test ) = @_;

    my @file_list;
    my $file;
    my $path;

    $path = "..";

    @vera_include_list = add_include_list("$path/../scratch/include/vera"); # headers for VMT models
    @vera_include_list = add_include_list("$path/testbench");               # headers private to the corekit testbench
    @vera_include_list = add_include_list("$path/vera/include");            # headers from imported vera libraries (harness)
    @vera_include_list = add_include_list("$path/$test");                   # header for the test task file

    @file_list = get_file_list_by_ext("$path/testbench", "vrp");
    foreach $file ( @file_list ) {
       generate_vro($file, "$path/testbench");
    }

    @file_list = get_file_list_by_ext("$path/vera/src", "vrp");
    foreach $file ( @file_list ) {
       generate_vro($file, "$vera_vro_cache/$vera_vmc_version/$DesignName");
    }

    @file_list = get_file_list_by_ext("$path/$test", "vrp");
    foreach $file ( @file_list ) {
       generate_vro($file, "$path/$test");
    }
}

sub compile_check_environment {

    #
    # Check VERA_HOME variable and Vera installation
    #
    if ( defined $ENV{'VERA_HOME'} ) {
        $vera_home = $ENV{'VERA_HOME'};
    } 
    else {
        print "ERROR:  VERA_HOME is not set.\n";
        compile_exit( 10 );
    }

    #
    # Check VERA_VRO_CACHE variable 
    #
    if ( defined $ENV{'VERA_VRO_CACHE'} ) {
        $vera_vro_cache = $ENV{'VERA_VRO_CACHE'};
    } 
    else {
        print "ERROR:  VERA_VRO_CACHE is not set.\n";
        compile_exit( 10 );
    }

    #
    # Get VMC version of this Vera installation
    
    chomp( $vera_vmc_version = `vera -vmc` );
    if ( $vera_vmc_version !~ /\d\.\d/ ) {
        print "ERROR:  Could not determine Vera VMC version.\n";
        compile_exit( 2 );
     }
}

sub generate_vro {

    my ( $source, $dest_dir ) = @_;

    #
    # Compile encrypted source code
    #
    my $base;
    my $status;
    my $vera_cmd;
    my $source_dir;
   
    $base = basename( $source, ".vrp" );
    $source_dir = dirname( $source, ".vrp" );

    if ( ! -d "$dest_dir" ) {
        $status = system( "mkdir -p $dest_dir " );
	if ( $status ) {
            print "ERROR:  Could not create directory '$dest_dir'.\n";
            compile_exit( 20 );
	}
    }

    # compile only if :
    # the .vro does not exist in $dest_dir
    # OR VeraForceCompile is enabled
    # OR VeraForceCompileMain is enabled and the source is the Vera program.
    # By default VeraForceCompile=0 and VeraForceCompileMain=1 to make sure
    # that the main program .vro (and vthe derived vera shell) are always in 
    # line with the environment.
    if ( !( -f "$dest_dir/$base.vro") || ($VeraForceCompile == 1) || ( ($VeraForceCompileMain == 1) && ($base eq "test_${DesignName}") ) ) {

        if ( ! -w "$dest_dir" ) {
            print "ERROR:  Directory '$dest_dir' not writable.\n";
            compile_exit( 31 );
        }
 
        $vera_cmd  = "vera -cmp -vip -q -ip -cs ";
        $vera_cmd .= "@vera_include_list ";
        $vera_cmd .= "$source ";
        $vera_cmd .= "$dest_dir ";

	print "  compiling encrypted source - vera -cmp -vip $base.vrp\n";
	#print "  $vera_cmd\n";

        $status = system( $vera_cmd );
        if ( $status ) {
            print "ERROR:  Failure during Vera compilation.\n";
            compile_exit( 10 );
        }
    }
    else {
	print "  compilation skipped : object $base.vro already in cache.\n";
    }
}


sub generate_vrl() {

    my $status;

    if ( ! -w "." ) {
        print "ERROR:  Directory  $Cwd/$Test not writable.\n";
        compile_exit( 31 );
    }

    # .vros from the cache
    $status  = system( "rm -f test_${DesignName}.vrl" );
    $status  = system( "touch test_${DesignName}.vrl" );

    if ( -e "$vera_vro_cache/$vera_vmc_version/$DesignName" ) {
      $status += system( "ls $vera_vro_cache/$vera_vmc_version/$DesignName/*.vro >> test_${DesignName}.vrl" );
    }

    # .vros from the test directory
    $status += system( "ls ./*.vro >> test_${DesignName}.vrl" );

    # .vros from the testbench directory
    $status += system( "ls ../testbench/*.vro >> test_${DesignName}.vrl" );

    if ( $status ) {
        print "ERROR:  Could not create file test_${DesignName}.vrl.\n";
        compile_exit( 2 );
    }
}

# Added to generate the .proj and the .vcon files on the fly.
# This is required for some of the new corekits (DMA) that are 
# packaged without the trivial .proj and .vcon replicated across
# all test directories.
sub generate_proj() {

    my $status;

    if ( ! -w "." ) {
        print "ERROR:  Directory  $Cwd/$Test not writable.\n";
        compile_exit( 31 );
    }

    if ( ! -f "test_${DesignName}.proj" ) {
        print "  touching trivial Vera vcon test_${DesignName}.vcon\n";
        $status = system( "touch test_${DesignName}.vcon" );
        print "  generating trivial Vera proj test_${DesignName}.proj\n";
        open(proj_file,"> test_${DesignName}.proj") || die "$Pgm: ERROR - Can't open test_${DesignName}.proj ($!)\n";
        printf proj_file "// This file is created each time by runtest\n";
        printf proj_file "main test_${DesignName}\n";
        printf proj_file " test_${DesignName}.vrl\n";
        printf proj_file " test_${DesignName}.vcon\n";
        close(proj_file);
    }
}

# Added to generate the vera shell on the fly. This is required to expand
# Vera shell parameters according to the user environment (DW home, VMT 
# VIP library version, AMBA VIP library version, VERA VMC version etc.)
sub generate_vshell {

    my $simchoice = $_[0];
    my $status;
    my $vshell = "test_${DesignName}_shell.v";
    my $vhdl_vshell = "test_${DesignName}_proj_shell.vhd";
    my $vhdl_vshell_output = "test_${DesignName}_shell_mti.vhd";
    my $vhdl_vshell_output_ncvhdl = "test_${DesignName}_shell_ncv.vhd";
    my $vhdl_vshell_output_sro = "test_${DesignName}_shell_sro.vhd";

    my $vera_cmd = "vera -proj test_${DesignName}.proj";
    my $vera_cmd_mti = "vera -mti -proj test_${DesignName}.proj";
    my $vera_cmd_ncvhdl = "vera -nc_vhdl -proj test_${DesignName}.proj";
    my $vera_cmd_sro = "vera -sro -proj test_${DesignName}.proj";

    my $dummy_period_hclk = "123456.0";
    my $dummy_halfperiod_hclk = "61728";

    my $dummy_period_pclk = "654321.0";
    my $dummy_halfperiod_pclk = "327160";

    my $dummy_halfperiod_pclk_ncvhdl = "3.271605e+05";
    my $dummy_halfperiod_hclk_ncvhdl = "6.172800e+04";

    my $hclk_halfperiod = $Period / 2 ;
    my $pclk_halfperiod = ($Period * $ApbClockRatio) /2 ;
    my $status_mti;

    my $status_ncvhdl;

    my $status_sro;
    my $inputLine;
    my $declarationsFound;

    if ( ! -w "." ) {
        print "ERROR:  Directory  $Cwd/$Test not writable.\n";
        compile_exit( 31 );
    }

    &generate_proj();

    if (($simchoice eq "vcs") || ($simchoice eq "vcsi") || ($simchoice eq "verilog_xl") || ($simchoice eq "nc_verilog") || ($simchoice eq "mti_verilog")) {
      print "  generating Vera shell $vshell\n";
      $status = system( $vera_cmd );
      if ( $status ) {
          print "ERROR:  Failure during Vera shell generation.\n";
          compile_exit( 10 );
      }
      # postprocess the vera shell to set user defined clock period and clock ratios

      else {
          $status += system("sed 's/$dummy_period_hclk/$Period/' $vshell > $vshell.tmp");
          $status += system("sed '/^vmcclk*/ s/0;/1;/g' $vshell.tmp > $vshell.tmp1");
          $status += system("sed 's/$dummy_period_pclk/($Period*$ApbClockRatio)/' $vshell.tmp1 > $vshell");
          $status += system("rm -f $vshell.tmp $vshell.tmp1");
      }
    } elsif ($simchoice eq "mti_vhdl") {
      print "  generating Vera shell for MTI_VHDL\n";
      $status_mti = system( $vera_cmd_mti );
      if ( $status_mti ) {
          print "ERROR:  Failure during Vera shell generation for MTI_VHDL.\n";
          compile_exit( 10 );
      } else {
          $status_mti += system("sed 's/$dummy_halfperiod_hclk/$hclk_halfperiod/' $vhdl_vshell > $vhdl_vshell.tmp");
          $status_mti += system("sed '/initial_value =>*/ s/0/1/g' $vhdl_vshell.tmp > $vhdl_vshell.tmp1
");
          $status_mti += system("sed 's/$dummy_halfperiod_pclk/$pclk_halfperiod/' $vhdl_vshell.tmp1 > $vhdl_vshell_output");
          $status_mti += system("rm -f $vhdl_vshell.tmp $vhdl_vshell.tmp1 $vhdl_vshell");
      }
    } elsif ($simchoice eq "nc_vhdl") {
      print "  generating Vera shell for NC_VHDL\n";
      $status_ncvhdl = system ( $vera_cmd_ncvhdl );
      if ($status_ncvhdl) {
          print "ERROR : Failure during Vera shell generation for NC_VHDL.\n";
          compile_exit( 10 );
      } else {
          $status_ncvhdl += system("sed 's/$dummy_halfperiod_hclk_ncvhdl/$hclk_halfperiod/' $vhdl_vshell > $vhdl_vshell.tmp");
          $status_ncvhdl += system("sed 's/$dummy_halfperiod_pclk_ncvhdl/$pclk_halfperiod/' $vhdl_vshell.tmp > $vhdl_vshell.tmp1");
          $status_ncvhdl += system("sed '/vera_clk_dut_apb_if_pclk <= */ s/0/1/g' $vhdl_vshell.tmp1 > $vhdl_vshell.tmp2");
          $status_ncvhdl += system("sed '/vera_clk_dut_apb_if_hclk <= */ s/0/1/g' $vhdl_vshell.tmp1 > $vhdl_vshell_output_ncvhdl");
          $status_mti += system("rm -f $vhdl_vshell.tmp $vhdl_vshell.tmp1 $vhdl_vshell.tmp2 $vhdl_vshell");
      }
    } elsif ($simchoice eq "scirocco") {
        print "  generating Vera shell for Scirocco\n"; 
      $status_sro = system ($vera_cmd_sro);
      if ($status_sro) {
        print "ERROR : Failure during Vera shell generation for Scirocco.\n";
        compile_exit (10);
      } else {
          $status_sro += system("sed 's/$dummy_halfperiod_hclk/$hclk_halfperiod/' $vhdl_vshell > $vhdl_vshell.tmp");
          $status_sro += system("sed 's/$dummy_halfperiod_pclk/$pclk_halfperiod/' $vhdl_vshell.tmp > $vhdl_vshell.tmp1");
          $status_sro += system("sed '/initial_value =>*/ s/0/1/g' $vhdl_vshell.tmp1 > $vhdl_vshell.tmp2");
          $declarationsFound = 0;
  
         open(INPUTFILE, "<$vhdl_vshell.tmp2") || die "Could not open $vhdl_vshell.tmp2 for reading\n";
         open(OUTPUTFILE, ">$vhdl_vshell.tmp3") || die "Could not open $vhdl_vshell.tmp3 for writing\n";
         $inputLine = "";
         until ($inputLine =~ "ENTITY test_${DesignName}_shell IS") {
           $inputLine = <INPUTFILE>;
           print OUTPUTFILE $inputLine;
         }
         until ($inputLine =~ /\)\;/) {
           $inputLine = <INPUTFILE>;
           print OUTPUTFILE $inputLine;
         }

         until ($inputLine =~ /END\;/) {
           $inputLine = <INPUTFILE>;
           if (($inputLine =~ "dut_apb_if_pclk") || ($inputLine =~ "dut_ahb_if_hclk"))  {
             $declarationsFound = 1;
           }
         }

         if ($declarationsFound == 0) {
           print OUTPUTFILE "     PORT ( \n";
           print OUTPUTFILE "       SIGNAL dut_ahb_if_hclk : OUT std_logic;\n";
           print OUTPUTFILE "       SIGNAL dut_apb_if_pclk : OUT std_logic\n";
           print OUTPUTFILE "     );\n";
         }
         print OUTPUTFILE $inputLine;
         until (eof(INPUTFILE)) {
           $inputLine = <INPUTFILE>; 
           print OUTPUTFILE $inputLine;
         }
         close (OUTPUTFILE);
         close (INPUTFILE); 
         if ($declarationsFound == 0) {
           system ("sed 's/clk_out => clkg_1_1/clk_out => dut_ahb_if_hclk/' $vhdl_vshell.tmp3 > $vhdl_vshell.tmp4");
           system ("sed 's/clk_out => clkg_2_1/clk_out => dut_apb_if_pclk/' $vhdl_vshell.tmp4 > $vhdl_vshell.tmp5");
           system ("mv $vhdl_vshell.tmp5 $vhdl_vshell_output_sro");
         } else {
           system ("mv $vhdl_vshell.tmp3 $vhdl_vshell_output_sro");
         }
         system("rm -fr $vhdl_vshell.* $vhdl_vshell");
       }
    }
}

sub get_file_list_by_ext {

    my ( $file_dir, $file_ext ) = @_;

    my @file_list;

    if ( ! -e $file_dir ) {
	@file_list = ();
	return( @file_list );
    }

    if ( ! opendir( D, $file_dir ) ) {
        print "ERROR:  Could not open VR file_dir '$file_dir'.\n";
        compile_exit( 12 );
    }

    @file_list = grep( /.$file_ext$/, readdir( D ) );

    closedir( D );

    if ( defined @file_list ) {
        @file_list = map { $file_dir . "/" . $_ } @file_list;
    }
    else {
	@file_list = ();
    }

    return( @file_list ); 

}

sub add_include_list {

    my ( $include_dir ) = @_;

    #
    # add an element to the include list global 
    # variable used for for the vera compilation
    #
    $vera_include_list[$#vera_include_list+1] = "-I$include_dir";

    #print "include_list=@vera_include_list\n";
    return( @vera_include_list ); 
}

sub compile_exit {

    my ( $code ) = @_;

    if($code == 0) {
    }
    else {
       exit( $code );
    }
}
