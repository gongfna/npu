#@ # 
#@ # Running rt_shell Version K-2015.06-SP5 for linux64 -- Feb 23, 2016
#@ # Date:   Tue Aug 28 10:19:46 2018
#@ # Run by: mzm@wusystem-eda
#@ 

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/doc/dware/AMBA/amba.tcl

#@ namespace eval AMBA {
#@ 
#@   proc Launch {} {
#@ 
#@     if {[string equal [get_workspace_name -quiet] ""]} {
#@       set result [msg_box -icon question                           -msgType yesno                           "The AMBA Subsystem Assembly Wizard cannot be started until you have created a workspace.
#@ Would you like to do so now?"]
#@       if {[string equal $result "Yes"]} {
#@         create_workspace -gui
#@       }
#@     }
#@ 
#@     if {![verifyComponents]} {
#@       return
#@     }
#@ 
#@     if {![string equal [get_workspace_name -quiet] ""]} {
#@       show_url $::synopsys_root/doc/dware/AMBA/amba.html "" "AMBA Subsystem Assembly Wizard"
#@       refreshHtml
#@       set act [find_item -type activity AddSubsystemComponents -should 1]
#@       sAct::DlgActivateBoundActivity $act
#@     }
#@   }
#@ 
#@   proc InitializeSubsystem {} {
#@     if {[string equal [all_components] ""]} {
#@       set result {
#@ <P>Choose the initial subsystem below which is closest to your needs. This
#@ is just a starting point, and can be added to, or subtracted from as
#@ desired.
#@ <P>
#@ <UL>
#@       }
#@       set systems {
#@         {{AHB} {i_ahb DW_ahb}} 
#@         {{AHB + APB} {i_ahb DW_ahb i_apb DW_apb}}
#@         {{AHB + APB + APB} {i_ahb DW_ahb i_apb1 DW_apb i_apb2 DW_apb}}
#@       }
#@       foreach system $systems {
#@         set label [lindex $system 0]
#@         set init_args [lindex $system 1]
#@         append result "
#@ <LI>
#@ <A HREF=\"cgi:AMBA::createInitialSubsystem%20\{$init_args\}\">$label</A>
#@ </LI>
#@ "
#@       }
#@       append result "</UL>"
#@     } else {
#@       set result {
#@ <P>You already have a subsystem in progress. <A HREF="cgi:AMBA::resetSubsystem%3B%20AMBA::refreshHtml">Click
#@ here</A> to delete your existing subsystem and start over. 
#@       }
#@     }
#@     return $result
#@   }
#@ 
#@   proc createInitialSubsystem {contents} {
#@ 
#@     sUtils::try {
#@       # Build the subsystem with the given contents.
#@       foreach {instance component} $contents {
#@         instantiate_component -name $instance $component
#@       }
#@     } catch-throw {
#@       resetSubsystem
#@     }
#@ 
#@     # Refresh the page.
#@     refreshHtml
#@   }
#@ 
#@   proc resetSubsystem {} {
#@     set exported [find_item -quiet -type interfaceInstance -hidden -search <current>]
#@     if {[sizeof_collection $exported]} {remove_item $exported}
#@     foreach compName [all_components] {
#@       remove_component $compName
#@     }
#@   }
#@ 
#@   proc refreshHtml {} {
#@     set browsers [find_item -quiet -type DlgBrowser -filter Value=~.*/amba.html]
#@     if {[sizeof_collection $browsers]} {
#@       set page [get_attribute [index_collection $browsers 0] -attr Value]
#@       set_attribute $browsers -attr Value -value $page
#@     }
#@   }
#@ 
#@   proc verifyComponents {} {
#@     array set components [get_installed_component_names]
#@     if {![info exists components(DW_ahb)] ||
#@         ![info exists components(DW_apb)]} {
#@       if {[info exists ::env(DESIGNWARE_HOME)]} {
#@         # Try to fix the component search path.
#@         set dw_home_latest [file join [getenv DESIGNWARE_HOME] iip latest]
#@         if {[file exists $dw_home_latest]} {
#@           set_activity_parameter AddSubsystemComponents SearchPath $dw_home_latest
#@           unset components
#@           array set components [get_installed_component_names]
#@         }
#@       }
#@     }
#@ 
#@     if {![info exists components(DW_ahb)] ||
#@         ![info exists components(DW_apb)]} {
#@       if {[info exists ::env(DESIGNWARE_HOME)]} {
#@         msg_box -icon exclamation                 -msgType okcancel "The DesignWare AMBA components cannot be found using the current setting of the
#@ DESIGNWARE_HOME variable. This probably means the variable is set to point at the
#@ wrong directory. When set correctly, the specified directory will contain the
#@ sub-directory 'iip'.
#@ Current value: [getenv DESIGNWARE_HOME]"
#@       } else {
#@         msg_box -icon exclamation                 -msgType okcancel "The DesignWare AMBA components cannot be found using the existing component search path.
#@ Please set the environment variable DESIGNWARE_HOME to point at the DesignWare
#@ installation area and then launch the wizard again. This can be done within
#@ coreAssembler using the builtin 'setenv' command."
#@       }
#@ 
#@       return 0
#@     }
#@     
#@     return 1
#@   }
#@ 
#@   proc AddComponents {} {
#@     set result {}
#@ 
#@     set orderedIndex {DW_ahb/AHB_Master DW_ahb/AHB_Slave DW_apb/APB_Slave}
#@     set labels(DW_ahb/AHB_Master) {AHB Master}
#@     set labels(DW_ahb/AHB_Slave)  {AHB Slave}
#@     set labels(DW_apb/APB_Slave)  {APB Slave}
#@ 
#@     # Determine available components.
#@     GetAvailableComponents $orderedIndex components
#@ 
#@     foreach entry $orderedIndex {
#@       set data [split $entry "/"]
#@       set bus [lindex $data 0]
#@       set interface [lindex $data 1]
#@       set busInstances [getInstances $bus]
#@       if {[sizeof_collection $busInstances]} {
#@         append result "<UL>\n"
#@         foreach_in_collection busInstance $busInstances {
#@           set instanceName [get_attribute $busInstance -attr Name]
#@           set columns 3
#@           set index 0
#@           append result "<li>Add new $labels($entry) to <b>$instanceName</b>\n"
#@           append result "<TABLE WIDTH=\"100%\">\n"
#@           foreach component $components($entry) {
#@             incr index
#@             if {[expr {$index % $columns}] == 1} {
#@               if {$index > 1} {
#@                 append result "</TR>\n"
#@               }
#@               append result "<TR>\n"
#@             }
#@             regsub {^<} $component {\&lt } htmlComponent
#@             regsub {>$} $htmlComponent {\&gt } htmlComponent
#@             set ref [sHtml::quote_url                "cgi:AMBA::AddComponentToBus $component $instanceName $bus $interface"]
#@             append result "<TD><UL><LI><A HREF=\"$ref\">$htmlComponent</A></LI></UL></TD>\n"
#@           }
#@           append result "</TR></TABLE>\n"
#@         }
#@         append result "</UL>\n"
#@       }
#@     }
#@ 
#@     if {[string equal $result {}]} {
#@       set result {<P>Not available until initial subsystem has been defined in the Initialize Subsystem section\n.}
#@     } else {
#@       # Prepend link to add new AHB to the subsystem.
#@       set cmd {instantiate_component DW_ahb -name [sAssemblerKb::generate_instance_name DW_ahb]; ::AMBA::refreshHtml}
#@       set ref [sHtml::quote_url cgi:$cmd]
#@       set tmpResult "<UL><LI><A HREF=\"$ref\">Add</A> another AHB bus (DW_ahb) to the subsystem</LI></UL>"
#@       set result [format "%s\n<PRE>\n</PRE>%s" $tmpResult $result]
#@     }
#@ 
#@     return $result
#@   }
#@ 
#@   proc AddComponentToBus {componentName busInstanceName busComponentName interfaceName} {
#@     if {[string equal $componentName "DW_ahb_icm"] &&
#@         ([sizeof_collection [getInstances DW_ahb]] < 2)} {
#@       msg_box -msgType ok             -icon exclamation             -title "DW_ahb_icm unavailable"             "You have chosen to add a DW_ahb_icm to a single AHB system.
#@ This is not supported. You cannot instantiate the DW_ahb_icm 
#@ until you have at least 2 DW_ahb instances in your subsystem."
#@     } elseif {[string equal $componentName "<Exported>"]} {
#@       set name [sAssemblerKb::generate_exported_interface_name                    $busInstanceName $interfaceName]
#@       export_interface -name $name                        -prefix                        -component $busInstanceName                        -interface $interfaceName
#@     } else { 
#@       set instanceName [sAssemblerKb::generate_instance_name $componentName]
#@       instantiate_component $componentName -name $instanceName
#@       if {[string equal $componentName DW_ahb_icm]} {
#@         MakeIcmLayerConnections $instanceName $busInstanceName
#@       } else {
#@         connect_interface -from_component $busInstanceName -from_interface $interfaceName -to_component $instanceName
#@       }
#@     }
#@     refreshHtml
#@   }
#@   
#@   proc getInstances {name} {
#@     set instances {}
#@     set designs [find_item -quiet                            -type design                            *$name                            -filter UnelabName==$name]
#@     set designs [add_to_collection $designs                     [find_item -quiet -type design $name]]
#@     foreach_in_collection design $designs {
#@       set instances [add_to_collection $instances                         [get_attribute $design -attr CellReferences]]
#@     }
#@     
#@     return $instances
#@   }
#@ 
#@   proc SpecifyAddressMaps {} {
#@     set result {}
#@     set busses(DW_ahb) {{Normal Mode Address Map} {Boot Mode Address Map}}
#@     set busses(DW_apb) {{Address Map}}
#@     foreach busComponent {DW_ahb DW_apb} {
#@       foreach_in_collection instance [getInstances $busComponent] {
#@         set name [get_attribute $instance -attr Name]
#@         foreach addrMap $busses($busComponent) {
#@           set ref [sHtml::quote_url "cgi:sAssemblerKb::show_configuration_dialog_page $name {$addrMap}"]
#@           append result "<LI><A HREF=\"$ref\">Define $addrMap for $name ($busComponent)</A></LI>\n"
#@         }
#@       }
#@     }
#@ 
#@     if {[string equal $result {}]} {
#@       set result "<P>There are not currently any components in the subsystem requiring address map definition.</P>"
#@     } else {
#@       set result [format "<UL>%s</UL>" $result]
#@     }
#@ 
#@     return $result
#@   }
#@ 
#@   proc DefineInterrupts {} {
#@     set result {}
#@ 
#@     set instances [getInstances DW_apb_ictl]
#@     if {![sizeof_collection $instances]} {
#@       set instances [getInstances DW_ahb_ictl]
#@     }
#@     if {[sizeof_collection $instances]} {
#@       set result "<P><A HREF=\"cgi:sAssemblerKb::showSpreadsheetConnectionDialog\">Click here</A> to define interrupts.</P>\n"
#@     } else {
#@       set result "<P>There are not currently any interrupt controllers in the subsystem</P>\n"
#@     } 
#@ 
#@     return $result
#@   }
#@ 
#@   proc GetAvailableComponents {compTypes compData} {
#@     
#@     upvar $compData components
#@ 
#@     array set busComponents {}
#@     array set interfaceToBusMap {}
#@ 
#@     # Initialize available components lists.
#@     foreach compType $compTypes {
#@       set components($compType) {}
#@ 
#@       # Store map from interface name to bus component.
#@       set pieces [split $compType "/"]
#@       set busComponent [lindex $pieces 0]
#@       set interfaceName [lindex $pieces 1]
#@       set busComponents($busComponent) 1
#@       set interfaceToBusMap($interfaceName) $busComponent
#@     }
#@ 
#@     # Determine list of all available components.
#@     array set availableComponents [get_installed_component_names]
#@     array set availableInterfaces {}
#@     
#@     foreach componentName [array names availableComponents] {
#@       # Read interface data file.
#@       set interfaceFile [file join [lindex $availableComponents($componentName) 0] .interfaces]
#@       if {[file exists $interfaceFile]} {
#@         unset availableInterfaces 
#@         array set availableInterfaces [exec cat $interfaceFile]
#@ 
#@         # Iterate over interfaces from the current component.
#@         foreach interfaceName [array names availableInterfaces] {
#@ 
#@           if {[info exists interfaceToBusMap($interfaceName)] &&
#@               ![string equal $componentName $interfaceToBusMap($interfaceName)] &&
#@               [info exists components($interfaceToBusMap($interfaceName)/$interfaceName)]} {
#@             # Found a component that attaches to the current bus. Remember the name.
#@             lappend components($interfaceToBusMap($interfaceName)/$interfaceName) $componentName
#@           }
#@         }
#@       }
#@     }
#@ 
#@     # Sort components and add <Exported> entry.
#@     foreach compType $compTypes {
#@       set components($compType) [lsort -dictionary $components($compType)]
#@       lappend components($compType) {<Exported>}
#@     }
#@   }
#@ 
#@ 
#@   proc SubsystemContents {} {
#@     if {[string equal [all_components] ""]} {
#@       set result {Subsystem is currently uninitialized (empty).}
#@     } else {
#@ 
#@       # Gather tree data.
#@       array set data {}
#@       foreach busType {DW_ahb DW_apb DW_ahb_icm} intfList {{AHB_Master AHB_Slave} APB_Slave AHB_Slave} {
#@         foreach_in_collection instance [getInstances $busType] {
#@ 
#@           set instanceName [get_attribute $instance -attr Name]
#@           foreach intfName $intfList {
#@           
#@             regsub {A.B_} $intfName {} intfLabel
#@             append intfLabel "s"
#@ 
#@             set key "$instanceName $intfLabel"
#@             set data($key) {}
#@ 
#@             set provider [find_item $intfName                                -type interfaceInstance                                -filter ComponentName==$instanceName/$intfName]
#@             set consumers [get_attribute $provider -attr Consumers]
#@             set consumers [find_item -quiet $consumers -sort SlotOrder]
#@             foreach_in_collection consumer $consumers {
#@               set slot [get_attribute $consumer -attr SlotOrder]
#@               set componentName [split [get_attribute $consumer                                                       -attr ComponentName] "/"]
#@               if {[llength $componentName] == 1} {
#@                 lappend data($key) "$slot $componentName Exported"
#@               } else {
#@                 set componentName [lindex $componentName 0]
#@                 set refDesignName [ReferenceDesignName $componentName]
#@                 lappend data($key) "$slot $componentName $refDesignName"
#@               }
#@             }
#@ 
#@             # Don't recurse on the ICM unless it's attached to an APB.
#@             if {[string equal $busType DW_ahb_icm] &&
#@                 ![string match {*DW_apb*} $data($key)]} {
#@               unset data($key)
#@             }
#@           }
#@         }
#@       }
#@ 
#@       # Determine type of top-level nodes in status tree.
#@       set topBusType [expr {[sizeof_collection [getInstances DW_ahb]] ? 
#@                                                "DW_ahb" : "DW_apb"}]
#@ 
#@       array set processed {}
#@ 
#@       # Generate HTML for the tree.
#@       set result {<UL>}
#@       foreach_in_collection instance [getInstances $topBusType] {
#@         set refDesignName [ReferenceDesignName "" $instance]
#@         append result {<LI>}
#@         append result "[get_attribute $instance -attr Name] ($refDesignName)"
#@         PrintTreeNodes $instance data processed result
#@         append result {</LI>}
#@       }
#@       append result {</UL>}
#@     }
#@ 
#@     return $result
#@   }
#@ 
#@   proc PrintTreeNodes {instance data processed result} {
#@     upvar $data _data
#@     upvar $result _result
#@     upvar $processed _processed
#@ 
#@     set instanceName [get_attribute $instance -attr Name]
#@     set refDesignName [ReferenceDesignName "" $instance]
#@ 
#@     if {[info exists _processed($instanceName)]} {
#@       return  ;# Already saw this cell
#@     } elseif {[string equal $refDesignName DW_ahb]} {
#@       # Prevent recursion for AHB only.
#@       set _processed($instanceName) 1
#@     }
#@ 
#@     set skipLabel [string equal $refDesignName DW_ahb_icm]
#@     set listStarted $skipLabel
#@ 
#@     foreach key [array names _data] {
#@       if {[string match "$instanceName *" $key]} {
#@         set label [lindex [split $key " "] 1]
#@         if {!$listStarted} {
#@           append _result "<UL>"
#@           set listStarted 1
#@         }
#@         if {!$skipLabel} {
#@           append _result "<LI>$label<UL>\n"
#@         } else {
#@           append _result "<UL>\n"
#@         }
#@         foreach entry $_data($key) {
#@           set slot [lindex $entry 0]
#@           set component [lindex $entry 1]
#@           set design [lindex $entry 2]
#@           set customText [CustomTextForComponent $component $design]
#@ 
#@           append _result "<LI>"
#@           append _result "$slot: $component ($design) $customText\n"
#@           if {![string equal $design Exported]} {
#@             PrintTreeNodes [find_item -type cell $component] _data _processed _result
#@           }
#@           append _result "</LI>"
#@         }
#@         append _result "</UL>"
#@         if {!$skipLabel} { append _result "</LI>" }
#@       }
#@     }
#@     if {$listStarted && !$skipLabel} {
#@       append _result "</UL>"
#@     }
#@   }
#@ 
#@   proc CustomTextForComponent {component design} {
#@   
#@     if {![string equal $design DW_ahb_icm]} {
#@       # No extra text.
#@       set result ""
#@     } else {
#@       # Show component on other side of the ICM.
#@       set intf [find_item -type interfaceInstance                           AHB_Slave                           -filter ComponentName==$component/AHB_Slave]
#@       set slaveIntf [get_attribute $intf -attr Consumers]
#@       if {[sizeof_collection $slaveIntf]} {
#@         set slaveCompName [split               [get_attribute $slaveIntf -attr ComponentName] \ "/"]
#@         if {[llength $slaveCompName] == 1} {
#@           set result                 "<b>&nbsp;&nbsp;-->&nbsp;&nbsp;</b>$slaveCompName (Exported)"
#@         } else {
#@           set slaveCompName [lindex $slaveCompName 0]
#@           set refDesignName [ReferenceDesignName $slaveCompName]
#@           if {[string equal $refDesignName ""]} {
#@             set refDesignName [get_attribute $refDesign -attr Name]
#@           }
#@           set result             "<b>&nbsp;&nbsp;-->&nbsp;&nbsp;</b>$slaveCompName ($refDesignName)"
#@         }
#@       } else {
#@         # There is nothing attached to the ICM yet.
#@         set result ""
#@       }
#@     }
#@ 
#@     return $result
#@   }
#@ 
#@   proc ReferenceDesignName {componentName {component ""}} {
#@     if {[string equal $componentName ""]} {
#@       set cell $component
#@     } else {
#@       set cell [find_item -type cell $componentName]
#@     }
#@     set refDesign [get_attribute $cell -attr ReferenceDesign]
#@     set refDesignName [get_attribute $refDesign -attr UnelabName]
#@     if {[string equal $refDesignName ""]} {
#@       set refDesignName [get_attribute $refDesign -attr Name]
#@     }
#@     return $refDesignName
#@   }
#@ 
#@   proc MakeIcmLayerConnections {icmName ahbName} {
#@     set ahbs [getInstances DW_ahb]
#@     set numberOfAhbs [sizeof_collection $ahbs]
#@ 
#@     # Need to query user about which layers to attach.
#@     set dlg {}
#@     set dlgSuffix AmbaWizardQuery
#@     sUtils::try {
#@ 
#@       # Build the dialog.
#@       set dlg [create_item -type dialog ${dlgSuffix}Dlg]
#@       set_attribute $dlg -attr ShowHelpBtn -value false
#@       set_attribute $dlg -attr ShowCancelBtn -value false
#@       set_attribute $dlg -attr CheckCmd -value {::AMBA::layer_check %item}
#@       set_attribute $dlg -attr Title -value "AHB Interconnect Matrix Definition"
#@       set text {
#@ Please specify which AHBs you would like attached to this DW_ahb_icm.
#@       }
#@       if {$numberOfAhbs > 4} { append text "\nAt most 4 AHBs can be chosen." }
#@       set xPos 7
#@       set yPos 7
#@       set items [sDlg::createLabel $dlgSuffix $text "" $dlg $xPos $yPos]
#@       set yPos [sDlg::calcNewYPos $items]
#@       set boxes {}
#@       set groupItems $items
#@       foreach_in_collection ahb $ahbs {
#@         set name [get_attribute $ahb -attr Name]
#@         set default [string equal $name $ahbName]
#@         set enabled [expr {![string equal $name $ahbName]}]
#@         set text "Attach to $name"
#@         set help {If checked, indicates that the new DW_ahb_icm should
#@ be attached to the indicated AHB bus.}
#@         set items [sDlg::labeledCheckBox ${dlgSuffix}$name                                            $text                                            $help                                            $dlg                                            $default                                            $xPos $yPos]
#@         set_attribute $items -attr Enabled -value $enabled
#@         set yPos [sDlg::calcNewYPos $items]
#@ 
#@         set boxes [add_to_collection $boxes [index_collection $items 0]]
#@         set groupItems [add_to_collection $groupItems $items]
#@       }
#@ 
#@       # Make all check boxes the same size.
#@       set boxes [find_item $boxes -sort -SizeX]
#@       set maxWidth [get_attribute [index_collection $boxes 0] -attr SizeX]
#@       set_attribute $boxes -attr SizeX -value $maxWidth
#@ 
#@       # Put group box around the check boxes.
#@       set items [sDlg::groupDlgItems ${dlgSuffix}Layers                                      "AHB Selection"                                      $groupItems]
#@       set groupSize [get_attribute $items -attr SizeX]
#@       set yPos [sDlg::calcNewYPos $items]
#@ 
#@       # Add label and a drop-down for what's attached to the other side 
#@       # of the ICM.
#@       set text "Choose AHB slave to attach to the DW_ahb_icm."
#@       set items [sDlg::createLabel $dlgSuffix $text "" $dlg $xPos $yPos]
#@       set yPos [sDlg::calcNewYPos $items]
#@       set groupItems $items
#@ 
#@       set help "Choose which AHB slave is to be connected to multiple
#@ AHB busses via the DW_ahb_icm."
#@ 
#@       # Determine available slaves (excluding the ICM).
#@       GetAvailableComponents DW_ahb/AHB_Slave components
#@       set index [lsearch $components(DW_ahb/AHB_Slave) DW_ahb_icm]
#@       if {$index >= 0} {
#@         set components(DW_ahb/AHB_Slave)               [lreplace $components(DW_ahb/AHB_Slave) $index $index]
#@       }
#@ 
#@       set items [sDlg::labeledStringCombo ${dlgSuffix}Slave                                           "AHB Slave"                                           $help                                           $dlg                                           $components(DW_ahb/AHB_Slave)                                           $xPos $yPos]
#@       set combo [find_item $items -type dlgStringsCombo]
#@       set groupItems [add_to_collection $groupItems $items]
#@ 
#@       # Put group box around the drop-down.
#@       set items [sDlg::groupDlgItems ${dlgSuffix}Slave                                      "Slave Selection"                                      $groupItems]
#@       # Force size to be the same as the first group box.
#@       # Grow combo by same amount the group box grows.
#@       set group2Size [get_attribute $items -attr SizeX]
#@       set delta [expr {$groupSize - $group2Size}]
#@       set_attribute $items -attr SizeX -value $groupSize
#@       set comboSize [get_attribute $combo -attr SizeX]
#@       set_attribute $combo -attr SizeX -value [expr {$comboSize + $delta}]
#@ 
#@       sDlg::sizeDlgToContents $dlg
#@         
#@       # Show the dialog
#@       show_dialog $dlg
#@ 
#@       # Gather results.
#@       set dlg [find_item -type dialog ${dlgSuffix}Dlg]
#@       set children [get_attribute $dlg -attr Children]
#@       set boxes [find_item $children -type dlgCheckBox                                      -filter "Value==1"                                      -sort ItemId]
#@ 
#@       # Make the interface connections.
#@       set_configuration_parameter -component $icmName                                     ICM_NUM_LAYERS                                     [sizeof_collection $boxes]
#@       set layer 0
#@       foreach_in_collection box $boxes {
#@         set text [get_attribute $box -attr Text]
#@         set ahbName [lindex $text 2]
#@         connect_interface -from_component $ahbName                             -from_interface AHB_Slave                             -to_component $icmName                             -to_interface Layer[incr layer]
#@       }
#@ 
#@       # Instantiate the AHB slave.
#@       set combo [find_item $children -type dlgStringsCombo]
#@       set slaveName [get_attribute $combo -attr Value]
#@       if {[string equal $slaveName "<Exported>"]} {
#@         set name [sAssemblerKb::generate_exported_interface_name                      $icmName AHB_Slave]
#@         export_interface -name $name                          -prefix                          -component $icmName                          -interface AHB_Slave
#@       } else {
#@         set instanceName [sAssemblerKb::generate_instance_name $slaveName]
#@         instantiate_component $slaveName -name $instanceName
#@ 
#@         # Connect the slave to the ICM.
#@         connect_interface -from_component $icmName                           -from_interface AHB_Slave                           -to_component $instanceName                           -to_interface AHB_Slave
#@       }
#@     } catch-throw {
#@     } finally {
#@       # Clean up.
#@       set dlg [find_item -quiet -type dialog ${dlgSuffix}Dlg]
#@       if {[sizeof_collection $dlg]} {remove_item -quiet $dlg}
#@     }
#@   }
#@ 
#@   proc layer_check {dialog} {
#@     set children [get_attribute $dialog -attr Children]
#@     set boxes [find_item $children -type dlgCheckBox                                      -filter "Value==1"                                      -sort ItemId]
#@     set msg {}
#@     set count [sizeof_collection $boxes]
#@ 
#@     if {$count > 4} {
#@       set msg "deselect at least [expr {$count - 4}] DW_ahb instance"
#@       set suffix [expr {($count - 4) > 1 ? "s" : ""}]
#@       append msg $suffix
#@     } elseif {$count < 2} {
#@       set msg "select at least 1 more DW_ahb instance"
#@     }
#@ 
#@     if {![string equal $msg ""]} {
#@       msg_box -msgType ok             -icon exclamation             -title "Illegal AHB Selection" "You must choose between 2 and 4 DW_ahb instances to attach 
#@ to the DW_ahb_icm (including the instance you initially chose
#@ to add the DW_ahb_icm to).
#@ 
#@ In this case you must ${msg}."
#@       return -code error
#@     }
#@   }
#@   
#@   #
#@   # Generate HTML page containing links to docs for installed cores.
#@   #
#@   proc generate_doc_page {} {
#@     if {[get_workspace_name -quiet] eq ""} {
#@       array set componentData [get_installed_component_names -update]
#@     } else {
#@       array set componentData [get_installed_component_names]
#@     }
#@               
#@     set text {<HTML>
#@ <HEAD>
#@ <TITLE>Documentation For Installed Components</TITLE>
#@ <BODY><H1><CENTER>Documentation For Installed Components</CENTER></H1>}
#@     foreach entry [lsort [array names componentData]] {
#@       set path [lindex $componentData($entry) 0]
#@       set version [lindex $componentData($entry) 1]
#@       
#@       # HTML header for current component
#@       append text "<H2>$entry ($version)</H2>\n"
#@       
#@       set docTypes "rn db an"
#@       set docTitles(rn) "Release Notes"
#@       set docTitles(db) "Data Book"
#@       set docTitles(an) "Application Notes"
#@       set startList 1
#@       
#@       # Locate docs for this component
#@       foreach docType $docTypes {
#@         set document [glob -nocomplain -- $path/doc/*_${docType}.pdf]
#@         if {[llength $document] == 0} {
#@           set document [glob -nocomplain -- $path/docs/*_${docType}.pdf]
#@         }
#@         if {[llength $document] == 1} {
#@           if {$startList} {
#@             append text "<UL>"
#@             set startList 0
#@           }
#@           append text             "<LI><A HREF=\"file:$document\">$docTitles($docType)</A></LI>"
#@         }
#@       }
#@       
#@       if {!$startList} {append text {</UL>}}
#@ 
#@     }
#@     append text {</BODY></HTML>}
#@     
#@     set text
#@   }
#@   
#@   # Show directory browser for specifying DESIGNWARE_HOME.
#@   proc specify_designware_home {} {
#@     
#@     set dw_home {}
#@     while {[string equal $dw_home ""]} {
#@       set dw_home [show_dir_dialog -title "Specify DESIGNWARE_HOME"]
#@       if {[string equal $dw_home ""]} {
#@         set dw_home "-" ;# User cancelled dialog
#@       } elseif {![file exists $dw_home/iip/latest]} {
#@         set response [msg_box -msgType yesno                               -icon question                               -title "Invalid DESIGNWARE_HOME"                               "The specified value for DESIGNWARE_HOME
#@ ($dw_home)
#@ is illegal. It does not contain an iip/latest sub-directory.
#@ Would you like to try again?"]
#@         if {[string equal $response No]} {
#@           set dw_home "-"
#@         }
#@       }
#@     }
#@     if {![string equal $dw_home ""] && ![string equal $dw_home "-"]} {
#@       # Update DESIGNWARE_HOME
#@       setenv DESIGNWARE_HOME $dw_home
#@       set ::component_search_path [file join $dw_home iip latest]
#@       set browser [find_item -type dlgBrowser HelpBrowser]
#@       sUtils::evalInGuiScratchKb {
#@         set_attribute $browser -attr Value -value             $::synopsys_root/doc/dware/coretools.html
#@       }
#@     }
#@   }
#@ 
#@   proc template {templateName} {
#@     set template [getenv DESIGNWARE_HOME]/iip/data/quickstart_templates/latest/$templateName.template
#@     if {![file exists $template]} {
#@       set template [getenv DESIGNWARE_HOME]/iip/QuickStart/$templateName.template
#@     }
#@     create_workspace -template $template
#@   }
#@ 
#@   proc create_amba_workspace {installdir componentName {script {}}} {
#@ 
#@     set configDir [file join $installdir auxiliary configs]
#@     set configFile [file join $configDir configurations.html]
#@     if {$script eq "" && [file exists $configFile]} {
#@       set ::dwh_component_installation $installdir
#@       set ::dwh_component_name $componentName
#@       set browser [find_item -type dlgBrowser HelpBrowser -search system]
#@       sUtils::evalInGuiScratchKb {
#@         set_attribute $browser -attr Value -value $configFile
#@       }
#@     } else {
#@       set name $componentName
#@       if {![regsub {^DW_apb_} $name {i_} name] &&
#@           ![regsub {^DW_ahb_} $name {i_} name] &&
#@           ![regsub {^DW_amba_} $name {i_} name] &&
#@           ![regsub {^DW_} $name {i_} name]} {
#@         set name "i_$name"
#@       }
#@       if {[file exists $name]} {
#@         set index 0
#@         set tmpName $name
#@         while {[file exists $tmpName] && ($index < 10000)} {
#@           set tmpName ${name}_[incr index]
#@         }
#@         set name $tmpName
#@       }
#@    
#@       create_workspace -gui -name $name -install $installdir 
#@       if {$script ne ""} {
#@         if {![file exists $script]} {
#@           set script [file join $configDir $script]
#@         }
#@         if {[file exists $script]} {
#@           echo "Sourcing configuration script: $script"
#@           catch {source $script}
#@         }
#@       }
#@     }
#@   }
#@ }
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/doc/dware/AMBA/amba.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcl8.5/package.tcl

#@ # package.tcl --
#@ #
#@ # utility procs formerly in init.tcl which can be loaded on demand
#@ # for package management.
#@ #
#@ # Copyright (c) 1991-1993 The Regents of the University of California.
#@ # Copyright (c) 1994-1998 Sun Microsystems, Inc.
#@ #
#@ # See the file "license.terms" for information on usage and redistribution
#@ # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#@ #
#@ 
#@ namespace eval tcl::Pkg {}
#@ 
#@ # ::tcl::Pkg::CompareExtension --
#@ #
#@ #  Used internally by pkg_mkIndex to compare the extension of a file to
#@ #  a given extension. On Windows, it uses a case-insensitive comparison
#@ #  because the file system can be file insensitive.
#@ #
#@ # Arguments:
#@ #  fileName	name of a file whose extension is compared
#@ #  ext		(optional) The extension to compare against; you must
#@ #		provide the starting dot.
#@ #		Defaults to [info sharedlibextension]
#@ #
#@ # Results:
#@ #  Returns 1 if the extension matches, 0 otherwise
#@ 
#@ proc tcl::Pkg::CompareExtension { fileName {ext {}} } {
#@     global tcl_platform
#@     if {$ext eq ""} {set ext [info sharedlibextension]}
#@     if {$tcl_platform(platform) eq "windows"} {
#@         return [string equal -nocase [file extension $fileName] $ext]
#@     } else {
#@         # Some unices add trailing numbers after the .so, so
#@         # we could have something like '.so.1.2'.
#@         set root $fileName
#@         while {1} {
#@             set currExt [file extension $root]
#@             if {$currExt eq $ext} {
#@                 return 1
#@             } 
#@ 
#@ 	    # The current extension does not match; if it is not a numeric
#@ 	    # value, quit, as we are only looking to ignore version number
#@ 	    # extensions.  Otherwise we might return 1 in this case:
#@ 	    #		tcl::Pkg::CompareExtension foo.so.bar .so
#@ 	    # which should not match.
#@ 
#@ 	    if { ![string is integer -strict [string range $currExt 1 end]] } {
#@ 		return 0
#@ 	    }
#@             set root [file rootname $root]
#@ 	}
#@     }
#@ }
#@ 
#@ # pkg_mkIndex --
#@ # This procedure creates a package index in a given directory.  The
#@ # package index consists of a "pkgIndex.tcl" file whose contents are
#@ # a Tcl script that sets up package information with "package require"
#@ # commands.  The commands describe all of the packages defined by the
#@ # files given as arguments.
#@ #
#@ # Arguments:
#@ # -direct		(optional) If this flag is present, the generated
#@ #			code in pkgMkIndex.tcl will cause the package to be
#@ #			loaded when "package require" is executed, rather
#@ #			than lazily when the first reference to an exported
#@ #			procedure in the package is made.
#@ # -verbose		(optional) Verbose output; the name of each file that
#@ #			was successfully rocessed is printed out. Additionally,
#@ #			if processing of a file failed a message is printed.
#@ # -load pat		(optional) Preload any packages whose names match
#@ #			the pattern.  Used to handle DLLs that depend on
#@ #			other packages during their Init procedure.
#@ # dir -			Name of the directory in which to create the index.
#@ # args -		Any number of additional arguments, each giving
#@ #			a glob pattern that matches the names of one or
#@ #			more shared libraries or Tcl script files in
#@ #			dir.
#@ 
#@ proc pkg_mkIndex {args} {
#@     set usage {"pkg_mkIndex ?-direct? ?-lazy? ?-load pattern? ?-verbose? ?--? dir ?pattern ...?"};
#@ 
#@     set argCount [llength $args]
#@     if {$argCount < 1} {
#@ 	return -code error "wrong # args: should be\n$usage"
#@     }
#@ 
#@     set more ""
#@     set direct 1
#@     set doVerbose 0
#@     set loadPat ""
#@     for {set idx 0} {$idx < $argCount} {incr idx} {
#@ 	set flag [lindex $args $idx]
#@ 	switch -glob -- $flag {
#@ 	    -- {
#@ 		# done with the flags
#@ 		incr idx
#@ 		break
#@ 	    }
#@ 	    -verbose {
#@ 		set doVerbose 1
#@ 	    }
#@ 	    -lazy {
#@ 		set direct 0
#@ 		append more " -lazy"
#@ 	    }
#@ 	    -direct {
#@ 		append more " -direct"
#@ 	    }
#@ 	    -load {
#@ 		incr idx
#@ 		set loadPat [lindex $args $idx]
#@ 		append more " -load $loadPat"
#@ 	    }
#@ 	    -* {
#@ 		return -code error "unknown flag $flag: should be\n$usage"
#@ 	    }
#@ 	    default {
#@ 		# done with the flags
#@ 		break
#@ 	    }
#@ 	}
#@     }
#@ 
#@     set dir [lindex $args $idx]
#@     set patternList [lrange $args [expr {$idx + 1}] end]
#@     if {[llength $patternList] == 0} {
#@ 	set patternList [list "*.tcl" "*[info sharedlibextension]"]
#@     }
#@ 
#@     if {[catch {
#@ 	    glob -directory $dir -tails -types {r f} -- {*}$patternList
#@     } fileList o]} {
#@ 	return -options $o $fileList
#@     }
#@     foreach file $fileList {
#@ 	# For each file, figure out what commands and packages it provides.
#@ 	# To do this, create a child interpreter, load the file into the
#@ 	# interpreter, and get a list of the new commands and packages
#@ 	# that are defined.
#@ 
#@ 	if {$file eq "pkgIndex.tcl"} {
#@ 	    continue
#@ 	}
#@ 
#@ 	set c [interp create]
#@ 
#@ 	# Load into the child any packages currently loaded in the parent
#@ 	# interpreter that match the -load pattern.
#@ 
#@ 	if {$loadPat ne ""} {
#@ 	    if {$doVerbose} {
#@ 		tclLog "currently loaded packages: '[info loaded]'"
#@ 		tclLog "trying to load all packages matching $loadPat"
#@ 	    }
#@ 	    if {![llength [info loaded]]} {
#@ 		tclLog "warning: no packages are currently loaded, nothing"
#@ 		tclLog "can possibly match '$loadPat'"
#@ 	    }
#@ 	}
#@ 	foreach pkg [info loaded] {
#@ 	    if {! [string match -nocase $loadPat [lindex $pkg 1]]} {
#@ 		continue
#@ 	    }
#@ 	    if {$doVerbose} {
#@ 		tclLog "package [lindex $pkg 1] matches '$loadPat'"
#@ 	    }
#@ 	    if {[catch {
#@ 		load [lindex $pkg 0] [lindex $pkg 1] $c
#@ 	    } err]} {
#@ 		if {$doVerbose} {
#@ 		    tclLog "warning: load [lindex $pkg 0] [lindex $pkg 1]\nfailed with: $err"
#@ 		}
#@ 	    } elseif {$doVerbose} {
#@ 		tclLog "loaded [lindex $pkg 0] [lindex $pkg 1]"
#@ 	    }
#@ 	    if {[lindex $pkg 1] eq "Tk"} {
#@ 		# Withdraw . if Tk was loaded, to avoid showing a window.
#@ 		$c eval [list wm withdraw .]
#@ 	    }
#@ 	}
#@ 
#@ 	$c eval {
#@ 	    # Stub out the package command so packages can
#@ 	    # require other packages.
#@ 
#@ 	    rename package __package_orig
#@ 	    proc package {what args} {
#@ 		switch -- $what {
#@ 		    require { return ; # ignore transitive requires }
#@ 		    default { __package_orig $what {*}$args }
#@ 		}
#@ 	    }
#@ 	    proc tclPkgUnknown args {}
#@ 	    package unknown tclPkgUnknown
#@ 
#@ 	    # Stub out the unknown command so package can call
#@ 	    # into each other during their initialilzation.
#@ 
#@ 	    proc unknown {args} {}
#@ 
#@ 	    # Stub out the auto_import mechanism
#@ 
#@ 	    proc auto_import {args} {}
#@ 
#@ 	    # reserve the ::tcl namespace for support procs
#@ 	    # and temporary variables.  This might make it awkward
#@ 	    # to generate a pkgIndex.tcl file for the ::tcl namespace.
#@ 
#@ 	    namespace eval ::tcl {
#@ 		variable dir		;# Current directory being processed
#@ 		variable file		;# Current file being processed
#@ 		variable direct		;# -direct flag value
#@ 		variable x		;# Loop variable
#@ 		variable debug		;# For debugging
#@ 		variable type		;# "load" or "source", for -direct
#@ 		variable namespaces	;# Existing namespaces (e.g., ::tcl)
#@ 		variable packages	;# Existing packages (e.g., Tcl)
#@ 		variable origCmds	;# Existing commands
#@ 		variable newCmds	;# Newly created commands
#@ 		variable newPkgs {}	;# Newly created packages
#@ 	    }
#@ 	}
#@ 
#@ 	$c eval [list set ::tcl::dir $dir]
#@ 	$c eval [list set ::tcl::file $file]
#@ 	$c eval [list set ::tcl::direct $direct]
#@ 
#@ 	# Download needed procedures into the slave because we've
#@ 	# just deleted the unknown procedure.  This doesn't handle
#@ 	# procedures with default arguments.
#@ 
#@ 	foreach p {::tcl::Pkg::CompareExtension} {
#@ 	    $c eval [list namespace eval [namespace qualifiers $p] {}]
#@ 	    $c eval [list proc $p [info args $p] [info body $p]]
#@ 	}
#@ 
#@ 	if {[catch {
#@ 	    $c eval {
#@ 		set ::tcl::debug "loading or sourcing"
#@ 
#@ 		# we need to track command defined by each package even in
#@ 		# the -direct case, because they are needed internally by
#@ 		# the "partial pkgIndex.tcl" step above.
#@ 
#@ 		proc ::tcl::GetAllNamespaces {{root ::}} {
#@ 		    set list $root
#@ 		    foreach ns [namespace children $root] {
#@ 			lappend list {*}[::tcl::GetAllNamespaces $ns]
#@ 		    }
#@ 		    return $list
#@ 		}
#@ 
#@ 		# init the list of existing namespaces, packages, commands
#@ 
#@ 		foreach ::tcl::x [::tcl::GetAllNamespaces] {
#@ 		    set ::tcl::namespaces($::tcl::x) 1
#@ 		}
#@ 		foreach ::tcl::x [package names] {
#@ 		    if {[package provide $::tcl::x] ne ""} {
#@ 			set ::tcl::packages($::tcl::x) 1
#@ 		    }
#@ 		}
#@ 		set ::tcl::origCmds [info commands]
#@ 
#@ 		# Try to load the file if it has the shared library
#@ 		# extension, otherwise source it.  It's important not to
#@ 		# try to load files that aren't shared libraries, because
#@ 		# on some systems (like SunOS) the loader will abort the
#@ 		# whole application when it gets an error.
#@ 
#@ 		if {[::tcl::Pkg::CompareExtension $::tcl::file [info sharedlibextension]]} {
#@ 		    # The "file join ." command below is necessary.
#@ 		    # Without it, if the file name has no \'s and we're
#@ 		    # on UNIX, the load command will invoke the
#@ 		    # LD_LIBRARY_PATH search mechanism, which could cause
#@ 		    # the wrong file to be used.
#@ 
#@ 		    set ::tcl::debug loading
#@ 		    load [file join $::tcl::dir $::tcl::file]
#@ 		    set ::tcl::type load
#@ 		} else {
#@ 		    set ::tcl::debug sourcing
#@ 		    source [file join $::tcl::dir $::tcl::file]
#@ 		    set ::tcl::type source
#@ 		}
#@ 
#@ 		# As a performance optimization, if we are creating 
#@ 		# direct load packages, don't bother figuring out the 
#@ 		# set of commands created by the new packages.  We 
#@ 		# only need that list for setting up the autoloading 
#@ 		# used in the non-direct case.
#@ 		if { !$::tcl::direct } {
#@ 		    # See what new namespaces appeared, and import commands
#@ 		    # from them.  Only exported commands go into the index.
#@ 		    
#@ 		    foreach ::tcl::x [::tcl::GetAllNamespaces] {
#@ 			if {! [info exists ::tcl::namespaces($::tcl::x)]} {
#@ 			    namespace import -force ${::tcl::x}::*
#@ 			}
#@ 
#@ 			# Figure out what commands appeared
#@ 			
#@ 			foreach ::tcl::x [info commands] {
#@ 			    set ::tcl::newCmds($::tcl::x) 1
#@ 			}
#@ 			foreach ::tcl::x $::tcl::origCmds {
#@ 			    unset -nocomplain ::tcl::newCmds($::tcl::x)
#@ 			}
#@ 			foreach ::tcl::x [array names ::tcl::newCmds] {
#@ 			    # determine which namespace a command comes from
#@ 			    
#@ 			    set ::tcl::abs [namespace origin $::tcl::x]
#@ 			    
#@ 			    # special case so that global names have no leading
#@ 			    # ::, this is required by the unknown command
#@ 			    
#@ 			    set ::tcl::abs 				    [lindex [auto_qualify $::tcl::abs ::] 0]
#@ 			    
#@ 			    if {$::tcl::x ne $::tcl::abs} {
#@ 				# Name changed during qualification
#@ 				
#@ 				set ::tcl::newCmds($::tcl::abs) 1
#@ 				unset ::tcl::newCmds($::tcl::x)
#@ 			    }
#@ 			}
#@ 		    }
#@ 		}
#@ 
#@ 		# Look through the packages that appeared, and if there is
#@ 		# a version provided, then record it
#@ 
#@ 		foreach ::tcl::x [package names] {
#@ 		    if {[package provide $::tcl::x] ne ""
#@ 			    && ![info exists ::tcl::packages($::tcl::x)]} {
#@ 			lappend ::tcl::newPkgs 			    [list $::tcl::x [package provide $::tcl::x]]
#@ 		    }
#@ 		}
#@ 	    }
#@ 	} msg] == 1} {
#@ 	    set what [$c eval set ::tcl::debug]
#@ 	    if {$doVerbose} {
#@ 		tclLog "warning: error while $what $file: $msg"
#@ 	    }
#@ 	} else {
#@ 	    set what [$c eval set ::tcl::debug]
#@ 	    if {$doVerbose} {
#@ 		tclLog "successful $what of $file"
#@ 	    }
#@ 	    set type [$c eval set ::tcl::type]
#@ 	    set cmds [lsort [$c eval array names ::tcl::newCmds]]
#@ 	    set pkgs [$c eval set ::tcl::newPkgs]
#@ 	    if {$doVerbose} {
#@ 		if { !$direct } {
#@ 		    tclLog "commands provided were $cmds"
#@ 		}
#@ 		tclLog "packages provided were $pkgs"
#@ 	    }
#@ 	    if {[llength $pkgs] > 1} {
#@ 		tclLog "warning: \"$file\" provides more than one package ($pkgs)"
#@ 	    }
#@ 	    foreach pkg $pkgs {
#@ 		# cmds is empty/not used in the direct case
#@ 		lappend files($pkg) [list $file $type $cmds]
#@ 	    }
#@ 
#@ 	    if {$doVerbose} {
#@ 		tclLog "processed $file"
#@ 	    }
#@ 	}
#@ 	interp delete $c
#@     }
#@ 
#@     append index "# Tcl package index file, version 1.1\n"
#@     append index "# This file is generated by the \"pkg_mkIndex$more\" command\n"
#@     append index "# and sourced either when an application starts up or\n"
#@     append index "# by a \"package unknown\" script.  It invokes the\n"
#@     append index "# \"package ifneeded\" command to set up package-related\n"
#@     append index "# information so that packages will be loaded automatically\n"
#@     append index "# in response to \"package require\" commands.  When this\n"
#@     append index "# script is sourced, the variable \$dir must contain the\n"
#@     append index "# full path name of this file's directory.\n"
#@ 
#@     foreach pkg [lsort [array names files]] {
#@ 	set cmd {}
#@ 	foreach {name version} $pkg {
#@ 	    break
#@ 	}
#@ 	lappend cmd ::tcl::Pkg::Create -name $name -version $version
#@ 	foreach spec [lsort -index 0 $files($pkg)] {
#@ 	    foreach {file type procs} $spec {
#@ 		if { $direct } {
#@ 		    set procs {}
#@ 		}
#@ 		lappend cmd "-$type" [list $file $procs]
#@ 	    }
#@ 	}
#@ 	append index "\n[eval $cmd]"
#@     }
#@ 
#@     set f [open [file join $dir pkgIndex.tcl] w]
#@     puts $f $index
#@     close $f
#@ }
#@ 
#@ # tclPkgSetup --
#@ # This is a utility procedure use by pkgIndex.tcl files.  It is invoked
#@ # as part of a "package ifneeded" script.  It calls "package provide"
#@ # to indicate that a package is available, then sets entries in the
#@ # auto_index array so that the package's files will be auto-loaded when
#@ # the commands are used.
#@ #
#@ # Arguments:
#@ # dir -			Directory containing all the files for this package.
#@ # pkg -			Name of the package (no version number).
#@ # version -		Version number for the package, such as 2.1.3.
#@ # files -		List of files that constitute the package.  Each
#@ #			element is a sub-list with three elements.  The first
#@ #			is the name of a file relative to $dir, the second is
#@ #			"load" or "source", indicating whether the file is a
#@ #			loadable binary or a script to source, and the third
#@ #			is a list of commands defined by this file.
#@ 
#@ proc tclPkgSetup {dir pkg version files} {
#@     global auto_index
#@ 
#@     package provide $pkg $version
#@     foreach fileInfo $files {
#@ 	set f [lindex $fileInfo 0]
#@ 	set type [lindex $fileInfo 1]
#@ 	foreach cmd [lindex $fileInfo 2] {
#@ 	    if {$type eq "load"} {
#@ 		set auto_index($cmd) [list load [file join $dir $f] $pkg]
#@ 	    } else {
#@ 		set auto_index($cmd) [list source [file join $dir $f]]
#@ 	    } 
#@ 	}
#@     }
#@ }
#@ 
#@ # tclPkgUnknown --
#@ # This procedure provides the default for the "package unknown" function.
#@ # It is invoked when a package that's needed can't be found.  It scans
#@ # the auto_path directories and their immediate children looking for
#@ # pkgIndex.tcl files and sources any such files that are found to setup
#@ # the package database. As it searches, it will recognize changes
#@ # to the auto_path and scan any new directories.
#@ #
#@ # Arguments:
#@ # name -		Name of desired package.  Not used.
#@ # version -		Version of desired package.  Not used.
#@ # exact -		Either "-exact" or omitted.  Not used.
#@ 
#@ proc tclPkgUnknown {name args} {
#@     global auto_path env
#@ 
#@     if {![info exists auto_path]} {
#@ 	return
#@     }
#@     # Cache the auto_path, because it may change while we run through
#@     # the first set of pkgIndex.tcl files
#@     set old_path [set use_path $auto_path]
#@     while {[llength $use_path]} {
#@ 	set dir [lindex $use_path end]
#@ 	
#@ 	# Make sure we only scan each directory one time.
#@ 	if {[info exists tclSeenPath($dir)]} {
#@ 	    set use_path [lrange $use_path 0 end-1]
#@ 	    continue
#@ 	}
#@ 	set tclSeenPath($dir) 1
#@ 
#@ 	# we can't use glob in safe interps, so enclose the following
#@ 	# in a catch statement, where we get the pkgIndex files out
#@ 	# of the subdirectories
#@ 	catch {
#@ 	    foreach file [glob -directory $dir -join -nocomplain 		    * pkgIndex.tcl] {
#@ 		set dir [file dirname $file]
#@ 		if {![info exists procdDirs($dir)]} {
#@ 		    set code [catch {source $file} msg opt]
#@ 		    if {$code == 1 &&
#@ 			    [lindex [dict get $opt -errorcode] 0] eq "POSIX" &&
#@ 			    [lindex [dict get $opt -errorcode] 1] eq "EACCES"} {
#@ 			# $file was not readable; silently ignore
#@ 			continue
#@ 		    }
#@ 		    if {$code} {
#@ 			tclLog "error reading package index file $file: $msg"
#@ 		    } else {
#@ 			set procdDirs($dir) 1
#@ 		    }
#@ 		}
#@ 	    }
#@ 	}
#@ 	set dir [lindex $use_path end]
#@ 	if {![info exists procdDirs($dir)]} {
#@ 	    set file [file join $dir pkgIndex.tcl]
#@ 	    # safe interps usually don't have "file exists", 
#@ 	    if {([interp issafe] || [file exists $file])} {
#@ 		set code [catch {source $file} msg opt]
#@ 		if {$code == 1 &&
#@ 			[lindex [dict get $opt -errorcode] 0] eq "POSIX" &&
#@ 			[lindex [dict get $opt -errorcode] 1] eq "EACCES"} {
#@ 		    # $file was not readable; silently ignore
#@ 		    continue
#@ 		}
#@ 		if {$code}  {
#@ 		    tclLog "error reading package index file $file: $msg"
#@ 		} else {
#@ 		    set procdDirs($dir) 1
#@ 		}
#@ 	    }
#@ 	}
#@ 
#@ 	set use_path [lrange $use_path 0 end-1]
#@ 
#@ 	# Check whether any of the index scripts we [source]d above
#@ 	# set a new value for $::auto_path.  If so, then find any
#@ 	# new directories on the $::auto_path, and lappend them to
#@ 	# the $use_path we are working from.  This gives index scripts
#@ 	# the (arguably unwise) power to expand the index script search
#@ 	# path while the search is in progress.
#@ 	set index 0
#@ 	if {[llength $old_path] == [llength $auto_path]} {
#@ 	    foreach dir $auto_path old $old_path {
#@ 		if {$dir ne $old} {
#@ 		    # This entry in $::auto_path has changed.
#@ 		    break
#@ 		}
#@ 		incr index
#@ 	    }
#@ 	}
#@ 
#@ 	# $index now points to the first element of $auto_path that
#@ 	# has changed, or the beginning if $auto_path has changed length
#@ 	# Scan the new elements of $auto_path for directories to add to
#@ 	# $use_path.  Don't add directories we've already seen, or ones
#@ 	# already on the $use_path.
#@ 	foreach dir [lrange $auto_path $index end] {
#@ 	    if {![info exists tclSeenPath($dir)] 
#@ 		    && ([lsearch -exact $use_path $dir] == -1) } {
#@ 		lappend use_path $dir
#@ 	    }
#@ 	}
#@ 	set old_path $auto_path
#@     }
#@ }
#@ 
#@ # tcl::MacOSXPkgUnknown --
#@ # This procedure extends the "package unknown" function for MacOSX.
#@ # It scans the Resources/Scripts directories of the immediate children
#@ # of the auto_path directories for pkgIndex files.
#@ #
#@ # Arguments:
#@ # original -		original [package unknown] procedure
#@ # name -		Name of desired package.  Not used.
#@ # version -		Version of desired package.  Not used.
#@ # exact -		Either "-exact" or omitted.  Not used.
#@ 
#@ proc tcl::MacOSXPkgUnknown {original name args} {
#@ 
#@     #  First do the cross-platform default search
#@     uplevel 1 $original [linsert $args 0 $name]
#@ 
#@     # Now do MacOSX specific searching
#@     global auto_path
#@ 
#@     if {![info exists auto_path]} {
#@ 	return
#@     }
#@     # Cache the auto_path, because it may change while we run through
#@     # the first set of pkgIndex.tcl files
#@     set old_path [set use_path $auto_path]
#@     while {[llength $use_path]} {
#@ 	set dir [lindex $use_path end]
#@ 
#@ 	# Make sure we only scan each directory one time.
#@ 	if {[info exists tclSeenPath($dir)]} {
#@ 	    set use_path [lrange $use_path 0 end-1]
#@ 	    continue
#@ 	}
#@ 	set tclSeenPath($dir) 1
#@ 
#@ 	# get the pkgIndex files out of the subdirectories
#@ 	foreach file [glob -directory $dir -join -nocomplain 		* Resources Scripts pkgIndex.tcl] {
#@ 	    set dir [file dirname $file]
#@ 	    if {![info exists procdDirs($dir)]} {
#@ 		set code [catch {source $file} msg opt]
#@ 		if {$code == 1 &&
#@ 			[lindex [dict get $opt -errorcode] 0] eq "POSIX" &&
#@ 			[lindex [dict get $opt -errorcode] 1] eq "EACCES"} {
#@ 		    # $file was not readable; silently ignore
#@ 		    continue
#@ 		}
#@ 		if {$code} {
#@ 		    tclLog "error reading package index file $file: $msg"
#@ 		} else {
#@ 		    set procdDirs($dir) 1
#@ 		}
#@ 	    }
#@ 	}
#@ 	set use_path [lrange $use_path 0 end-1]
#@ 
#@ 	# Check whether any of the index scripts we [source]d above
#@ 	# set a new value for $::auto_path.  If so, then find any
#@ 	# new directories on the $::auto_path, and lappend them to
#@ 	# the $use_path we are working from.  This gives index scripts
#@ 	# the (arguably unwise) power to expand the index script search
#@ 	# path while the search is in progress.
#@ 	set index 0
#@ 	if {[llength $old_path] == [llength $auto_path]} {
#@ 	    foreach dir $auto_path old $old_path {
#@ 		if {$dir ne $old} {
#@ 		    # This entry in $::auto_path has changed.
#@ 		    break
#@ 		}
#@ 		incr index
#@ 	    }
#@ 	}
#@ 
#@ 	# $index now points to the first element of $auto_path that
#@ 	# has changed, or the beginning if $auto_path has changed length
#@ 	# Scan the new elements of $auto_path for directories to add to
#@ 	# $use_path.  Don't add directories we've already seen, or ones
#@ 	# already on the $use_path.
#@ 	foreach dir [lrange $auto_path $index end] {
#@ 	    if {![info exists tclSeenPath($dir)] 
#@ 		    && ([lsearch -exact $use_path $dir] == -1) } {
#@ 		lappend use_path $dir
#@ 	    }
#@ 	}
#@ 	set old_path $auto_path
#@     }
#@ }
#@ 
#@ # ::tcl::Pkg::Create --
#@ #
#@ #	Given a package specification generate a "package ifneeded" statement
#@ #	for the package, suitable for inclusion in a pkgIndex.tcl file.
#@ #
#@ # Arguments:
#@ #	args		arguments used by the Create function:
#@ #			-name		packageName
#@ #			-version	packageVersion
#@ #			-load		{filename ?{procs}?}
#@ #			...
#@ #			-source		{filename ?{procs}?}
#@ #			...
#@ #
#@ #			Any number of -load and -source parameters may be
#@ #			specified, so long as there is at least one -load or
#@ #			-source parameter.  If the procs component of a 
#@ #			module specifier is left off, that module will be
#@ #			set up for direct loading; otherwise, it will be
#@ #			set up for lazy loading.  If both -source and -load
#@ #			are specified, the -load'ed files will be loaded 
#@ #			first, followed by the -source'd files.
#@ #
#@ # Results:
#@ #	An appropriate "package ifneeded" statement for the package.
#@ 
#@ proc ::tcl::Pkg::Create {args} {
#@     append err(usage) "[lindex [info level 0] 0] "
#@     append err(usage) "-name packageName -version packageVersion"
#@     append err(usage) "?-load {filename ?{procs}?}? ... "
#@     append err(usage) "?-source {filename ?{procs}?}? ..."
#@ 
#@     set err(wrongNumArgs) "wrong # args: should be \"$err(usage)\""
#@     set err(valueMissing) "value for \"%s\" missing: should be \"$err(usage)\""
#@     set err(unknownOpt)   "unknown option \"%s\": should be \"$err(usage)\""
#@     set err(noLoadOrSource) "at least one of -load and -source must be given"
#@ 
#@     # process arguments
#@     set len [llength $args]
#@     if { $len < 6 } {
#@ 	error $err(wrongNumArgs)
#@     }
#@     
#@     # Initialize parameters
#@     set opts(-name)		{}
#@     set opts(-version)		{}
#@     set opts(-source)		{}
#@     set opts(-load)		{}
#@ 
#@     # process parameters
#@     for {set i 0} {$i < $len} {incr i} {
#@ 	set flag [lindex $args $i]
#@ 	incr i
#@ 	switch -glob -- $flag {
#@ 	    "-name"		-
#@ 	    "-version"		{
#@ 		if { $i >= $len } {
#@ 		    error [format $err(valueMissing) $flag]
#@ 		}
#@ 		set opts($flag) [lindex $args $i]
#@ 	    }
#@ 	    "-source"		-
#@ 	    "-load"		{
#@ 		if { $i >= $len } {
#@ 		    error [format $err(valueMissing) $flag]
#@ 		}
#@ 		lappend opts($flag) [lindex $args $i]
#@ 	    }
#@ 	    default {
#@ 		error [format $err(unknownOpt) [lindex $args $i]]
#@ 	    }
#@ 	}
#@     }
#@ 
#@     # Validate the parameters
#@     if { [llength $opts(-name)] == 0 } {
#@ 	error [format $err(valueMissing) "-name"]
#@     }
#@     if { [llength $opts(-version)] == 0 } {
#@ 	error [format $err(valueMissing) "-version"]
#@     }
#@     
#@     if { [llength $opts(-source)] == 0 && [llength $opts(-load)] == 0 } {
#@ 	error $err(noLoadOrSource)
#@     }
#@ 
#@     # OK, now everything is good.  Generate the package ifneeded statment.
#@     set cmdline "package ifneeded $opts(-name) $opts(-version) "
#@     
#@     set cmdList {}
#@     set lazyFileList {}
#@ 
#@     # Handle -load and -source specs
#@     foreach key {load source} {
#@ 	foreach filespec $opts(-$key) {
#@ 	    foreach {filename proclist} {{} {}} {
#@ 		break
#@ 	    }
#@ 	    foreach {filename proclist} $filespec {
#@ 		break
#@ 	    }
#@ 	    
#@ 	    if { [llength $proclist] == 0 } {
#@ 		set cmd "\[list $key \[file join \$dir [list $filename]\]\]"
#@ 		lappend cmdList $cmd
#@ 	    } else {
#@ 		lappend lazyFileList [list $filename $key $proclist]
#@ 	    }
#@ 	}
#@     }
#@ 
#@     if { [llength $lazyFileList] > 0 } {
#@ 	lappend cmdList "\[list tclPkgSetup \$dir $opts(-name)		$opts(-version) [list $lazyFileList]\]"
#@     }
#@     append cmdline [join $cmdList "\\n"]
#@     return $cmdline
#@ }
#@ 
#@ interp alias {} ::pkg::create {} ::tcl::Pkg::Create 
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcl8.5/package.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tclxml/pkgIndex.tcl

#@ # Tcl package index file - handcrafted
#@ #
#@ # $Id: //apbld/7.8/third_party/tclxml/library/pkgIndex.tcl#1 $
#@ 
#@ package ifneeded xml::c       3.1 [list init_c_package xml::c]
#@ package ifneeded xml::libxml2 3.1 [list init_c_package xml::libxml2]
#@ package ifneeded xml::tcl     3.1 [list source [file join $dir xml__tcl.tcl]]
#@ package ifneeded sgmlparser   1.0       [list source [file join $dir sgmlparser.tcl]]
#@ package ifneeded xpath        1.0       [list source [file join $dir xpath.tcl]]
#@ package ifneeded xmldep       1.0       [list source [file join $dir xmldep.tcl]]
#@ 
#@ # The C parsers are provided through their own packages and indices,
#@ # and thus do not have to be listed here. This index may require them
#@ # in certain places, but does not provide them. This is part of the
#@ # work refactoring the build system of TclXML to create clean
#@ # packages, and not require a jumble (jungle?) of things in one Makefile.
#@ #
#@ #package ifneeded xml::expat  3.1 [list load   [file join $dir @expat_TCL_LIB_FILE@]]
#@ #package ifneeded xml::xerces 2.0       [list load   [file join $dir @xerces_TCL_LIB_FILE@]]
#@ #package ifneeded xml::libxml2 3.1 [list load   [file join $dir @TclXML_libxml2_LIB_FILE@]]
#@ 
#@ namespace eval ::xml {}
#@ 
#@ # Requesting a specific package means we want it to be the default parser class.
#@ # This is achieved by loading it last.
#@ 
#@ # expat and libxml2 packages must have xml::c package loaded
#@ package ifneeded expat 3.1 {
#@     package require xml::c 3.1
#@     package require xmldefs
#@     package require xml::tclparser 3.1
#@     catch {package require xml::libxml2 3.1}
#@     package require xml::expat     3.1
#@     package provide expat          3.1
#@ }
#@ package ifneeded libxml2 3.1 {
#@     package require xml::c 3.1
#@     package require xmldefs
#@     package require xml::tclparser 3.1
#@     catch {package require xml::expat 3.1}
#@     package require xml::libxml2   3.1
#@     package provide libxml2        3.1
#@ }
#@ 
#@ # tclparser works with either xml::c or xml::tcl
#@ package ifneeded tclparser 3.1 {
#@     if {[catch {package require xml::c 3.1}]} {
#@ 	# No point in trying to load expat or libxml2
#@ 	package require xml::tcl       3.1
#@ 	package require xmldefs
#@ 	package require xml::tclparser 3.1
#@     } else {
#@ 	package require xmldefs
#@ 	catch {package require xml::expat   3.1}
#@ 	catch {package require xml::libxml2 3.1}
#@ 	package require xml::tclparser
#@     }
#@     package provide tclparser 3.1
#@ }
#@ 
#@ # use tcl only (mainly for testing)
#@ package ifneeded puretclparser 3.1 {
#@     package require xml::tcl       3.1
#@     package require xmldefs
#@     package require xml::tclparser 3.1
#@     package provide puretclparser  3.1
#@ }                                        
#@ 
#@ # Requesting the generic package leaves the choice of default parser automatic
#@ 
#@ package ifneeded xml 3.1 {
#@     if {[catch {package require xml::c 3.1}]} {
#@ 	package require xml::tcl       3.1
#@ 	package require xmldefs
#@ 	# Only choice is tclparser
#@ 	package require xml::tclparser 3.1
#@     } else {
#@ 	package require xmldefs
#@ 	package require xml::tclparser    3.1
#@ 	# libxml2 is favoured since it provides more features
#@ 	catch {package require xml::expat 3.1}
#@ 	catch {package require xml::libxml2 3.1}
#@     }
#@     package provide xml 3.1
#@ }
#@ 
#@ if {[info tclversion] <= 8.0} {
#@     package ifneeded sgml           1.9       [list source [file join $dir sgml-8.0.tcl]]
#@     package ifneeded xmldefs        3.1 [list source [file join $dir xml-8.0.tcl]]
#@     package ifneeded xml::tclparser 3.1 [list source [file join $dir tclparser-8.0.tcl]]
#@ } else {
#@     package ifneeded sgml           1.9       [list source [file join $dir sgml-8.1.tcl]]
#@     package ifneeded xmldefs        3.1 [list source [file join $dir xml-8.1.tcl]]
#@     package ifneeded xml::tclparser 3.1 [list source [file join $dir tclparser-8.1.tcl]]
#@ }
#@ 
#@ 
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tclxml/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # Do NOT edit by hand.  Let tcllib install generate this file.
#@ # Generated by tcllib installer for version 1.15
#@ 
#@ # All tcllib packages need Tcl 8 (use [namespace])
#@ if {![package vsatisfies [package provide Tcl] 8]} {return}
#@ 
#@ # Extend the auto_path to make tcllib packages available
#@ if {[lsearch -exact $::auto_path $dir] == -1} {
#@     lappend ::auto_path $dir
#@ }
#@ 
#@ # For Tcl 8.3.1 and later, that's all we need
#@ if {[package vsatisfies [package provide Tcl] 8.4]} {return}
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/parsetcl/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex -direct" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded parsetcl 0.2 [list sSys::fast_source [file join $dir parsetcl.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/parsetcl/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tclxslt/pkgIndex.tcl

#@ # pkgIndex.tcl --
#@ #
#@ #       Handcrafted for TclXSLT.
#@ #
#@ # Copyright (c) 2001-2003 Zveno Pty Ltd
#@ # http://ww.zveno.com/
#@ #
#@ # $Id: //apbld/7.8/third_party/tclxslt/library/pkgIndex.tcl#1 $
#@ 
#@ package ifneeded xslt 3.1 [list init_c_package xslt]
#@ package ifneeded xslt::cache 3.1 [list source [file join $dir xsltcache.tcl]]
#@ 
#@ package ifneeded xslt::resources 1.1 [list source [file join $dir resources.tcl]]
#@ package ifneeded xslt::process 1.1 [list source [file join $dir process.tcl]]
#@ package ifneeded xslt::utilities 1.0 [list source [file join $dir utilities.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tclxslt/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcldom/pkgIndex.tcl

#@ # TclDOM package index - hand crafted
#@ #
#@ # $Id: //apbld/7.8/third_party/tcldom/library/pkgIndex.tcl#1 $
#@ 
#@ #package ifneeded dom::c          3.1 [list init_c_package dom::c]
#@ package ifneeded dom::libxml2    3.1 "init_c_package dom::libxml2; source [file join $dir libxml2_impl.tcl]"
#@ package ifneeded dom::tcl        3.1 [list source [file join $dir dom.tcl]]
#@ package ifneeded dommap          1.0       [list source [file join $dir dommap.tcl]]
#@ package ifneeded xmlswitch       1.0       [list source [file join $dir xmlswitch.tcl]]
#@ 
#@ # Examples - will not necessarily be installed
#@ package ifneeded cgi2dom         1.1       [list source [file join $dir cgi2dom.tcl]]
#@ package ifneeded domtree         3.1 [list source [file join $dir domtree.tcl]]
#@ package ifneeded domtext         3.1 [list source [file join $dir domtext.tcl]]
#@ 
#@ ## Provided by separate package.
#@ ##package ifneeded dom::libxml2    3.1 [list load [file join $dir .. UNSPECIFIED] Tcldomxml]
#@ 
#@ namespace eval ::dom {}
#@ 
#@ # Requesting the generic dom package loads the C package 
#@ # if available, otherwise falls back to the generic Tcl package.
#@ # The application can tell which it got by examining the
#@ # list of packages loaded (and looking for dom::c, dom::libxml2 or dom::tcl).
#@ 
#@ package ifneeded dom 3.1 {
#@     if {[catch {package require dom::libxml2 3.1}]} {
#@ 	if {[catch {package require dom::c 3.1}]} {
#@ 	    package require dom::tcl 3.1
#@ 	}
#@     }
#@     package provide dom 3.1
#@ }
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcldom/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/cB_test/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex -direct" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded cB_test 1.1 [list sSys::fast_source [file join $dir cB_test.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/cB_test/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tclsoap/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded SOAP 1.6.7 [list source [file join $dir SOAP.tcl]]
#@ package ifneeded SOAP::CGI 1.0 [list source [file join $dir SOAP-CGI.tcl]]
#@ package ifneeded SOAP::Domain 1.4 [list source [file join $dir SOAP-domain.tcl]]
#@ package ifneeded SOAP::Service 0.4 [list source [file join $dir SOAP-service.tcl]]
#@ package ifneeded SOAP::Utils 1.0.1 [list source [file join $dir utils.tcl]]
#@ package ifneeded SOAP::ftp 1.0 [list source [file join $dir ftp.tcl]]
#@ package ifneeded SOAP::http 1.0 [list source [file join $dir http.tcl]]
#@ package ifneeded SOAP::https 1.0 [list source [file join $dir https.tcl]]
#@ package ifneeded SOAP::smtp 1.0 [list source [file join $dir smtp.tcl]]
#@ package ifneeded SOAP::xpath 0.2 [list source [file join $dir xpath.tcl]]
#@ package ifneeded SOAP::WSDL 1.0 [list source [file join $dir WSDL.tcl]]
#@ package ifneeded SOAP::Schema 0.1 [list source [file join $dir schema.tcl]]
#@ package ifneeded XMLRPC 1.0 [list source [file join $dir XMLRPC.tcl]]
#@ package ifneeded rpcvar 1.2 [list source [file join $dir rpcvar.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tclsoap/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/clock/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.5]} {return}
#@ package ifneeded clock::rfc2822 0.1 [list source [file join $dir rfc2822.tcl]]
#@ package ifneeded clock::iso8601 0.1 [list source [file join $dir iso8601.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/clock/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/pt/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.5]} return
#@ 
#@ # General utilities.
#@ package ifneeded char          1 [list source [file join $dir char.tcl]]
#@ package ifneeded configuration 1 [list source [file join $dir configuration.tcl]]
#@ package ifneeded paths         1 [list source [file join $dir paths.tcl]]
#@ package ifneeded text::write   1 [list source [file join $dir text_write.tcl]]
#@ 
#@ # AST support
#@ package ifneeded pt::ast     1.1 [list source [file join $dir pt_astree.tcl]]
#@ 
#@ # Parsing Expression support
#@ package ifneeded pt::pe        1 [list source [file join $dir pt_pexpression.tcl]]
#@ package ifneeded pt::pe::op    1 [list source [file join $dir pt_pexpr_op.tcl]]
#@ 
#@ # Parsing Expression Grammar support.
#@ package ifneeded pt::peg            1 [list source [file join $dir pt_pegrammar.tcl]]
#@ package ifneeded pt::peg::container 1 [list source [file join $dir pt_peg_container.tcl]]
#@ package ifneeded pt::peg::interp    1 [list source [file join $dir pt_peg_interp.tcl]]
#@ package ifneeded pt::peg::op        1 [list source [file join $dir pt_peg_op.tcl]]
#@ package ifneeded pt::parse::peg     1 [list source [file join $dir pt_parse_peg.tcl]]
#@ 
#@ 
#@ # Export/import managers. Assumes an untrusted environment.
#@ package ifneeded pt::peg::export            1 [list source [file join $dir pt_peg_export.tcl]]
#@ package ifneeded pt::peg::import            1 [list source [file join $dir pt_peg_import.tcl]]
#@ 
#@ # Export plugins, connecting manager to the core conversion packages.
#@ package ifneeded pt::peg::export::container 1 [list source [file join $dir pt_peg_export_container.tcl]]
#@ package ifneeded pt::peg::export::json      1 [list source [file join $dir pt_peg_export_json.tcl]]
#@ package ifneeded pt::peg::export::peg       1 [list source [file join $dir pt_peg_export_peg.tcl]]
#@ 
#@ # Import plugins, connecting manager to the core conversion packages.
#@ package ifneeded pt::peg::import::json      1 [list source [file join $dir pt_peg_import_json.tcl]]
#@ package ifneeded pt::peg::import::peg       1 [list source [file join $dir pt_peg_import_peg.tcl]]
#@ 
#@ # Export core functionality: Conversion from PEG to a specific format.
#@ package ifneeded pt::peg::to::container 1 [list source [file join $dir pt_peg_to_container.tcl]]
#@ package ifneeded pt::peg::to::cparam    1.0.1 [list source [file join $dir pt_peg_to_cparam.tcl]]
#@ package ifneeded pt::peg::to::json      1 [list source [file join $dir pt_peg_to_json.tcl]]
#@ package ifneeded pt::peg::to::param     1 [list source [file join $dir pt_peg_to_param.tcl]]
#@ package ifneeded pt::peg::to::peg       1 [list source [file join $dir pt_peg_to_peg.tcl]]
#@ package ifneeded pt::peg::to::tclparam  1 [list source [file join $dir pt_peg_to_tclparam.tcl]]
#@ 
#@ # Import core functionality: Conversion from a specific format to PEG.
#@ package ifneeded pt::peg::from::json      1 [list source [file join $dir pt_peg_from_json.tcl]]
#@ package ifneeded pt::peg::from::peg       1 [list source [file join $dir pt_peg_from_peg.tcl]]
#@ 
#@ # PARAM runtime.
#@ package ifneeded pt::rde      1.0.2 [list source [file join $dir pt_rdengine.tcl]]
#@ 
#@ # PEG grammar specification, as CONTAINER
#@ package ifneeded pt::peg::container::peg 1 [list source [file join $dir pt_peg_container_peg.tcl]]
#@ 
#@ # */PARAM support (canned configurations).
#@ package ifneeded pt::cparam::configuration::critcl  1.0.1 [list source [file join $dir pt_cparam_config_critcl.tcl]]
#@ package ifneeded pt::tclparam::configuration::snit  1.0.1 [list source [file join $dir pt_tclparam_config_snit.tcl]]
#@ package ifneeded pt::tclparam::configuration::tcloo 1.0.2 [list source [file join $dir pt_tclparam_config_tcloo.tcl]]
#@ 
#@ # Parser generator core.
#@ package ifneeded pt::pgen 1.0.1 [list source [file join $dir pt_pgen.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/pt/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/mime/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.3]} {return}
#@ package ifneeded mime 1.5.6 [list source [file join $dir mime.tcl]]
#@ package ifneeded smtp 1.4.5 [list source [file join $dir smtp.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/mime/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/tiff/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded tiff 0.2.1 [list source [file join $dir tiff.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/tiff/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/tie/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded tie                1.1   [list source [file join $dir tie.tcl]]
#@ package ifneeded tie::std::file     1.0.4 [list source [file join $dir tie_file.tcl]]
#@ package ifneeded tie::std::growfile 1.0   [list source [file join $dir tie_growfile.tcl]]
#@ package ifneeded tie::std::log      1.0   [list source [file join $dir tie_log.tcl]]
#@ package ifneeded tie::std::array    1.0   [list source [file join $dir tie_array.tcl]]
#@ package ifneeded tie::std::rarray   1.0   [list source [file join $dir tie_rarray.tcl]]
#@ package ifneeded tie::std::dsource  1.0   [list source [file join $dir tie_dsource.tcl]]
#@ 
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/tie/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/hook/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.5]} {
#@     # PRAGMA: returnok
#@     return
#@ }
#@ package ifneeded hook 0.1 [list source [file join $dir hook.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/hook/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/doctools2toc/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ 
#@ # Packages for the doctools toc v2 implementation
#@ # (still v1.1 doctoc language).
#@ 
#@ # - Index container, mutable toc objects
#@ # - Export and import management
#@ # - Export and import plugins
#@ # - Parser for doctoc markup, and handling serializations
#@ # - Message catalogs for the parser
#@ 
#@ package ifneeded doctools::toc                 2   [list source [file join $dir container.tcl]]
#@ 
#@ package ifneeded doctools::toc::export         0.1 [list source [file join $dir export.tcl]]
#@ package ifneeded doctools::toc::import         0.1 [list source [file join $dir import.tcl]]
#@ 
#@ package ifneeded doctools::toc::export::doctoc 0.1 [list source [file join $dir export_doctoc.tcl]]
#@ package ifneeded doctools::toc::export::html   0.1 [list source [file join $dir export_html.tcl]]
#@ package ifneeded doctools::toc::export::json   0.1 [list source [file join $dir export_json.tcl]]
#@ package ifneeded doctools::toc::export::nroff  0.2 [list source [file join $dir export_nroff.tcl]]
#@ package ifneeded doctools::toc::export::text   0.1 [list source [file join $dir export_text.tcl]]
#@ package ifneeded doctools::toc::export::wiki   0.1 [list source [file join $dir export_wiki.tcl]]
#@ 
#@ package ifneeded doctools::toc::import::doctoc 0.1 [list source [file join $dir import_doctoc.tcl]]
#@ package ifneeded doctools::toc::import::json   0.1 [list source [file join $dir import_json.tcl]]
#@ 
#@ package ifneeded doctools::toc::parse          0.1 [list source [file join $dir parse.tcl]]
#@ package ifneeded doctools::toc::structure      0.1 [list source [file join $dir structure.tcl]]
#@ 
#@ package ifneeded doctools::msgcat::toc::c      0.1 [list source [file join $dir msgcat_c.tcl]]
#@ package ifneeded doctools::msgcat::toc::de     0.1 [list source [file join $dir msgcat_de.tcl]]
#@ package ifneeded doctools::msgcat::toc::en     0.1 [list source [file join $dir msgcat_en.tcl]]
#@ package ifneeded doctools::msgcat::toc::fr     0.1 [list source [file join $dir msgcat_fr.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/doctools2toc/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/htmlparse/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded htmlparse 1.2.1 [list source [file join $dir htmlparse.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/htmlparse/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/virtchannel_core/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.5]} {return}
#@ 
#@ package ifneeded tcl::chan::core 1   [list source [file join $dir core.tcl]]
#@ package ifneeded tcl::chan::events 1 [list source [file join $dir events.tcl]]
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.6]} {return}
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/virtchannel_core/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/fumagic/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ 
#@ # Recognizers
#@ package ifneeded fileutil::magic::filetype 1.0.2 [list source [file join $dir filetypes.tcl]]
#@ package ifneeded fileutil::magic::mimetype 1.0.2 [list source [file join $dir mimetypes.tcl]]
#@ 
#@ # Runtime
#@ package ifneeded fileutil::magic::rt 1.0 [list source [file join $dir rtcore.tcl]]
#@ 
#@ # Compiler packages
#@ package ifneeded fileutil::magic::cgen   1.0 [list source [file join $dir cgen.tcl]]
#@ package ifneeded fileutil::magic::cfront 1.0 [list source [file join $dir cfront.tcl]]
#@ 
#@ 
#@ 
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/fumagic/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/namespacex/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.5]} {
#@     # PRAGMA: returnok
#@     return
#@ }
#@ package ifneeded namespacex 0.1 [list source [file join $dir namespacex.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/namespacex/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/textutil/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {
#@     # FRINK: nocheck
#@     return
#@ }
#@ package ifneeded textutil           0.7.1 [list source [file join $dir textutil.tcl]]
#@ package ifneeded textutil::adjust   0.7.1 [list source [file join $dir adjust.tcl]]
#@ package ifneeded textutil::split    0.7 [list source [file join $dir split.tcl]]
#@ package ifneeded textutil::trim     0.7 [list source [file join $dir trim.tcl]]
#@ package ifneeded textutil::tabify   0.7 [list source [file join $dir tabify.tcl]]
#@ package ifneeded textutil::repeat   0.7 [list source [file join $dir repeat.tcl]]
#@ package ifneeded textutil::string   0.7.1 [list source [file join $dir string.tcl]]
#@ package ifneeded textutil::expander 1.3.1 [list source [file join $dir expander.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/textutil/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/ftpd/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.3]} {return}
#@ package ifneeded ftpd 1.2.6 [list source [file join $dir ftpd.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/ftpd/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/sasl/pkgIndex.tcl

#@ # pkgIndex.tcl                                                -*- tcl -*-
#@ # Copyright (C) 2005 Pat Thoyts <patthoyts@users.sourceforge.net>
#@ # $Id: pkgIndex.tcl,v 1.11 2008/01/29 00:51:39 patthoyts Exp $
#@ if {![package vsatisfies [package provide Tcl] 8.2]} {
#@     # PRAGMA: returnok
#@     return
#@ }
#@ package ifneeded SASL 1.3.2 [list source [file join $dir sasl.tcl]]
#@ package ifneeded SASL::NTLM 1.1.1 [list source [file join $dir ntlm.tcl]]
#@ package ifneeded SASL::XGoogleToken 1.0.1 [list source [file join $dir gtoken.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/sasl/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/http/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded autoproxy 1.5.3 [list source [file join $dir autoproxy.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/http/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/sha1/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded sha256 1.0.3 [list source [file join $dir sha256.tcl]]
#@ package ifneeded sha1   2.0.3 [list source [file join $dir sha1.tcl]]
#@ package ifneeded sha1   1.1.0 [list source [file join $dir sha1v1.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/sha1/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/coroutine/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.6]} {return}
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/coroutine/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/md5crypt/pkgIndex.tcl

#@ # package index for md5crypt
#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded md5crypt 1.1.0 [list source [file join $dir md5crypt.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/md5crypt/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/ident/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded ident 0.42 [list source [file join $dir ident.tcl]]
#@ 
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/ident/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/grammar_aycock/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.5]} {return}
#@ 
#@ package ifneeded grammar::aycock 1.0     [list source [file join $dir aycock-build.tcl]]
#@ package ifneeded grammar::aycock::debug 1.0     [list source [file join $dir aycock-debug.tcl]]
#@ package ifneeded grammar::aycock::runtime 1.0     [list source [file join $dir aycock-runtime.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/grammar_aycock/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/pop3d/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded pop3d::udb  1.1   [list source [file join $dir pop3d_udb.tcl]]
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.3]} {return}
#@ package ifneeded pop3d       1.1.0 [list source [file join $dir pop3d.tcl]]
#@ package ifneeded pop3d::dbox 1.0.2 [list source [file join $dir pop3d_dbox.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/pop3d/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/profiler/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.3]} {return}
#@ package ifneeded profiler 0.3 [list source [file join $dir profiler.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/profiler/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/stooop/pkgIndex.tcl

#@ # @mdgen EXCLUDE: xifo.tcl
#@ # @mdgen EXCLUDE: mkpkgidx.tcl
#@ #
#@ # Copyright (c) 2001 by Jean-Luc Fontaine <jfontain@free.fr>.
#@ # This code may be distributed under the same terms as Tcl.
#@ #
#@ # $Id: pkgIndex.tcl,v 1.10 2007/03/23 17:31:51 andreas_kupries Exp $
#@ 
#@ # Since stooop redefines the proc command and the default package facility will
#@ # only load the stooop package at the first unknown command, proc being
#@ # obviously known by default, forcing the loading of stooop is mandatory prior
#@ # to the first proc declaration.
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.3]} {return}
#@ package ifneeded stooop 4.4.1 [list source [file join $dir stooop.tcl]]
#@ 
#@ # the following package index instruction was generated using:
#@ #   "tclsh mkpkgidx.tcl switched switched.tcl"
#@ # (comment out the following line if you do not want to use the switched class
#@ # as a package)
#@ 
#@ package ifneeded switched 2.2.1 [list source [file join $dir switched.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/stooop/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/soundex/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded soundex 1.0 [list source [file join $dir soundex.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/soundex/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/md4/pkgIndex.tcl

#@ # This package has been tested with tcl 8.2.3 and above.
#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded md4 1.0.5 [list source [file join $dir md4.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/md4/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/bench/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {
#@     return
#@ }
#@ package ifneeded bench            0.4 [list source [file join $dir bench.tcl]]
#@ package ifneeded bench::out::text 0.1.2 [list source [file join $dir bench_wtext.tcl]]
#@ package ifneeded bench::out::csv  0.1.2 [list source [file join $dir bench_wcsv.tcl]]
#@ package ifneeded bench::in        0.1   [list source [file join $dir bench_read.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/bench/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/json/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded json 1.1.2 [list source [file join $dir json.tcl]]
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.5]} {return}
#@ package ifneeded json::write 1.0.2 [list source [file join $dir json_write.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/json/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/pop3/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded pop3 1.9 [list source [file join $dir pop3.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/pop3/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/aes/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {
#@     # PRAGMA: returnok
#@     return
#@ }
#@ package ifneeded aes 1.1 [list source [file join $dir aes.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/aes/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/try/pkgIndex.tcl

#@ #checker -scope global exclude warnUndefinedVar
#@ # var in question is 'dir'.
#@ if {![package vsatisfies [package provide Tcl] 8.5]} {
#@     # PRAGMA: returnok
#@     return
#@ }
#@ # The package below is a backward compatible implementation of
#@ # try/catch/finally, for use by Tcl 8.5 only. On 8.6 it does nothing.
#@ package ifneeded try 1 [list source [file join $dir try.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/try/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/zip/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded zipfile::encode 0.1 [list source [file join $dir encode.tcl]]
#@ package ifneeded zipfile::decode 0.2 [list source [file join $dir decode.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/zip/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/units/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.1]} {return}
#@ package ifneeded units 2.1.1 [list source [file join $dir units.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/units/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/ncgi/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded ncgi 1.4.1 [list source [file join $dir ncgi.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/ncgi/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/map/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded map::slippy             0.5 [list source [file join $dir map_slippy.tcl]]
#@ package ifneeded map::slippy::fetcher    0.3 [list source [file join $dir map_slippy_fetcher.tcl]]
#@ package ifneeded map::slippy::cache      0.2 [list source [file join $dir map_slippy_cache.tcl]]
#@ package ifneeded map::geocode::nominatim 0.1 [list source [file join $dir map_geocode_nominatim.tcl]]
#@ 
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/map/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/asn/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded asn 0.8.4 [list source [file join $dir asn.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/asn/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/grammar_peg/pkgIndex.tcl

#@ package ifneeded grammar::peg         0.2   [list source [file join $dir peg.tcl]]
#@ package ifneeded grammar::peg::interp 0.1.1 [list source [file join $dir peg_interp.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/grammar_peg/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/base32/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} return
#@ package ifneeded base32       0.1 [list source [file join $dir base32.tcl]]
#@ package ifneeded base32::hex  0.1 [list source [file join $dir base32hex.tcl]]
#@ package ifneeded base32::core 0.1 [list source [file join $dir base32core.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/base32/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/uev/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded uevent         0.3.1 [list source [file join $dir uevent.tcl]]
#@ package ifneeded uevent::onidle 0.1   [list source [file join $dir uevent_onidle.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/uev/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/dns/pkgIndex.tcl

#@ # pkgIndex.tcl -
#@ #
#@ # $Id: pkgIndex.tcl,v 1.21 2010/08/16 17:35:18 andreas_kupries Exp $
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded dns    1.3.3 [list source [file join $dir dns.tcl]]
#@ package ifneeded resolv 1.0.3 [list source [file join $dir resolv.tcl]]
#@ package ifneeded ip     1.2   [list source [file join $dir ip.tcl]]
#@ package ifneeded spf    1.1.1 [list source [file join $dir spf.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/dns/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/docstrip/pkgIndex.tcl

#@ ## 
#@ ## This is the file `pkgIndex.tcl',
#@ ## generated with the SAK utility
#@ ## (sak docstrip/regen).
#@ ## 
#@ ## The original source files were:
#@ ## 
#@ ## tcldocstrip.dtx  (with options: `idx')
#@ ## 
#@ ## In other words:
#@ ## **************************************
#@ ## * This Source is not the True Source *
#@ ## **************************************
#@ ## the true source is the file from which this one was generated.
#@ ##
#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded docstrip 1.2  [list source [file join $dir docstrip.tcl]]
#@ package ifneeded docstrip::util 1.3  [list source [file join $dir docstrip_util.tcl]]
#@ ## 
#@ ## 
#@ ## End of file `pkgIndex.tcl'.
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/docstrip/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/smtpd/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.3]} {return}
#@ package ifneeded smtpd 1.5 [list source [file join $dir smtpd.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/smtpd/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/irc/pkgIndex.tcl

#@ # pkgIndex.tcl                                                    -*- tcl -*-
#@ # $Id: pkgIndex.tcl,v 1.10 2008/08/05 20:40:04 andreas_kupries Exp $
#@ if { ![package vsatisfies [package provide Tcl] 8.3] } {
#@     # PRAGMA: returnok
#@     return 
#@ }
#@ package ifneeded irc     0.6.1 [list source [file join $dir irc.tcl]]
#@ package ifneeded picoirc 0.5.1 [list source [file join $dir picoirc.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/irc/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/imap4/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.5]} {return}
#@ package ifneeded imap4 0.4 [list source [file join $dir imap4.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/imap4/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/term/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} return
#@ package ifneeded term                     0.1 [list source [file join $dir term.tcl]]
#@ package ifneeded term::ansi::code         0.1 [list source [file join $dir ansi/code.tcl]]
#@ package ifneeded term::ansi::code::attr   0.1 [list source [file join $dir ansi/code/attr.tcl]]
#@ package ifneeded term::ansi::code::ctrl   0.1.2 [list source [file join $dir ansi/code/ctrl.tcl]]
#@ package ifneeded term::ansi::code::macros 0.1 [list source [file join $dir ansi/code/macros.tcl]]
#@ package ifneeded term::ansi::ctrl::unix   0.1.1 [list source [file join $dir ansi/ctrlunix.tcl]]
#@ package ifneeded term::ansi::send         0.1 [list source [file join $dir ansi/send.tcl]]
#@ package ifneeded term::interact::menu     0.1 [list source [file join $dir imenu.tcl]]
#@ package ifneeded term::interact::pager    0.1 [list source [file join $dir ipager.tcl]]
#@ package ifneeded term::receive            0.1 [list source [file join $dir receive.tcl]]
#@ package ifneeded term::receive::bind      0.1 [list source [file join $dir bind.tcl]]
#@ package ifneeded term::send               0.1 [list source [file join $dir send.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/term/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/multiplexer/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ if { ![package vsatisfies [package provide Tcl] 8.2] } { return }
#@ package ifneeded multiplexer 0.2 [list source [file join $dir multiplexer.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/multiplexer/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/math/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded math                    1.2.5 [list source [file join $dir math.tcl]]
#@ package ifneeded math::geometry          1.1.2 [list source [file join $dir geometry.tcl]]
#@ package ifneeded math::fuzzy             0.2.1 [list source [file join $dir fuzzy.tcl]]
#@ package ifneeded math::complexnumbers    1.0.2 [list source [file join $dir qcomplex.tcl]]
#@ package ifneeded math::special           0.2.2 [list source [file join $dir special.tcl]]
#@ package ifneeded math::constants         1.0.1 [list source [file join $dir constants.tcl]]
#@ package ifneeded math::polynomials       1.0.1 [list source [file join $dir polynomials.tcl]]
#@ package ifneeded math::rationalfunctions 1.0.1 [list source [file join $dir rational_funcs.tcl]]
#@ package ifneeded math::fourier           1.0.2 [list source [file join $dir fourier.tcl]]
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.3]} {return}
#@ package ifneeded math::roman             1.0   [list source [file join $dir romannumerals.tcl]]
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ # statistics depends on linearalgebra (for multi-variate linear regression).
#@ package ifneeded math::statistics        0.8.0 [list source [file join $dir statistics.tcl]]
#@ package ifneeded math::optimize          1.0   [list source [file join $dir optimize.tcl]]
#@ package ifneeded math::calculus          0.7.1 [list source [file join $dir calculus.tcl]]
#@ package ifneeded math::interpolate       1.0.3 [list source [file join $dir interpolate.tcl]]
#@ package ifneeded math::linearalgebra     1.1.4 [list source [file join $dir linalg.tcl]]
#@ package ifneeded math::bignum            3.1.1 [list source [file join $dir bignum.tcl]]
#@ package ifneeded math::bigfloat          1.2.2 [list source [file join $dir bigfloat.tcl]]
#@ package ifneeded math::machineparameters 0.1   [list source [file join $dir machineparameters.tcl]]
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.5]} {return}
#@ package ifneeded math::calculus::symdiff 1.0   [list source [file join $dir symdiff.tcl]]
#@ package ifneeded math::bigfloat          2.0.1 [list source [file join $dir bigfloat2.tcl]]
#@ package ifneeded math::numtheory         1.0   [list source [file join $dir numtheory.tcl]]
#@ package ifneeded math::decimal           1.0.2 [list source [file join $dir decimal.tcl]]
#@ 
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/math/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/log/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8]} {return}
#@ package ifneeded log 1.3 [list source [file join $dir log.tcl]]
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded logger           0.9.3 [list source [file join $dir logger.tcl]]
#@ package ifneeded logger::appender 1.3   [list source [file join $dir loggerAppender.tcl]]
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded logger::utils    1.3   [list source [file join $dir loggerUtils.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/log/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/wip/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded wip 1.2 [list source [file join $dir wip.tcl]]
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.5]} {return}
#@ package ifneeded wip 2.2 [list source [file join $dir wip2.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/wip/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/nmea/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded nmea 1.0.0 [list source [file join $dir nmea.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/nmea/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/virtchannel_base/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.5]} {return}
#@ 
#@ package ifneeded tcl::chan::cat 1.0.2      [list source [file join $dir cat.tcl]]
#@ package ifneeded tcl::chan::facade 1.0.1   [list source [file join $dir facade.tcl]]
#@ package ifneeded tcl::chan::fifo 1         [list source [file join $dir fifo.tcl]]
#@ package ifneeded tcl::chan::fifo2 1        [list source [file join $dir fifo2.tcl]]
#@ package ifneeded tcl::chan::halfpipe 1     [list source [file join $dir halfpipe.tcl]]
#@ package ifneeded tcl::chan::memchan 1.0.2  [list source [file join $dir memchan.tcl]]
#@ package ifneeded tcl::chan::null 1         [list source [file join $dir null.tcl]]
#@ package ifneeded tcl::chan::nullzero 1     [list source [file join $dir nullzero.tcl]]
#@ package ifneeded tcl::chan::random 1       [list source [file join $dir random.tcl]]
#@ package ifneeded tcl::chan::std 1.0.1      [list source [file join $dir std.tcl]]
#@ package ifneeded tcl::chan::string 1.0.1   [list source [file join $dir string.tcl]]
#@ package ifneeded tcl::chan::textwindow 1   [list source [file join $dir textwindow.tcl]]
#@ package ifneeded tcl::chan::variable 1.0.2 [list source [file join $dir variable.tcl]]
#@ package ifneeded tcl::chan::zero 1         [list source [file join $dir zero.tcl]]
#@ package ifneeded tcl::randomseed 1         [list source [file join $dir randseed.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/virtchannel_base/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/md5/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded md5 2.0.7 [list source [file join $dir md5x.tcl]]
#@ package ifneeded md5 1.4.4 [list source [file join $dir md5.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/md5/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/png/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded png 0.2 [list source [file join $dir png.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/png/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/csv/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded csv 0.8 [list source [file join $dir csv.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/csv/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/transfer/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} return
#@ package ifneeded transfer::copy              0.3 [list source [file join $dir copyops.tcl]]
#@ package ifneeded transfer::copy::queue       0.1 [list source [file join $dir tqueue.tcl]]
#@ package ifneeded transfer::data::source      0.2 [list source [file join $dir dsource.tcl]]
#@ package ifneeded transfer::data::destination 0.2 [list source [file join $dir ddest.tcl]]
#@ package ifneeded transfer::connect           0.2 [list source [file join $dir connect.tcl]]
#@ package ifneeded transfer::transmitter       0.2 [list source [file join $dir transmitter.tcl]]
#@ package ifneeded transfer::receiver          0.2 [list source [file join $dir receiver.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/transfer/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/ftp/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded ftp         2.4.11 [list source [file join $dir ftp.tcl]]
#@ package ifneeded ftp::geturl 0.2.1  [list source [file join $dir ftp_geturl.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/ftp/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/html/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded html 1.4 [list source [file join $dir html.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/html/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/ntp/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded time 1.2.1 [list source [file join $dir time.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/ntp/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/control/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded control 0.1.3 [list source [file join $dir control.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/control/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/doctools/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded doctools            1.4.14 [list source [file join $dir doctools.tcl]]
#@ package ifneeded doctools::toc       1.1.3  [list source [file join $dir doctoc.tcl]]
#@ package ifneeded doctools::idx       1.0.4  [list source [file join $dir docidx.tcl]]
#@ package ifneeded doctools::cvs       1      [list source [file join $dir cvs.tcl]]
#@ package ifneeded doctools::changelog 1      [list source [file join $dir changelog.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/doctools/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/stringprep/pkgIndex.tcl

#@ package ifneeded stringprep 1.0.1 [list source [file join $dir stringprep.tcl]]
#@ package ifneeded stringprep::data 1.0.1 [list source [file join $dir stringprep_data.tcl]]
#@ package ifneeded unicode 1.0.0 [list source [file join $dir unicode.tcl]]
#@ package ifneeded unicode::data 1.0.0 [list source [file join $dir unicode_data.tcl]]
#@ 
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/stringprep/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/snit/pkgIndex.tcl

#@ if {[package vsatisfies [package provide Tcl] 8.5]} {
#@     package ifneeded snit 2.3.2         [list source [file join $dir snit2.tcl]]
#@ }
#@ 
#@ package ifneeded snit 1.4.2 [list source [file join $dir snit.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/snit/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/comm/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.3]} {return}
#@ package ifneeded comm 4.6.2 [list source [file join $dir comm.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/comm/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/tepam/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.3]} {return}
#@ package ifneeded tepam   0.4.0 [list source [file join $dir tepam.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/tepam/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/bee/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded bee 0.1 [list source [file join $dir bee.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/bee/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/yaml/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded yaml 0.3.6 [list source [file join $dir yaml.tcl]]
#@ package ifneeded huddle 0.1.5 [list source [file join $dir huddle.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/yaml/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/uri/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {
#@     # FRINK: nocheck
#@     return
#@ }
#@ package ifneeded uri      1.2.2 [list source [file join $dir uri.tcl]]
#@ package ifneeded uri::urn 1.0.2 [list source [file join $dir urn-scheme.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/uri/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/pki/pkgIndex.tcl

#@ package ifneeded pki 0.6 [list source [file join $dir pki.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/pki/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/doctools2base/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ 
#@ # Packages for the doctools {idx,toc,doc} v2 implementation
#@ # (still v1.1 doc{idx,toc} languages).
#@ 
#@ # Supporting packages
#@ # - Handling configuration variables, and include paths.
#@ # - Handling text generation, the nroff man.macros definitions,
#@ #            HTML/XML generation, and the default CSS style
#@ # - Handling of message catalogs as packages.
#@ # - Recursive descent parser for Tcl strings (as expected by 'subst -novariables').
#@ 
#@ package ifneeded doctools::config            0.1 [list source [file join $dir config.tcl]]
#@ package ifneeded doctools::paths             0.1 [list source [file join $dir paths.tcl]]
#@ package ifneeded doctools::text              0.1 [list source [file join $dir text.tcl]]
#@ package ifneeded doctools::nroff::man_macros 0.1 [list source [file join $dir nroff_manmacros.tcl]]
#@ package ifneeded doctools::html              0.1 [list source [file join $dir html.tcl]]
#@ package ifneeded doctools::html::cssdefaults 0.1 [list source [file join $dir html_cssdefaults.tcl]]
#@ package ifneeded doctools::msgcat            0.1 [list source [file join $dir msgcat.tcl]]
#@ package ifneeded doctools::tcl::parse        0.1 [list source [file join $dir tcl_parse.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/doctools2base/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/nns/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8]} {return}
#@ package ifneeded nameserv::common 0.1 [list source [file join $dir common.tcl]]
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded nameserv         0.4.2 [list source [file join $dir nns.tcl]]
#@ package ifneeded nameserv::server 0.3.2 [list source [file join $dir server.tcl]]
#@ package ifneeded nameserv::auto   0.3   [list source [file join $dir nns_auto.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/nns/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/amazon-s3/pkgIndex.tcl

#@ # pkgIndex.tcl --
#@ # Copyright (c) 2006 Darren New
#@ # This is for the Amazon S3 web service packages.
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.5]} {return}
#@ 
#@ package ifneeded xsxp 1.0 [list source [file join $dir xsxp.tcl]]
#@ package ifneeded S3 1.0.0 [list source [file join $dir S3.tcl]]
#@ 
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/amazon-s3/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/ldap/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded ldap 1.8 [list source [file join $dir ldap.tcl]]
#@ 
#@ # the OO level wrapper for ldap
#@ package ifneeded ldapx 1.0 [list source [file join $dir ldapx.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/ldap/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/tar/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {
#@     # PRAGMA: returnok
#@     return
#@ }
#@ package ifneeded tar 0.7.1 [list source [file join $dir tar.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/tar/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/bibtex/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded bibtex 0.5 [list source [file join $dir bibtex.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/bibtex/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/otp/pkgIndex.tcl

#@ # pkgIndex.tcl -*- tcl -*-
#@ if {![package vsatisfies [package provide Tcl] 8.2]} { return }
#@ package ifneeded otp 1.0.0 [list source [file join $dir otp.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/otp/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/inifile/pkgIndex.tcl

#@ if { ![package vsatisfies [package provide Tcl] 8.2] } { return }
#@ package ifneeded inifile 0.2.5 [list source [file join $dir ini.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/inifile/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/rcs/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded rcs 0.1 [list source [file join $dir rcs.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/rcs/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/rc4/pkgIndex.tcl

#@ # pkgIndex.tcl - 
#@ #
#@ # RC4 package index file
#@ #
#@ # This package has been tested with tcl 8.2.3 and above.
#@ #
#@ # $Id: pkgIndex.tcl,v 1.4 2005/12/20 16:19:38 patthoyts Exp $
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.2]} {
#@     # PRAGMA: returnok
#@     return
#@ }
#@ package ifneeded rc4 1.1.0 [list source [file join $dir rc4.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/rc4/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/jpeg/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded jpeg 0.4.0 [list source [file join $dir jpeg.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/jpeg/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/grammar_fa/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ 
#@ package ifneeded grammar::fa            0.4   [list source [file join $dir fa.tcl]]
#@ package ifneeded grammar::fa::op        0.4.1 [list source [file join $dir faop.tcl]]
#@ package ifneeded grammar::fa::dacceptor 0.1.1 [list source [file join $dir dacceptor.tcl]]
#@ package ifneeded grammar::fa::dexec     0.2   [list source [file join $dir dexec.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/grammar_fa/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/treeql/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} {
#@     # PRAGMA: returnok
#@     return
#@ }
#@ package ifneeded treeql 1.3.1 [list source [file join $dir treeql.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/treeql/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/des/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {
#@     # PRAGMA: returnok
#@     return
#@ }
#@ package ifneeded des 1.1.0 [list source [file join $dir des.tcl]]
#@ package ifneeded tclDES 1.0.0 [list source [file join $dir tcldes.tcl]]
#@ package ifneeded tclDESjr 1.0.0 [list source [file join $dir tcldesjr.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/des/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/fileutil/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded fileutil 1.14.5 [list source [file join $dir fileutil.tcl]]
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.3]} {return}
#@ package ifneeded fileutil::traverse 0.4.3 [list source [file join $dir traverse.tcl]]
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded fileutil::multi     0.1   [list source [file join $dir multi.tcl]]
#@ package ifneeded fileutil::multi::op 0.5.3 [list source [file join $dir multiop.tcl]]
#@ package ifneeded fileutil::decode    0.1   [list source [file join $dir decode.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/fileutil/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/mapproj/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded mapproj 1.0 [list source [file join $dir mapproj.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/mapproj/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/base64/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded base64   2.4.2 [list source [file join $dir base64.tcl]]
#@ package ifneeded uuencode 1.1.5 [list source [file join $dir uuencode.tcl]]
#@ package ifneeded yencode  1.1.3 [list source [file join $dir yencode.tcl]]
#@ package ifneeded ascii85  1.0   [list source [file join $dir ascii85.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/base64/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/doctools2idx/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ 
#@ # Packages for the doctools idx v2 implementation
#@ # (still v1.1 docidx language).
#@ 
#@ # - Index container, mutable index objects
#@ # - Export and import management
#@ # - Export and import plugins
#@ # - Parser for docidx markup, and handling serializations
#@ # - Message catalogs for the parser
#@ 
#@ package ifneeded doctools::idx                 2   [list source [file join $dir container.tcl]]
#@ 
#@ package ifneeded doctools::idx::export         0.1 [list source [file join $dir export.tcl]]
#@ package ifneeded doctools::idx::import         0.1 [list source [file join $dir import.tcl]]
#@ 
#@ package ifneeded doctools::idx::export::docidx 0.1 [list source [file join $dir export_docidx.tcl]]
#@ package ifneeded doctools::idx::export::html   0.2 [list source [file join $dir export_html.tcl]]
#@ package ifneeded doctools::idx::export::json   0.1 [list source [file join $dir export_json.tcl]]
#@ package ifneeded doctools::idx::export::nroff  0.3 [list source [file join $dir export_nroff.tcl]]
#@ package ifneeded doctools::idx::export::text   0.2 [list source [file join $dir export_text.tcl]]
#@ package ifneeded doctools::idx::export::wiki   0.2 [list source [file join $dir export_wiki.tcl]]
#@ 
#@ package ifneeded doctools::idx::import::docidx 0.1 [list source [file join $dir import_docidx.tcl]]
#@ package ifneeded doctools::idx::import::json   0.1 [list source [file join $dir import_json.tcl]]
#@ 
#@ package ifneeded doctools::idx::parse          0.1 [list source [file join $dir parse.tcl]]
#@ package ifneeded doctools::idx::structure      0.1 [list source [file join $dir structure.tcl]]
#@ 
#@ package ifneeded doctools::msgcat::idx::c      0.1 [list source [file join $dir msgcat_c.tcl]]
#@ package ifneeded doctools::msgcat::idx::de     0.1 [list source [file join $dir msgcat_de.tcl]]
#@ package ifneeded doctools::msgcat::idx::en     0.1 [list source [file join $dir msgcat_en.tcl]]
#@ package ifneeded doctools::msgcat::idx::fr     0.1 [list source [file join $dir msgcat_fr.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/doctools2idx/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/pluginmgr/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded pluginmgr 0.3 [list source [file join $dir pluginmgr.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/pluginmgr/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/ripemd/pkgIndex.tcl

#@ # pkgIndex.tcl - 
#@ #
#@ # RIPEMD package index file
#@ #
#@ # This package has been tested with tcl 8.2.3 and above.
#@ #
#@ # $Id: pkgIndex.tcl,v 1.6 2009/05/07 01:12:59 patthoyts Exp $
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded ripemd128 1.0.4 [list source [file join $dir ripemd128.tcl]]
#@ package ifneeded ripemd160 1.0.4 [list source [file join $dir ripemd160.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/ripemd/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/grammar_me/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ 
#@ package ifneeded grammar::me::util      0.1 [list source [file join $dir me_util.tcl]]
#@ package ifneeded grammar::me::tcl       0.1 [list source [file join $dir me_tcl.tcl]]
#@ package ifneeded grammar::me::cpu       0.2 [list source [file join $dir me_cpu.tcl]]
#@ package ifneeded grammar::me::cpu::core 0.2 [list source [file join $dir me_cpucore.tcl]]
#@ package ifneeded grammar::me::cpu::gasm 0.1 [list source [file join $dir gasm.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/grammar_me/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/struct/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded struct            2.1   [list source [file join $dir struct.tcl]]
#@ package ifneeded struct            1.4   [list source [file join $dir struct1.tcl]]
#@ 
#@ package ifneeded struct::queue     1.4.4 [list source [file join $dir queue.tcl]]
#@ package ifneeded struct::stack     1.5.3 [list source [file join $dir stack.tcl]]
#@ package ifneeded struct::tree      2.1.2 [list source [file join $dir tree.tcl]]
#@ package ifneeded struct::matrix    2.0.2 [list source [file join $dir matrix.tcl]]
#@ package ifneeded struct::pool      1.2.1 [list source [file join $dir pool.tcl]]
#@ package ifneeded struct::record    1.2.1 [list source [file join $dir record.tcl]]
#@ package ifneeded struct::set       2.2.3 [list source [file join $dir sets.tcl]]
#@ package ifneeded struct::disjointset 1.0 [list source [file join $dir disjointset.tcl]]
#@ package ifneeded struct::prioqueue 1.4   [list source [file join $dir prioqueue.tcl]]
#@ package ifneeded struct::skiplist  1.3   [list source [file join $dir skiplist.tcl]]
#@ 
#@ package ifneeded struct::graph     1.2.1 [list source [file join $dir graph1.tcl]]
#@ package ifneeded struct::tree      1.2.2 [list source [file join $dir tree1.tcl]]
#@ package ifneeded struct::matrix    1.2.1 [list source [file join $dir matrix1.tcl]]
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded struct::list      1.8.2  [list source [file join $dir list.tcl]]
#@ package ifneeded struct::graph     2.4    [list source [file join $dir graph.tcl]]
#@ package ifneeded struct::graph::op 0.11.3 [list source [file join $dir graphops.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/struct/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/blowfish/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {
#@     # PRAGMA: returnok
#@     return
#@ }
#@ package ifneeded blowfish 1.0.4 [list source [file join $dir blowfish.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/blowfish/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/report/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded report 0.3.1 [list source [file join $dir report.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/report/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/valtype/pkgIndex.tcl

#@ package ifneeded valtype::common                 1 [list source [file join $dir valtype.tcl]]
#@ package ifneeded valtype::creditcard::amex       1 [list source [file join $dir cc_amex.tcl]]
#@ package ifneeded valtype::creditcard::discover   1 [list source [file join $dir cc_discover.tcl]]
#@ package ifneeded valtype::creditcard::mastercard 1 [list source [file join $dir cc_mastercard.tcl]]
#@ package ifneeded valtype::creditcard::visa       1 [list source [file join $dir cc_visa.tcl]]
#@ package ifneeded valtype::gs1::ean13             1 [list source [file join $dir ean13.tcl]]
#@ package ifneeded valtype::imei                   1 [list source [file join $dir imei.tcl]]
#@ package ifneeded valtype::isbn                   1 [list source [file join $dir isbn.tcl]]
#@ package ifneeded valtype::luhn                   1 [list source [file join $dir luhn.tcl]]
#@ package ifneeded valtype::luhn5                  1 [list source [file join $dir luhn5.tcl]]
#@ package ifneeded valtype::usnpi                  1 [list source [file join $dir usnpi.tcl]]
#@ package ifneeded valtype::verhoeff               1 [list source [file join $dir verhoeff.tcl]]
#@ package ifneeded valtype::iban                 1.1 [list source [file join $dir iban.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/valtype/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/cmdline/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded cmdline 1.3.3 [list source [file join $dir cmdline.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/cmdline/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/uuid/pkgIndex.tcl

#@ # pkgIndex.tcl - 
#@ #
#@ # uuid package index file
#@ #
#@ # $Id: pkgIndex.tcl,v 1.3 2012/11/19 19:28:24 andreas_kupries Exp $
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded uuid 1.0.2 [list source [file join $dir uuid.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/uuid/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/rest/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.5]} {return}
#@ package ifneeded rest 1.0 [list source [file join $dir rest.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/rest/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/javascript/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8]} {return}
#@ package ifneeded javascript 1.0.2 [list source [file join $dir javascript.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/javascript/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/simulation/pkgIndex.tcl

#@ package ifneeded simulation::random 0.3.1 [list source [file join $dir random.tcl]]
#@ package ifneeded simulation::montecarlo 0.1 [list source [file join $dir montecarlo.tcl]]
#@ package ifneeded simulation::annealing 0.2 [list source [file join $dir annealing.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/simulation/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/cache/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded cache::async 0.3 [list source [file join $dir async.tcl]]
#@ 
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/cache/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/nntp/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded nntp 0.2.1 [list source [file join $dir nntp.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/nntp/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/virtchannel_transform/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.6]} {return}
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/virtchannel_transform/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/generator/pkgIndex.tcl

#@ # Requires Tcl 8.6 and higher, to have the coroutines underlying generators.
#@ if {![package vsatisfies [package provide Tcl] 8.6]} return
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/generator/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/interp/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.3]} return
#@ package ifneeded interp                   0.1.2 [list source [file join $dir interp.tcl]]
#@ package ifneeded interp::delegate::proc   0.2   [list source [file join $dir deleg_proc.tcl]]
#@ package ifneeded interp::delegate::method 0.2   [list source [file join $dir deleg_method.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/interp/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/page/pkgIndex.tcl

#@ # -- PAGE application packages --
#@ # -- ---- plugin management
#@ 
#@ package ifneeded page::pluginmgr 0.2 [list source [file join $dir pluginmgr.tcl]]
#@ 
#@ # -- PAGE plugin packages
#@ # -- ---- Canned configurations
#@ 
#@ package ifneeded page::config::peg   0.1 [list source [file join $dir plugins/config_peg.tcl]]
#@ 
#@ # -- PAGE plugin packages
#@ # -- ---- Readers
#@ 
#@ package ifneeded page::reader::peg     0.1 [list source [file join $dir plugins/reader_peg.tcl]]
#@ package ifneeded page::reader::lemon   0.1 [list source [file join $dir plugins/reader_lemon.tcl]]
#@ package ifneeded page::reader::hb      0.1 [list source [file join $dir plugins/reader_hb.tcl]]
#@ package ifneeded page::reader::ser     0.1 [list source [file join $dir plugins/reader_ser.tcl]]
#@ package ifneeded page::reader::treeser 0.1 [list source [file join $dir plugins/reader_treeser.tcl]]
#@ 
#@ # -- PAGE plugin packages
#@ # -- ---- Writers
#@ 
#@ package ifneeded page::writer::null     0.1   [list source [file join $dir plugins/writer_null.tcl]]
#@ package ifneeded page::writer::me       0.1   [list source [file join $dir plugins/writer_me.tcl]]
#@ package ifneeded page::writer::mecpu    0.1.1 [list source [file join $dir plugins/writer_mecpu.tcl]]
#@ package ifneeded page::writer::tree     0.1   [list source [file join $dir plugins/writer_tree.tcl]]
#@ package ifneeded page::writer::tpc      0.1   [list source [file join $dir plugins/writer_tpc.tcl]]
#@ package ifneeded page::writer::hb       0.1   [list source [file join $dir plugins/writer_hb.tcl]]
#@ package ifneeded page::writer::ser      0.1   [list source [file join $dir plugins/writer_ser.tcl]]
#@ package ifneeded page::writer::peg      0.1   [list source [file join $dir plugins/writer_peg.tcl]]
#@ package ifneeded page::writer::identity 0.1   [list source [file join $dir plugins/writer_identity.tcl]]
#@ 
#@ # -- PAGE plugin packages
#@ # -- ---- Transformations
#@ 
#@ package ifneeded page::transform::reachable  0.1 	[list source [file join $dir plugins/transform_reachable.tcl]]
#@ package ifneeded page::transform::realizable 0.1 	[list source [file join $dir plugins/transform_realizable.tcl]]
#@ package ifneeded page::transform::mecpu 0.1 	[list source [file join $dir plugins/transform_mecpu.tcl]]
#@ 
#@ # -- PAGE packages --
#@ # -- --- Parsing and normalization packages used by the reader plugins.
#@ 
#@ package ifneeded page::parse::peg        0.1 [list source [file join $dir parse_peg.tcl]]
#@ package ifneeded page::parse::lemon      0.1 [list source [file join $dir parse_lemon.tcl]]
#@ package ifneeded page::parse::pegser     0.1 [list source [file join $dir parse_pegser.tcl]]
#@ package ifneeded page::parse::peghb      0.1 [list source [file join $dir parse_peghb.tcl]]
#@ 
#@ package ifneeded page::util::norm::peg   0.1 [list source [file join $dir util_norm_peg.tcl]]
#@ package ifneeded page::util::norm::lemon 0.1 [list source [file join $dir util_norm_lemon.tcl]]
#@ 
#@ # @mdgen EXCLUDE: peg_grammar.tcl
#@ ### package ifneeded pg::peg::grammar      0.1 [list source [file join $dir peg_grammar.tcl]]
#@ 
#@ # -- PAGE packages --
#@ # -- --- Code generation packages used by the writer plugins.
#@ 
#@ package ifneeded page::gen::tree::text 0.1 [list source [file join $dir gen_tree_text.tcl]]
#@ package ifneeded page::gen::peg::cpkg  0.1 [list source [file join $dir gen_peg_cpkg.tcl]]
#@ package ifneeded page::gen::peg::hb    0.1 [list source [file join $dir gen_peg_hb.tcl]]
#@ package ifneeded page::gen::peg::ser   0.1 [list source [file join $dir gen_peg_ser.tcl]]
#@ package ifneeded page::gen::peg::canon 0.1 [list source [file join $dir gen_peg_canon.tcl]]
#@ package ifneeded page::gen::peg::me    0.1 [list source [file join $dir gen_peg_me.tcl]]
#@ package ifneeded page::gen::peg::mecpu 0.1 [list source [file join $dir gen_peg_mecpu.tcl]]
#@ 
#@ # -- Transformation Helper Packages --
#@ 
#@ package ifneeded page::analysis::peg::minimize   0.1 [list source [file join $dir analysis_peg_minimize.tcl]]
#@ package ifneeded page::analysis::peg::reachable  0.1 [list source [file join $dir analysis_peg_reachable.tcl]]
#@ package ifneeded page::analysis::peg::realizable 0.1 [list source [file join $dir analysis_peg_realizable.tcl]]
#@ package ifneeded page::analysis::peg::emodes     0.1 [list source [file join $dir analysis_peg_emodes.tcl]]
#@ package ifneeded page::compiler::peg::mecpu      0.1.1 [list source [file join $dir compiler_peg_mecpu.tcl]]
#@ 
#@ # -- Various other utilities --
#@ 
#@ package ifneeded page::util::peg   0.1 [list source [file join $dir util_peg.tcl]]
#@ package ifneeded page::util::quote 0.1 [list source [file join $dir util_quote.tcl]]
#@ package ifneeded page::util::flow  0.1 [list source [file join $dir util_flow.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/page/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/crc/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded cksum 1.1.3 [list source [file join $dir cksum.tcl]]
#@ package ifneeded crc16 1.1.2 [list source [file join $dir crc16.tcl]]
#@ package ifneeded crc32 1.3.1 [list source [file join $dir crc32.tcl]]
#@ package ifneeded sum   1.1.0 [list source [file join $dir sum.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/crc/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/counter/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded counter 2.0.4 [list source [file join $dir counter.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/counter/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/lambda/pkgIndex.tcl

#@ #checker -scope global exclude warnUndefinedVar
#@ # var in question is 'dir'.
#@ if {![package vsatisfies [package provide Tcl] 8.5]} {
#@     # PRAGMA: returnok
#@     return
#@ }
#@ # Utility wrapper around ::apply for easier writing.
#@ package ifneeded lambda 1 [list source [file join $dir lambda.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/lambda/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/ooutil/pkgIndex.tcl

#@ #checker -scope global exclude warnUndefinedVar
#@ # var in question is 'dir'.
#@ if {![package vsatisfies [package provide Tcl] 8.5]} {
#@     # PRAGMA: returnok
#@     return
#@ }
#@ package ifneeded oo::util 1.1 [list source [file join $dir ooutil.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/ooutil/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/gpx/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.5]} {return}
#@ package ifneeded gpx 1 [list source [file join $dir gpx.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcllib1.15/gpx/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/snps_tcl/snpsTclPro/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex -direct" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded snpsTclPro 1.0 [list source [file join $dir			snpsTclPro.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/snps_tcl/snpsTclPro/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcl8.5/msgcat/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8.5]} {return}
#@ package ifneeded msgcat 1.4.5 [list source [file join $dir msgcat.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcl8.5/msgcat/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcl8.5/http/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.4]} {return}
#@ package ifneeded http 2.7.9 [list tclPkgSetup $dir http 2.7.9 {{http.tcl source {::http::config ::http::formatQuery ::http::geturl ::http::reset ::http::wait ::http::register ::http::unregister ::http::mapReply}}}]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcl8.5/http/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcl8.5/platform/pkgIndex.tcl

#@ package ifneeded platform        1.0.10 [list source [file join $dir platform.tcl]]
#@ package ifneeded platform::shell 1.1.4 [list source [file join $dir shell.tcl]]
#@ 
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcl8.5/platform/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcl8.5/opt/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex -direct" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.2]} {return}
#@ package ifneeded opt 0.4.5 [list source [file join $dir optparse.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcl8.5/opt/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcl8.5/dde/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8]} return
#@ if {[info sharedlibextension] != ".dll"} return
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcl8.5/dde/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcl8.5/http1.0/pkgIndex.tcl

#@ # Tcl package index file, version 1.0
#@ # This file is generated by the "pkg_mkIndex" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ package ifneeded http 1.0 [list tclPkgSetup $dir http 1.0 {{http.tcl source {httpCopyDone httpCopyStart httpEof httpEvent httpFinish httpMapReply httpProxyRequired http_code http_config http_data http_formatQuery http_get http_reset http_size http_status http_wait}}}]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcl8.5/http1.0/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcl8.5/reg/pkgIndex.tcl

#@ if {![package vsatisfies [package provide Tcl] 8]} return
#@ if {[info sharedlibextension] != ".dll"} return
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcl8.5/reg/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcl8.5/tcltest/pkgIndex.tcl

#@ # Tcl package index file, version 1.1
#@ # This file is generated by the "pkg_mkIndex -direct" command
#@ # and sourced either when an application starts up or
#@ # by a "package unknown" script.  It invokes the
#@ # "package ifneeded" command to set up package-related
#@ # information so that packages will be loaded automatically
#@ # in response to "package require" commands.  When this
#@ # script is sourced, the variable $dir must contain the
#@ # full path name of this file's directory.
#@ 
#@ if {![package vsatisfies [package provide Tcl] 8.5]} {return}
#@ package ifneeded tcltest 2.3.4 [list source [file join $dir tcltest.tcl]]
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcl8.5/tcltest/pkgIndex.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcl8.5/msgcat/msgcat.tcl

#@ # msgcat.tcl --
#@ #
#@ #	This file defines various procedures which implement a
#@ #	message catalog facility for Tcl programs.  It should be
#@ #	loaded with the command "package require msgcat".
#@ #
#@ # Copyright (c) 1998-2000 by Ajuba Solutions.
#@ # Copyright (c) 1998 by Mark Harrison.
#@ #
#@ # See the file "license.terms" for information on usage and redistribution
#@ # of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#@ 
#@ package require Tcl 8.5
#@ # When the version number changes, be sure to update the pkgIndex.tcl file,
#@ # and the installation directory in the Makefiles.
#@ package provide msgcat 1.4.5
#@ 
#@ namespace eval msgcat {
#@     namespace export mc mcload mclocale mcmax mcmset mcpreferences mcset 	    mcunknown
#@ 
#@     # Records the current locale as passed to mclocale
#@     variable Locale ""
#@ 
#@     # Records the list of locales to search
#@     variable Loclist {}
#@ 
#@     # Records the mapping between source strings and translated strings.  The
#@     # dict key is of the form "<locale> <namespace> <src>", where locale and
#@     # namespace should be themselves dict values and the value is
#@     # the translated string.
#@     variable Msgs [dict create]
#@ 
#@     # Map of language codes used in Windows registry to those of ISO-639
#@     if {[info sharedlibextension] eq ".dll"} {
#@ 	variable WinRegToISO639 [dict create  {*}{
#@ 	    01 ar 0401 ar_SA 0801 ar_IQ 0c01 ar_EG 1001 ar_LY 1401 ar_DZ
#@ 		  1801 ar_MA 1c01 ar_TN 2001 ar_OM 2401 ar_YE 2801 ar_SY
#@ 		  2c01 ar_JO 3001 ar_LB 3401 ar_KW 3801 ar_AE 3c01 ar_BH
#@ 		  4001 ar_QA
#@ 	    02 bg 0402 bg_BG
#@ 	    03 ca 0403 ca_ES
#@ 	    04 zh 0404 zh_TW 0804 zh_CN 0c04 zh_HK 1004 zh_SG 1404 zh_MO
#@ 	    05 cs 0405 cs_CZ
#@ 	    06 da 0406 da_DK
#@ 	    07 de 0407 de_DE 0807 de_CH 0c07 de_AT 1007 de_LU 1407 de_LI
#@ 	    08 el 0408 el_GR
#@ 	    09 en 0409 en_US 0809 en_GB 0c09 en_AU 1009 en_CA 1409 en_NZ
#@ 		  1809 en_IE 1c09 en_ZA 2009 en_JM 2409 en_GD 2809 en_BZ
#@ 		  2c09 en_TT 3009 en_ZW 3409 en_PH
#@ 	    0a es 040a es_ES 080a es_MX 0c0a es_ES@modern 100a es_GT 140a es_CR
#@ 		  180a es_PA 1c0a es_DO 200a es_VE 240a es_CO 280a es_PE
#@ 		  2c0a es_AR 300a es_EC 340a es_CL 380a es_UY 3c0a es_PY
#@ 		  400a es_BO 440a es_SV 480a es_HN 4c0a es_NI 500a es_PR
#@ 	    0b fi 040b fi_FI
#@ 	    0c fr 040c fr_FR 080c fr_BE 0c0c fr_CA 100c fr_CH 140c fr_LU
#@ 		  180c fr_MC
#@ 	    0d he 040d he_IL
#@ 	    0e hu 040e hu_HU
#@ 	    0f is 040f is_IS
#@ 	    10 it 0410 it_IT 0810 it_CH
#@ 	    11 ja 0411 ja_JP
#@ 	    12 ko 0412 ko_KR
#@ 	    13 nl 0413 nl_NL 0813 nl_BE
#@ 	    14 no 0414 no_NO 0814 nn_NO
#@ 	    15 pl 0415 pl_PL
#@ 	    16 pt 0416 pt_BR 0816 pt_PT
#@ 	    17 rm 0417 rm_CH
#@ 	    18 ro 0418 ro_RO 0818 ro_MO
#@ 	    19 ru 0819 ru_MO
#@ 	    1a hr 041a hr_HR 081a sr_YU 0c1a sr_YU@cyrillic
#@ 	    1b sk 041b sk_SK
#@ 	    1c sq 041c sq_AL
#@ 	    1d sv 041d sv_SE 081d sv_FI
#@ 	    1e th 041e th_TH
#@ 	    1f tr 041f tr_TR
#@ 	    20 ur 0420 ur_PK 0820 ur_IN
#@ 	    21 id 0421 id_ID
#@ 	    22 uk 0422 uk_UA
#@ 	    23 be 0423 be_BY
#@ 	    24 sl 0424 sl_SI
#@ 	    25 et 0425 et_EE
#@ 	    26 lv 0426 lv_LV
#@ 	    27 lt 0427 lt_LT
#@ 	    28 tg 0428 tg_TJ
#@ 	    29 fa 0429 fa_IR
#@ 	    2a vi 042a vi_VN
#@ 	    2b hy 042b hy_AM
#@ 	    2c az 042c az_AZ@latin 082c az_AZ@cyrillic
#@ 	    2d eu
#@ 	    2e wen 042e wen_DE
#@ 	    2f mk 042f mk_MK
#@ 	    30 bnt 0430 bnt_TZ
#@ 	    31 ts 0431 ts_ZA
#@ 	    32 tn
#@ 	    33 ven 0433 ven_ZA
#@ 	    34 xh 0434 xh_ZA
#@ 	    35 zu 0435 zu_ZA
#@ 	    36 af 0436 af_ZA
#@ 	    37 ka 0437 ka_GE
#@ 	    38 fo 0438 fo_FO
#@ 	    39 hi 0439 hi_IN
#@ 	    3a mt 043a mt_MT
#@ 	    3b se 043b se_NO
#@ 	    043c gd_UK 083c ga_IE
#@ 	    3d yi 043d yi_IL
#@ 	    3e ms 043e ms_MY 083e ms_BN
#@ 	    3f kk 043f kk_KZ
#@ 	    40 ky 0440 ky_KG
#@ 	    41 sw 0441 sw_KE
#@ 	    42 tk 0442 tk_TM
#@ 	    43 uz 0443 uz_UZ@latin 0843 uz_UZ@cyrillic
#@ 	    44 tt 0444 tt_RU
#@ 	    45 bn 0445 bn_IN
#@ 	    46 pa 0446 pa_IN
#@ 	    47 gu 0447 gu_IN
#@ 	    48 or 0448 or_IN
#@ 	    49 ta
#@ 	    4a te 044a te_IN
#@ 	    4b kn 044b kn_IN
#@ 	    4c ml 044c ml_IN
#@ 	    4d as 044d as_IN
#@ 	    4e mr 044e mr_IN
#@ 	    4f sa 044f sa_IN
#@ 	    50 mn
#@ 	    51 bo 0451 bo_CN
#@ 	    52 cy 0452 cy_GB
#@ 	    53 km 0453 km_KH
#@ 	    54 lo 0454 lo_LA
#@ 	    55 my 0455 my_MM
#@ 	    56 gl 0456 gl_ES
#@ 	    57 kok 0457 kok_IN
#@ 	    58 mni 0458 mni_IN
#@ 	    59 sd
#@ 	    5a syr 045a syr_TR
#@ 	    5b si 045b si_LK
#@ 	    5c chr 045c chr_US
#@ 	    5d iu 045d iu_CA
#@ 	    5e am 045e am_ET
#@ 	    5f ber 045f ber_MA
#@ 	    60 ks 0460 ks_PK 0860 ks_IN
#@ 	    61 ne 0461 ne_NP 0861 ne_IN
#@ 	    62 fy 0462 fy_NL
#@ 	    63 ps
#@ 	    64 tl 0464 tl_PH
#@ 	    65 div 0465 div_MV
#@ 	    66 bin 0466 bin_NG
#@ 	    67 ful 0467 ful_NG
#@ 	    68 ha 0468 ha_NG
#@ 	    69 nic 0469 nic_NG
#@ 	    6a yo 046a yo_NG
#@ 	    70 ibo 0470 ibo_NG
#@ 	    71 kau 0471 kau_NG
#@ 	    72 om 0472 om_ET
#@ 	    73 ti 0473 ti_ET
#@ 	    74 gn 0474 gn_PY
#@ 	    75 cpe 0475 cpe_US
#@ 	    76 la 0476 la_VA
#@ 	    77 so 0477 so_SO
#@ 	    78 sit 0478 sit_CN
#@ 	    79 pap 0479 pap_AN
#@ 	}]
#@     }
#@ }
#@ 
#@ # msgcat::mc --
#@ #
#@ #	Find the translation for the given string based on the current
#@ #	locale setting. Check the local namespace first, then look in each
#@ #	parent namespace until the source is found.  If additional args are
#@ #	specified, use the format command to work them into the traslated
#@ #	string.
#@ #
#@ # Arguments:
#@ #	src	The string to translate.
#@ #	args	Args to pass to the format command
#@ #
#@ # Results:
#@ #	Returns the translated string.  Propagates errors thrown by the
#@ #	format command.
#@ 
#@ proc msgcat::mc {src args} {
#@     # Check for the src in each namespace starting from the local and
#@     # ending in the global.
#@ 
#@     variable Msgs
#@     variable Loclist
#@     variable Locale
#@ 
#@     set ns [uplevel 1 [list ::namespace current]]
#@ 
#@     while {$ns != ""} {
#@ 	foreach loc $Loclist {
#@ 	    if {[dict exists $Msgs $loc $ns $src]} {
#@ 		if {[llength $args] == 0} {
#@ 		    return [dict get $Msgs $loc $ns $src]
#@ 		} else {
#@ 		    return [format [dict get $Msgs $loc $ns $src] {*}$args]
#@ 		}
#@ 	    }
#@ 	}
#@ 	set ns [namespace parent $ns]
#@     }
#@     # we have not found the translation
#@     return [uplevel 1 [list [namespace origin mcunknown] 	    $Locale $src {*}$args]]
#@ }
#@ 
#@ # msgcat::mclocale --
#@ #
#@ #	Query or set the current locale.
#@ #
#@ # Arguments:
#@ #	newLocale	(Optional) The new locale string. Locale strings
#@ #			should be composed of one or more sublocale parts
#@ #			separated by underscores (e.g. en_US).
#@ #
#@ # Results:
#@ #	Returns the current locale.
#@ 
#@ proc msgcat::mclocale {args} {
#@     variable Loclist
#@     variable Locale
#@     set len [llength $args]
#@ 
#@     if {$len > 1} {
#@ 	return -code error "wrong # args: should be		\"[lindex [info level 0] 0] ?newLocale?\""
#@     }
#@ 
#@     if {$len == 1} {
#@ 	set newLocale [lindex $args 0]
#@ 	if {$newLocale ne [file tail $newLocale]} {
#@ 	    return -code error "invalid newLocale value \"$newLocale\":		    could be path to unsafe code."
#@ 	}
#@ 	set Locale [string tolower $newLocale]
#@ 	set Loclist {}
#@ 	set word ""
#@ 	foreach part [split $Locale _] {
#@ 	    set word [string trim "${word}_${part}" _]
#@ 	    if {$word ne [lindex $Loclist 0]} {
#@ 		set Loclist [linsert $Loclist 0 $word]
#@ 	    }
#@ 	}
#@ 	lappend Loclist {}
#@ 	set Locale [lindex $Loclist 0]
#@     }
#@     return $Locale
#@ }
#@ 
#@ # msgcat::mcpreferences --
#@ #
#@ #	Fetch the list of locales used to look up strings, ordered from
#@ #	most preferred to least preferred.
#@ #
#@ # Arguments:
#@ #	None.
#@ #
#@ # Results:
#@ #	Returns an ordered list of the locales preferred by the user.
#@ 
#@ proc msgcat::mcpreferences {} {
#@     variable Loclist
#@     return $Loclist
#@ }
#@ 
#@ # msgcat::mcload --
#@ #
#@ #	Attempt to load message catalogs for each locale in the
#@ #	preference list from the specified directory.
#@ #
#@ # Arguments:
#@ #	langdir		The directory to search.
#@ #
#@ # Results:
#@ #	Returns the number of message catalogs that were loaded.
#@ 
#@ proc msgcat::mcload {langdir} {
#@     set x 0
#@     foreach p [mcpreferences] {
#@ 	if { $p eq {} } {
#@ 	    set p ROOT
#@ 	}
#@ 	set langfile [file join $langdir $p.msg]
#@ 	if {[file exists $langfile]} {
#@ 	    incr x
#@ 	    uplevel 1 [list ::source -encoding utf-8 $langfile]
#@ 	}
#@     }
#@     return $x
#@ }
#@ 
#@ # msgcat::mcset --
#@ #
#@ #	Set the translation for a given string in a specified locale.
#@ #
#@ # Arguments:
#@ #	locale		The locale to use.
#@ #	src		The source string.
#@ #	dest		(Optional) The translated string.  If omitted,
#@ #			the source string is used.
#@ #
#@ # Results:
#@ #	Returns the new locale.
#@ 
#@ proc msgcat::mcset {locale src {dest ""}} {
#@     variable Msgs
#@     if {[llength [info level 0]] == 3} { ;# dest not specified
#@ 	set dest $src
#@     }
#@ 
#@     set ns [uplevel 1 [list ::namespace current]]
#@ 
#@     set locale [string tolower $locale]
#@ 
#@     dict set Msgs $locale $ns $src $dest
#@     return $dest
#@ }
#@ 
#@ # msgcat::mcmset --
#@ #
#@ #	Set the translation for multiple strings in a specified locale.
#@ #
#@ # Arguments:
#@ #	locale		The locale to use.
#@ #	pairs		One or more src/dest pairs (must be even length)
#@ #
#@ # Results:
#@ #	Returns the number of pairs processed
#@ 
#@ proc msgcat::mcmset {locale pairs } {
#@     variable Msgs
#@ 
#@     set length [llength $pairs]
#@     if {$length % 2} {
#@ 	return -code error "bad translation list:		 should be \"[lindex [info level 0] 0] locale {src dest ...}\""
#@     }
#@ 
#@     set locale [string tolower $locale]
#@     set ns [uplevel 1 [list ::namespace current]]
#@ 
#@     foreach {src dest} $pairs {
#@ 	dict set Msgs $locale $ns $src $dest
#@     }
#@ 
#@     return $length
#@ }
#@ 
#@ # msgcat::mcunknown --
#@ #
#@ #	This routine is called by msgcat::mc if a translation cannot
#@ #	be found for a string.  This routine is intended to be replaced
#@ #	by an application specific routine for error reporting
#@ #	purposes.  The default behavior is to return the source string.
#@ #	If additional args are specified, the format command will be used
#@ #	to work them into the traslated string.
#@ #
#@ # Arguments:
#@ #	locale		The current locale.
#@ #	src		The string to be translated.
#@ #	args		Args to pass to the format command
#@ #
#@ # Results:
#@ #	Returns the translated value.
#@ 
#@ proc msgcat::mcunknown {locale src args} {
#@     if {[llength $args]} {
#@ 	return [format $src {*}$args]
#@     } else {
#@ 	return $src
#@     }
#@ }
#@ 
#@ # msgcat::mcmax --
#@ #
#@ #	Calculates the maximum length of the translated strings of the given
#@ #	list.
#@ #
#@ # Arguments:
#@ #	args	strings to translate.
#@ #
#@ # Results:
#@ #	Returns the length of the longest translated string.
#@ 
#@ proc msgcat::mcmax {args} {
#@     set max 0
#@     foreach string $args {
#@ 	set translated [uplevel 1 [list [namespace origin mc] $string]]
#@ 	set len [string length $translated]
#@ 	if {$len>$max} {
#@ 	    set max $len
#@ 	}
#@     }
#@     return $max
#@ }
#@ 
#@ # Convert the locale values stored in environment variables to a form
#@ # suitable for passing to [mclocale]
#@ proc msgcat::ConvertLocale {value} {
#@     # Assume $value is of form: $language[_$territory][.$codeset][@modifier]
#@     # Convert to form: $language[_$territory][_$modifier]
#@     #
#@     # Comment out expanded RE version -- bugs alleged
#@     # regexp -expanded {
#@     #	^		# Match all the way to the beginning
#@     #	([^_.@]*)	# Match "lanugage"; ends with _, ., or @
#@     #	(_([^.@]*))?	# Match (optional) "territory"; starts with _
#@     #	([.]([^@]*))?	# Match (optional) "codeset"; starts with .
#@     #	(@(.*))?	# Match (optional) "modifier"; starts with @
#@     #	$		# Match all the way to the end
#@     # } $value -> language _ territory _ codeset _ modifier
#@     if {![regexp {^([^_.@]+)(_([^.@]*))?([.]([^@]*))?(@(.*))?$} $value 	    -> language _ territory _ codeset _ modifier]} {
#@ 	return -code error "invalid locale '$value': empty language part"
#@     }
#@     set ret $language
#@     if {[string length $territory]} {
#@ 	append ret _$territory
#@     }
#@     if {[string length $modifier]} {
#@ 	append ret _$modifier
#@     }
#@     return $ret
#@ }
#@ 
#@ # Initialize the default locale
#@ proc msgcat::Init {} {
#@     global env
#@ 
#@     #
#@     # set default locale, try to get from environment
#@     #
#@     foreach varName {LC_ALL LC_MESSAGES LANG} {
#@ 	if {[info exists env($varName)] && ("" ne $env($varName))} {
#@ 	    if {![catch {
#@ 		mclocale [ConvertLocale $env($varName)]
#@ 	    }]} {
#@ 		return
#@ 	    }
#@ 	}
#@     }
#@     #
#@     # On Darwin, fallback to current CFLocale identifier if available.
#@     #
#@     if {[info exists ::tcl::mac::locale] && $::tcl::mac::locale ne ""} {
#@ 	if {![catch {
#@ 	    mclocale [ConvertLocale $::tcl::mac::locale]
#@ 	}]} {
#@ 	    return
#@ 	}
#@     }
#@     #
#@     # The rest of this routine is special processing for Windows or
#@     # Cygwin. All other platforms, get out now.
#@     #
#@     if {([info sharedlibextension] ne ".dll")
#@ 	    || [catch {package require registry}]} {
#@ 	mclocale C
#@ 	return
#@     }
#@     #
#@     # On Windows or Cygwin, try to set locale depending on registry
#@     # settings, or fall back on locale of "C".
#@     #
#@ 
#@     # First check registry value LocalName present from Windows Vista
#@     # which contains the local string as RFC5646, composed of:
#@     # [a-z]{2,3} : language
#@     # -[a-z]{4}  : script (optional, translated by table Latn->latin)
#@     # -[a-z]{2}|[0-9]{3} : territory (optional, numerical region codes not used)
#@     # (-.*)* : variant, extension, private use (optional, not used)
#@     # Those are translated to local strings.
#@     # Examples: de-CH -> de_ch, sr-Latn-CS -> sr_cs@latin, es-419 -> es
#@     #
#@     set key {HKEY_CURRENT_USER\Control Panel\International}
#@     if {([registry values $key "LocaleName"] ne "")
#@ 	    && [regexp {^([a-z]{2,3})(?:-([a-z]{4}))?(?:-([a-z]{2}))?(?:-.+)?$}	    [string tolower [registry get $key "LocaleName"]] match locale	    script territory]} {
#@ 	if {"" ne $territory} {
#@ 	    append locale _ $territory
#@ 	}
#@ 	set modifierDict [dict create latn latin cyrl cyrillic]
#@ 	if {[dict exists $modifierDict $script]} {
#@ 	    append locale @ [dict get $modifierDict $script]
#@ 	}
#@ 	if {![catch {
#@ 	    mclocale [ConvertLocale $locale]
#@ 	}]} {
#@ 	    return
#@ 	}
#@     }
#@ 
#@     # then check key locale which contains a numerical language ID
#@     if {[catch {
#@ 	set locale [registry get $key "locale"]
#@     }]} {
#@ 	mclocale C
#@ 	return
#@     }
#@     #
#@     # Keep trying to match against smaller and smaller suffixes
#@     # of the registry value, since the latter hexadigits appear
#@     # to determine general language and earlier hexadigits determine
#@     # more precise information, such as territory.  For example,
#@     #     0409 - English - United States
#@     #     0809 - English - United Kingdom
#@     # Add more translations to the WinRegToISO639 array above.
#@     #
#@     variable WinRegToISO639
#@     set locale [string tolower $locale]
#@     while {[string length $locale]} {
#@ 	if {![catch {
#@ 	    mclocale [ConvertLocale [dict get $WinRegToISO639 $locale]]
#@ 	}]} {
#@ 	    return
#@ 	}
#@ 	set locale [string range $locale 1 end]
#@     }
#@     #
#@     # No translation known.  Fall back on "C" locale
#@     #
#@     mclocale C
#@ }
#@ msgcat::Init
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/auxx/tcllib/lib/tcl8.5/msgcat/msgcat.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/doc/dware/AMBA/amba.tcl

#@ namespace eval AMBA {
#@ 
#@   proc Launch {} {
#@ 
#@     if {[string equal [get_workspace_name -quiet] ""]} {
#@       set result [msg_box -icon question                           -msgType yesno                           "The AMBA Subsystem Assembly Wizard cannot be started until you have created a workspace.
#@ Would you like to do so now?"]
#@       if {[string equal $result "Yes"]} {
#@         create_workspace -gui
#@       }
#@     }
#@ 
#@     if {![verifyComponents]} {
#@       return
#@     }
#@ 
#@     if {![string equal [get_workspace_name -quiet] ""]} {
#@       show_url $::synopsys_root/doc/dware/AMBA/amba.html "" "AMBA Subsystem Assembly Wizard"
#@       refreshHtml
#@       set act [find_item -type activity AddSubsystemComponents -should 1]
#@       sAct::DlgActivateBoundActivity $act
#@     }
#@   }
#@ 
#@   proc InitializeSubsystem {} {
#@     if {[string equal [all_components] ""]} {
#@       set result {
#@ <P>Choose the initial subsystem below which is closest to your needs. This
#@ is just a starting point, and can be added to, or subtracted from as
#@ desired.
#@ <P>
#@ <UL>
#@       }
#@       set systems {
#@         {{AHB} {i_ahb DW_ahb}} 
#@         {{AHB + APB} {i_ahb DW_ahb i_apb DW_apb}}
#@         {{AHB + APB + APB} {i_ahb DW_ahb i_apb1 DW_apb i_apb2 DW_apb}}
#@       }
#@       foreach system $systems {
#@         set label [lindex $system 0]
#@         set init_args [lindex $system 1]
#@         append result "
#@ <LI>
#@ <A HREF=\"cgi:AMBA::createInitialSubsystem%20\{$init_args\}\">$label</A>
#@ </LI>
#@ "
#@       }
#@       append result "</UL>"
#@     } else {
#@       set result {
#@ <P>You already have a subsystem in progress. <A HREF="cgi:AMBA::resetSubsystem%3B%20AMBA::refreshHtml">Click
#@ here</A> to delete your existing subsystem and start over. 
#@       }
#@     }
#@     return $result
#@   }
#@ 
#@   proc createInitialSubsystem {contents} {
#@ 
#@     sUtils::try {
#@       # Build the subsystem with the given contents.
#@       foreach {instance component} $contents {
#@         instantiate_component -name $instance $component
#@       }
#@     } catch-throw {
#@       resetSubsystem
#@     }
#@ 
#@     # Refresh the page.
#@     refreshHtml
#@   }
#@ 
#@   proc resetSubsystem {} {
#@     set exported [find_item -quiet -type interfaceInstance -hidden -search <current>]
#@     if {[sizeof_collection $exported]} {remove_item $exported}
#@     foreach compName [all_components] {
#@       remove_component $compName
#@     }
#@   }
#@ 
#@   proc refreshHtml {} {
#@     set browsers [find_item -quiet -type DlgBrowser -filter Value=~.*/amba.html]
#@     if {[sizeof_collection $browsers]} {
#@       set page [get_attribute [index_collection $browsers 0] -attr Value]
#@       set_attribute $browsers -attr Value -value $page
#@     }
#@   }
#@ 
#@   proc verifyComponents {} {
#@     array set components [get_installed_component_names]
#@     if {![info exists components(DW_ahb)] ||
#@         ![info exists components(DW_apb)]} {
#@       if {[info exists ::env(DESIGNWARE_HOME)]} {
#@         # Try to fix the component search path.
#@         set dw_home_latest [file join [getenv DESIGNWARE_HOME] iip latest]
#@         if {[file exists $dw_home_latest]} {
#@           set_activity_parameter AddSubsystemComponents SearchPath $dw_home_latest
#@           unset components
#@           array set components [get_installed_component_names]
#@         }
#@       }
#@     }
#@ 
#@     if {![info exists components(DW_ahb)] ||
#@         ![info exists components(DW_apb)]} {
#@       if {[info exists ::env(DESIGNWARE_HOME)]} {
#@         msg_box -icon exclamation                 -msgType okcancel "The DesignWare AMBA components cannot be found using the current setting of the
#@ DESIGNWARE_HOME variable. This probably means the variable is set to point at the
#@ wrong directory. When set correctly, the specified directory will contain the
#@ sub-directory 'iip'.
#@ Current value: [getenv DESIGNWARE_HOME]"
#@       } else {
#@         msg_box -icon exclamation                 -msgType okcancel "The DesignWare AMBA components cannot be found using the existing component search path.
#@ Please set the environment variable DESIGNWARE_HOME to point at the DesignWare
#@ installation area and then launch the wizard again. This can be done within
#@ coreAssembler using the builtin 'setenv' command."
#@       }
#@ 
#@       return 0
#@     }
#@     
#@     return 1
#@   }
#@ 
#@   proc AddComponents {} {
#@     set result {}
#@ 
#@     set orderedIndex {DW_ahb/AHB_Master DW_ahb/AHB_Slave DW_apb/APB_Slave}
#@     set labels(DW_ahb/AHB_Master) {AHB Master}
#@     set labels(DW_ahb/AHB_Slave)  {AHB Slave}
#@     set labels(DW_apb/APB_Slave)  {APB Slave}
#@ 
#@     # Determine available components.
#@     GetAvailableComponents $orderedIndex components
#@ 
#@     foreach entry $orderedIndex {
#@       set data [split $entry "/"]
#@       set bus [lindex $data 0]
#@       set interface [lindex $data 1]
#@       set busInstances [getInstances $bus]
#@       if {[sizeof_collection $busInstances]} {
#@         append result "<UL>\n"
#@         foreach_in_collection busInstance $busInstances {
#@           set instanceName [get_attribute $busInstance -attr Name]
#@           set columns 3
#@           set index 0
#@           append result "<li>Add new $labels($entry) to <b>$instanceName</b>\n"
#@           append result "<TABLE WIDTH=\"100%\">\n"
#@           foreach component $components($entry) {
#@             incr index
#@             if {[expr {$index % $columns}] == 1} {
#@               if {$index > 1} {
#@                 append result "</TR>\n"
#@               }
#@               append result "<TR>\n"
#@             }
#@             regsub {^<} $component {\&lt } htmlComponent
#@             regsub {>$} $htmlComponent {\&gt } htmlComponent
#@             set ref [sHtml::quote_url                "cgi:AMBA::AddComponentToBus $component $instanceName $bus $interface"]
#@             append result "<TD><UL><LI><A HREF=\"$ref\">$htmlComponent</A></LI></UL></TD>\n"
#@           }
#@           append result "</TR></TABLE>\n"
#@         }
#@         append result "</UL>\n"
#@       }
#@     }
#@ 
#@     if {[string equal $result {}]} {
#@       set result {<P>Not available until initial subsystem has been defined in the Initialize Subsystem section\n.}
#@     } else {
#@       # Prepend link to add new AHB to the subsystem.
#@       set cmd {instantiate_component DW_ahb -name [sAssemblerKb::generate_instance_name DW_ahb]; ::AMBA::refreshHtml}
#@       set ref [sHtml::quote_url cgi:$cmd]
#@       set tmpResult "<UL><LI><A HREF=\"$ref\">Add</A> another AHB bus (DW_ahb) to the subsystem</LI></UL>"
#@       set result [format "%s\n<PRE>\n</PRE>%s" $tmpResult $result]
#@     }
#@ 
#@     return $result
#@   }
#@ 
#@   proc AddComponentToBus {componentName busInstanceName busComponentName interfaceName} {
#@     if {[string equal $componentName "DW_ahb_icm"] &&
#@         ([sizeof_collection [getInstances DW_ahb]] < 2)} {
#@       msg_box -msgType ok             -icon exclamation             -title "DW_ahb_icm unavailable"             "You have chosen to add a DW_ahb_icm to a single AHB system.
#@ This is not supported. You cannot instantiate the DW_ahb_icm 
#@ until you have at least 2 DW_ahb instances in your subsystem."
#@     } elseif {[string equal $componentName "<Exported>"]} {
#@       set name [sAssemblerKb::generate_exported_interface_name                    $busInstanceName $interfaceName]
#@       export_interface -name $name                        -prefix                        -component $busInstanceName                        -interface $interfaceName
#@     } else { 
#@       set instanceName [sAssemblerKb::generate_instance_name $componentName]
#@       instantiate_component $componentName -name $instanceName
#@       if {[string equal $componentName DW_ahb_icm]} {
#@         MakeIcmLayerConnections $instanceName $busInstanceName
#@       } else {
#@         connect_interface -from_component $busInstanceName -from_interface $interfaceName -to_component $instanceName
#@       }
#@     }
#@     refreshHtml
#@   }
#@   
#@   proc getInstances {name} {
#@     set instances {}
#@     set designs [find_item -quiet                            -type design                            *$name                            -filter UnelabName==$name]
#@     set designs [add_to_collection $designs                     [find_item -quiet -type design $name]]
#@     foreach_in_collection design $designs {
#@       set instances [add_to_collection $instances                         [get_attribute $design -attr CellReferences]]
#@     }
#@     
#@     return $instances
#@   }
#@ 
#@   proc SpecifyAddressMaps {} {
#@     set result {}
#@     set busses(DW_ahb) {{Normal Mode Address Map} {Boot Mode Address Map}}
#@     set busses(DW_apb) {{Address Map}}
#@     foreach busComponent {DW_ahb DW_apb} {
#@       foreach_in_collection instance [getInstances $busComponent] {
#@         set name [get_attribute $instance -attr Name]
#@         foreach addrMap $busses($busComponent) {
#@           set ref [sHtml::quote_url "cgi:sAssemblerKb::show_configuration_dialog_page $name {$addrMap}"]
#@           append result "<LI><A HREF=\"$ref\">Define $addrMap for $name ($busComponent)</A></LI>\n"
#@         }
#@       }
#@     }
#@ 
#@     if {[string equal $result {}]} {
#@       set result "<P>There are not currently any components in the subsystem requiring address map definition.</P>"
#@     } else {
#@       set result [format "<UL>%s</UL>" $result]
#@     }
#@ 
#@     return $result
#@   }
#@ 
#@   proc DefineInterrupts {} {
#@     set result {}
#@ 
#@     set instances [getInstances DW_apb_ictl]
#@     if {![sizeof_collection $instances]} {
#@       set instances [getInstances DW_ahb_ictl]
#@     }
#@     if {[sizeof_collection $instances]} {
#@       set result "<P><A HREF=\"cgi:sAssemblerKb::showSpreadsheetConnectionDialog\">Click here</A> to define interrupts.</P>\n"
#@     } else {
#@       set result "<P>There are not currently any interrupt controllers in the subsystem</P>\n"
#@     } 
#@ 
#@     return $result
#@   }
#@ 
#@   proc GetAvailableComponents {compTypes compData} {
#@     
#@     upvar $compData components
#@ 
#@     array set busComponents {}
#@     array set interfaceToBusMap {}
#@ 
#@     # Initialize available components lists.
#@     foreach compType $compTypes {
#@       set components($compType) {}
#@ 
#@       # Store map from interface name to bus component.
#@       set pieces [split $compType "/"]
#@       set busComponent [lindex $pieces 0]
#@       set interfaceName [lindex $pieces 1]
#@       set busComponents($busComponent) 1
#@       set interfaceToBusMap($interfaceName) $busComponent
#@     }
#@ 
#@     # Determine list of all available components.
#@     array set availableComponents [get_installed_component_names]
#@     array set availableInterfaces {}
#@     
#@     foreach componentName [array names availableComponents] {
#@       # Read interface data file.
#@       set interfaceFile [file join [lindex $availableComponents($componentName) 0] .interfaces]
#@       if {[file exists $interfaceFile]} {
#@         unset availableInterfaces 
#@         array set availableInterfaces [exec cat $interfaceFile]
#@ 
#@         # Iterate over interfaces from the current component.
#@         foreach interfaceName [array names availableInterfaces] {
#@ 
#@           if {[info exists interfaceToBusMap($interfaceName)] &&
#@               ![string equal $componentName $interfaceToBusMap($interfaceName)] &&
#@               [info exists components($interfaceToBusMap($interfaceName)/$interfaceName)]} {
#@             # Found a component that attaches to the current bus. Remember the name.
#@             lappend components($interfaceToBusMap($interfaceName)/$interfaceName) $componentName
#@           }
#@         }
#@       }
#@     }
#@ 
#@     # Sort components and add <Exported> entry.
#@     foreach compType $compTypes {
#@       set components($compType) [lsort -dictionary $components($compType)]
#@       lappend components($compType) {<Exported>}
#@     }
#@   }
#@ 
#@ 
#@   proc SubsystemContents {} {
#@     if {[string equal [all_components] ""]} {
#@       set result {Subsystem is currently uninitialized (empty).}
#@     } else {
#@ 
#@       # Gather tree data.
#@       array set data {}
#@       foreach busType {DW_ahb DW_apb DW_ahb_icm} intfList {{AHB_Master AHB_Slave} APB_Slave AHB_Slave} {
#@         foreach_in_collection instance [getInstances $busType] {
#@ 
#@           set instanceName [get_attribute $instance -attr Name]
#@           foreach intfName $intfList {
#@           
#@             regsub {A.B_} $intfName {} intfLabel
#@             append intfLabel "s"
#@ 
#@             set key "$instanceName $intfLabel"
#@             set data($key) {}
#@ 
#@             set provider [find_item $intfName                                -type interfaceInstance                                -filter ComponentName==$instanceName/$intfName]
#@             set consumers [get_attribute $provider -attr Consumers]
#@             set consumers [find_item -quiet $consumers -sort SlotOrder]
#@             foreach_in_collection consumer $consumers {
#@               set slot [get_attribute $consumer -attr SlotOrder]
#@               set componentName [split [get_attribute $consumer                                                       -attr ComponentName] "/"]
#@               if {[llength $componentName] == 1} {
#@                 lappend data($key) "$slot $componentName Exported"
#@               } else {
#@                 set componentName [lindex $componentName 0]
#@                 set refDesignName [ReferenceDesignName $componentName]
#@                 lappend data($key) "$slot $componentName $refDesignName"
#@               }
#@             }
#@ 
#@             # Don't recurse on the ICM unless it's attached to an APB.
#@             if {[string equal $busType DW_ahb_icm] &&
#@                 ![string match {*DW_apb*} $data($key)]} {
#@               unset data($key)
#@             }
#@           }
#@         }
#@       }
#@ 
#@       # Determine type of top-level nodes in status tree.
#@       set topBusType [expr {[sizeof_collection [getInstances DW_ahb]] ? 
#@                                                "DW_ahb" : "DW_apb"}]
#@ 
#@       array set processed {}
#@ 
#@       # Generate HTML for the tree.
#@       set result {<UL>}
#@       foreach_in_collection instance [getInstances $topBusType] {
#@         set refDesignName [ReferenceDesignName "" $instance]
#@         append result {<LI>}
#@         append result "[get_attribute $instance -attr Name] ($refDesignName)"
#@         PrintTreeNodes $instance data processed result
#@         append result {</LI>}
#@       }
#@       append result {</UL>}
#@     }
#@ 
#@     return $result
#@   }
#@ 
#@   proc PrintTreeNodes {instance data processed result} {
#@     upvar $data _data
#@     upvar $result _result
#@     upvar $processed _processed
#@ 
#@     set instanceName [get_attribute $instance -attr Name]
#@     set refDesignName [ReferenceDesignName "" $instance]
#@ 
#@     if {[info exists _processed($instanceName)]} {
#@       return  ;# Already saw this cell
#@     } elseif {[string equal $refDesignName DW_ahb]} {
#@       # Prevent recursion for AHB only.
#@       set _processed($instanceName) 1
#@     }
#@ 
#@     set skipLabel [string equal $refDesignName DW_ahb_icm]
#@     set listStarted $skipLabel
#@ 
#@     foreach key [array names _data] {
#@       if {[string match "$instanceName *" $key]} {
#@         set label [lindex [split $key " "] 1]
#@         if {!$listStarted} {
#@           append _result "<UL>"
#@           set listStarted 1
#@         }
#@         if {!$skipLabel} {
#@           append _result "<LI>$label<UL>\n"
#@         } else {
#@           append _result "<UL>\n"
#@         }
#@         foreach entry $_data($key) {
#@           set slot [lindex $entry 0]
#@           set component [lindex $entry 1]
#@           set design [lindex $entry 2]
#@           set customText [CustomTextForComponent $component $design]
#@ 
#@           append _result "<LI>"
#@           append _result "$slot: $component ($design) $customText\n"
#@           if {![string equal $design Exported]} {
#@             PrintTreeNodes [find_item -type cell $component] _data _processed _result
#@           }
#@           append _result "</LI>"
#@         }
#@         append _result "</UL>"
#@         if {!$skipLabel} { append _result "</LI>" }
#@       }
#@     }
#@     if {$listStarted && !$skipLabel} {
#@       append _result "</UL>"
#@     }
#@   }
#@ 
#@   proc CustomTextForComponent {component design} {
#@   
#@     if {![string equal $design DW_ahb_icm]} {
#@       # No extra text.
#@       set result ""
#@     } else {
#@       # Show component on other side of the ICM.
#@       set intf [find_item -type interfaceInstance                           AHB_Slave                           -filter ComponentName==$component/AHB_Slave]
#@       set slaveIntf [get_attribute $intf -attr Consumers]
#@       if {[sizeof_collection $slaveIntf]} {
#@         set slaveCompName [split               [get_attribute $slaveIntf -attr ComponentName] \ "/"]
#@         if {[llength $slaveCompName] == 1} {
#@           set result                 "<b>&nbsp;&nbsp;-->&nbsp;&nbsp;</b>$slaveCompName (Exported)"
#@         } else {
#@           set slaveCompName [lindex $slaveCompName 0]
#@           set refDesignName [ReferenceDesignName $slaveCompName]
#@           if {[string equal $refDesignName ""]} {
#@             set refDesignName [get_attribute $refDesign -attr Name]
#@           }
#@           set result             "<b>&nbsp;&nbsp;-->&nbsp;&nbsp;</b>$slaveCompName ($refDesignName)"
#@         }
#@       } else {
#@         # There is nothing attached to the ICM yet.
#@         set result ""
#@       }
#@     }
#@ 
#@     return $result
#@   }
#@ 
#@   proc ReferenceDesignName {componentName {component ""}} {
#@     if {[string equal $componentName ""]} {
#@       set cell $component
#@     } else {
#@       set cell [find_item -type cell $componentName]
#@     }
#@     set refDesign [get_attribute $cell -attr ReferenceDesign]
#@     set refDesignName [get_attribute $refDesign -attr UnelabName]
#@     if {[string equal $refDesignName ""]} {
#@       set refDesignName [get_attribute $refDesign -attr Name]
#@     }
#@     return $refDesignName
#@   }
#@ 
#@   proc MakeIcmLayerConnections {icmName ahbName} {
#@     set ahbs [getInstances DW_ahb]
#@     set numberOfAhbs [sizeof_collection $ahbs]
#@ 
#@     # Need to query user about which layers to attach.
#@     set dlg {}
#@     set dlgSuffix AmbaWizardQuery
#@     sUtils::try {
#@ 
#@       # Build the dialog.
#@       set dlg [create_item -type dialog ${dlgSuffix}Dlg]
#@       set_attribute $dlg -attr ShowHelpBtn -value false
#@       set_attribute $dlg -attr ShowCancelBtn -value false
#@       set_attribute $dlg -attr CheckCmd -value {::AMBA::layer_check %item}
#@       set_attribute $dlg -attr Title -value "AHB Interconnect Matrix Definition"
#@       set text {
#@ Please specify which AHBs you would like attached to this DW_ahb_icm.
#@       }
#@       if {$numberOfAhbs > 4} { append text "\nAt most 4 AHBs can be chosen." }
#@       set xPos 7
#@       set yPos 7
#@       set items [sDlg::createLabel $dlgSuffix $text "" $dlg $xPos $yPos]
#@       set yPos [sDlg::calcNewYPos $items]
#@       set boxes {}
#@       set groupItems $items
#@       foreach_in_collection ahb $ahbs {
#@         set name [get_attribute $ahb -attr Name]
#@         set default [string equal $name $ahbName]
#@         set enabled [expr {![string equal $name $ahbName]}]
#@         set text "Attach to $name"
#@         set help {If checked, indicates that the new DW_ahb_icm should
#@ be attached to the indicated AHB bus.}
#@         set items [sDlg::labeledCheckBox ${dlgSuffix}$name                                            $text                                            $help                                            $dlg                                            $default                                            $xPos $yPos]
#@         set_attribute $items -attr Enabled -value $enabled
#@         set yPos [sDlg::calcNewYPos $items]
#@ 
#@         set boxes [add_to_collection $boxes [index_collection $items 0]]
#@         set groupItems [add_to_collection $groupItems $items]
#@       }
#@ 
#@       # Make all check boxes the same size.
#@       set boxes [find_item $boxes -sort -SizeX]
#@       set maxWidth [get_attribute [index_collection $boxes 0] -attr SizeX]
#@       set_attribute $boxes -attr SizeX -value $maxWidth
#@ 
#@       # Put group box around the check boxes.
#@       set items [sDlg::groupDlgItems ${dlgSuffix}Layers                                      "AHB Selection"                                      $groupItems]
#@       set groupSize [get_attribute $items -attr SizeX]
#@       set yPos [sDlg::calcNewYPos $items]
#@ 
#@       # Add label and a drop-down for what's attached to the other side 
#@       # of the ICM.
#@       set text "Choose AHB slave to attach to the DW_ahb_icm."
#@       set items [sDlg::createLabel $dlgSuffix $text "" $dlg $xPos $yPos]
#@       set yPos [sDlg::calcNewYPos $items]
#@       set groupItems $items
#@ 
#@       set help "Choose which AHB slave is to be connected to multiple
#@ AHB busses via the DW_ahb_icm."
#@ 
#@       # Determine available slaves (excluding the ICM).
#@       GetAvailableComponents DW_ahb/AHB_Slave components
#@       set index [lsearch $components(DW_ahb/AHB_Slave) DW_ahb_icm]
#@       if {$index >= 0} {
#@         set components(DW_ahb/AHB_Slave)               [lreplace $components(DW_ahb/AHB_Slave) $index $index]
#@       }
#@ 
#@       set items [sDlg::labeledStringCombo ${dlgSuffix}Slave                                           "AHB Slave"                                           $help                                           $dlg                                           $components(DW_ahb/AHB_Slave)                                           $xPos $yPos]
#@       set combo [find_item $items -type dlgStringsCombo]
#@       set groupItems [add_to_collection $groupItems $items]
#@ 
#@       # Put group box around the drop-down.
#@       set items [sDlg::groupDlgItems ${dlgSuffix}Slave                                      "Slave Selection"                                      $groupItems]
#@       # Force size to be the same as the first group box.
#@       # Grow combo by same amount the group box grows.
#@       set group2Size [get_attribute $items -attr SizeX]
#@       set delta [expr {$groupSize - $group2Size}]
#@       set_attribute $items -attr SizeX -value $groupSize
#@       set comboSize [get_attribute $combo -attr SizeX]
#@       set_attribute $combo -attr SizeX -value [expr {$comboSize + $delta}]
#@ 
#@       sDlg::sizeDlgToContents $dlg
#@         
#@       # Show the dialog
#@       show_dialog $dlg
#@ 
#@       # Gather results.
#@       set dlg [find_item -type dialog ${dlgSuffix}Dlg]
#@       set children [get_attribute $dlg -attr Children]
#@       set boxes [find_item $children -type dlgCheckBox                                      -filter "Value==1"                                      -sort ItemId]
#@ 
#@       # Make the interface connections.
#@       set_configuration_parameter -component $icmName                                     ICM_NUM_LAYERS                                     [sizeof_collection $boxes]
#@       set layer 0
#@       foreach_in_collection box $boxes {
#@         set text [get_attribute $box -attr Text]
#@         set ahbName [lindex $text 2]
#@         connect_interface -from_component $ahbName                             -from_interface AHB_Slave                             -to_component $icmName                             -to_interface Layer[incr layer]
#@       }
#@ 
#@       # Instantiate the AHB slave.
#@       set combo [find_item $children -type dlgStringsCombo]
#@       set slaveName [get_attribute $combo -attr Value]
#@       if {[string equal $slaveName "<Exported>"]} {
#@         set name [sAssemblerKb::generate_exported_interface_name                      $icmName AHB_Slave]
#@         export_interface -name $name                          -prefix                          -component $icmName                          -interface AHB_Slave
#@       } else {
#@         set instanceName [sAssemblerKb::generate_instance_name $slaveName]
#@         instantiate_component $slaveName -name $instanceName
#@ 
#@         # Connect the slave to the ICM.
#@         connect_interface -from_component $icmName                           -from_interface AHB_Slave                           -to_component $instanceName                           -to_interface AHB_Slave
#@       }
#@     } catch-throw {
#@     } finally {
#@       # Clean up.
#@       set dlg [find_item -quiet -type dialog ${dlgSuffix}Dlg]
#@       if {[sizeof_collection $dlg]} {remove_item -quiet $dlg}
#@     }
#@   }
#@ 
#@   proc layer_check {dialog} {
#@     set children [get_attribute $dialog -attr Children]
#@     set boxes [find_item $children -type dlgCheckBox                                      -filter "Value==1"                                      -sort ItemId]
#@     set msg {}
#@     set count [sizeof_collection $boxes]
#@ 
#@     if {$count > 4} {
#@       set msg "deselect at least [expr {$count - 4}] DW_ahb instance"
#@       set suffix [expr {($count - 4) > 1 ? "s" : ""}]
#@       append msg $suffix
#@     } elseif {$count < 2} {
#@       set msg "select at least 1 more DW_ahb instance"
#@     }
#@ 
#@     if {![string equal $msg ""]} {
#@       msg_box -msgType ok             -icon exclamation             -title "Illegal AHB Selection" "You must choose between 2 and 4 DW_ahb instances to attach 
#@ to the DW_ahb_icm (including the instance you initially chose
#@ to add the DW_ahb_icm to).
#@ 
#@ In this case you must ${msg}."
#@       return -code error
#@     }
#@   }
#@   
#@   #
#@   # Generate HTML page containing links to docs for installed cores.
#@   #
#@   proc generate_doc_page {} {
#@     if {[get_workspace_name -quiet] eq ""} {
#@       array set componentData [get_installed_component_names -update]
#@     } else {
#@       array set componentData [get_installed_component_names]
#@     }
#@               
#@     set text {<HTML>
#@ <HEAD>
#@ <TITLE>Documentation For Installed Components</TITLE>
#@ <BODY><H1><CENTER>Documentation For Installed Components</CENTER></H1>}
#@     foreach entry [lsort [array names componentData]] {
#@       set path [lindex $componentData($entry) 0]
#@       set version [lindex $componentData($entry) 1]
#@       
#@       # HTML header for current component
#@       append text "<H2>$entry ($version)</H2>\n"
#@       
#@       set docTypes "rn db an"
#@       set docTitles(rn) "Release Notes"
#@       set docTitles(db) "Data Book"
#@       set docTitles(an) "Application Notes"
#@       set startList 1
#@       
#@       # Locate docs for this component
#@       foreach docType $docTypes {
#@         set document [glob -nocomplain -- $path/doc/*_${docType}.pdf]
#@         if {[llength $document] == 0} {
#@           set document [glob -nocomplain -- $path/docs/*_${docType}.pdf]
#@         }
#@         if {[llength $document] == 1} {
#@           if {$startList} {
#@             append text "<UL>"
#@             set startList 0
#@           }
#@           append text             "<LI><A HREF=\"file:$document\">$docTitles($docType)</A></LI>"
#@         }
#@       }
#@       
#@       if {!$startList} {append text {</UL>}}
#@ 
#@     }
#@     append text {</BODY></HTML>}
#@     
#@     set text
#@   }
#@   
#@   # Show directory browser for specifying DESIGNWARE_HOME.
#@   proc specify_designware_home {} {
#@     
#@     set dw_home {}
#@     while {[string equal $dw_home ""]} {
#@       set dw_home [show_dir_dialog -title "Specify DESIGNWARE_HOME"]
#@       if {[string equal $dw_home ""]} {
#@         set dw_home "-" ;# User cancelled dialog
#@       } elseif {![file exists $dw_home/iip/latest]} {
#@         set response [msg_box -msgType yesno                               -icon question                               -title "Invalid DESIGNWARE_HOME"                               "The specified value for DESIGNWARE_HOME
#@ ($dw_home)
#@ is illegal. It does not contain an iip/latest sub-directory.
#@ Would you like to try again?"]
#@         if {[string equal $response No]} {
#@           set dw_home "-"
#@         }
#@       }
#@     }
#@     if {![string equal $dw_home ""] && ![string equal $dw_home "-"]} {
#@       # Update DESIGNWARE_HOME
#@       setenv DESIGNWARE_HOME $dw_home
#@       set ::component_search_path [file join $dw_home iip latest]
#@       set browser [find_item -type dlgBrowser HelpBrowser]
#@       sUtils::evalInGuiScratchKb {
#@         set_attribute $browser -attr Value -value             $::synopsys_root/doc/dware/coretools.html
#@       }
#@     }
#@   }
#@ 
#@   proc template {templateName} {
#@     set template [getenv DESIGNWARE_HOME]/iip/data/quickstart_templates/latest/$templateName.template
#@     if {![file exists $template]} {
#@       set template [getenv DESIGNWARE_HOME]/iip/QuickStart/$templateName.template
#@     }
#@     create_workspace -template $template
#@   }
#@ 
#@   proc create_amba_workspace {installdir componentName {script {}}} {
#@ 
#@     set configDir [file join $installdir auxiliary configs]
#@     set configFile [file join $configDir configurations.html]
#@     if {$script eq "" && [file exists $configFile]} {
#@       set ::dwh_component_installation $installdir
#@       set ::dwh_component_name $componentName
#@       set browser [find_item -type dlgBrowser HelpBrowser -search system]
#@       sUtils::evalInGuiScratchKb {
#@         set_attribute $browser -attr Value -value $configFile
#@       }
#@     } else {
#@       set name $componentName
#@       if {![regsub {^DW_apb_} $name {i_} name] &&
#@           ![regsub {^DW_ahb_} $name {i_} name] &&
#@           ![regsub {^DW_amba_} $name {i_} name] &&
#@           ![regsub {^DW_} $name {i_} name]} {
#@         set name "i_$name"
#@       }
#@       if {[file exists $name]} {
#@         set index 0
#@         set tmpName $name
#@         while {[file exists $tmpName] && ($index < 10000)} {
#@           set tmpName ${name}_[incr index]
#@         }
#@         set name $tmpName
#@       }
#@    
#@       create_workspace -gui -name $name -install $installdir 
#@       if {$script ne ""} {
#@         if {![file exists $script]} {
#@           set script [file join $configDir $script]
#@         }
#@         if {[file exists $script]} {
#@           echo "Sourcing configuration script: $script"
#@           catch {source $script}
#@         }
#@       }
#@     }
#@   }
#@ }
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/doc/dware/AMBA/amba.tcl

#@ # -- Starting source /edatools/synopsys/coretools/K-2015.06-SP5/doc/dware/AMBA/amba.tcl

#@ namespace eval AMBA {
#@ 
#@   proc Launch {} {
#@ 
#@     if {[string equal [get_workspace_name -quiet] ""]} {
#@       set result [msg_box -icon question                           -msgType yesno                           "The AMBA Subsystem Assembly Wizard cannot be started until you have created a workspace.
#@ Would you like to do so now?"]
#@       if {[string equal $result "Yes"]} {
#@         create_workspace -gui
#@       }
#@     }
#@ 
#@     if {![verifyComponents]} {
#@       return
#@     }
#@ 
#@     if {![string equal [get_workspace_name -quiet] ""]} {
#@       show_url $::synopsys_root/doc/dware/AMBA/amba.html "" "AMBA Subsystem Assembly Wizard"
#@       refreshHtml
#@       set act [find_item -type activity AddSubsystemComponents -should 1]
#@       sAct::DlgActivateBoundActivity $act
#@     }
#@   }
#@ 
#@   proc InitializeSubsystem {} {
#@     if {[string equal [all_components] ""]} {
#@       set result {
#@ <P>Choose the initial subsystem below which is closest to your needs. This
#@ is just a starting point, and can be added to, or subtracted from as
#@ desired.
#@ <P>
#@ <UL>
#@       }
#@       set systems {
#@         {{AHB} {i_ahb DW_ahb}} 
#@         {{AHB + APB} {i_ahb DW_ahb i_apb DW_apb}}
#@         {{AHB + APB + APB} {i_ahb DW_ahb i_apb1 DW_apb i_apb2 DW_apb}}
#@       }
#@       foreach system $systems {
#@         set label [lindex $system 0]
#@         set init_args [lindex $system 1]
#@         append result "
#@ <LI>
#@ <A HREF=\"cgi:AMBA::createInitialSubsystem%20\{$init_args\}\">$label</A>
#@ </LI>
#@ "
#@       }
#@       append result "</UL>"
#@     } else {
#@       set result {
#@ <P>You already have a subsystem in progress. <A HREF="cgi:AMBA::resetSubsystem%3B%20AMBA::refreshHtml">Click
#@ here</A> to delete your existing subsystem and start over. 
#@       }
#@     }
#@     return $result
#@   }
#@ 
#@   proc createInitialSubsystem {contents} {
#@ 
#@     sUtils::try {
#@       # Build the subsystem with the given contents.
#@       foreach {instance component} $contents {
#@         instantiate_component -name $instance $component
#@       }
#@     } catch-throw {
#@       resetSubsystem
#@     }
#@ 
#@     # Refresh the page.
#@     refreshHtml
#@   }
#@ 
#@   proc resetSubsystem {} {
#@     set exported [find_item -quiet -type interfaceInstance -hidden -search <current>]
#@     if {[sizeof_collection $exported]} {remove_item $exported}
#@     foreach compName [all_components] {
#@       remove_component $compName
#@     }
#@   }
#@ 
#@   proc refreshHtml {} {
#@     set browsers [find_item -quiet -type DlgBrowser -filter Value=~.*/amba.html]
#@     if {[sizeof_collection $browsers]} {
#@       set page [get_attribute [index_collection $browsers 0] -attr Value]
#@       set_attribute $browsers -attr Value -value $page
#@     }
#@   }
#@ 
#@   proc verifyComponents {} {
#@     array set components [get_installed_component_names]
#@     if {![info exists components(DW_ahb)] ||
#@         ![info exists components(DW_apb)]} {
#@       if {[info exists ::env(DESIGNWARE_HOME)]} {
#@         # Try to fix the component search path.
#@         set dw_home_latest [file join [getenv DESIGNWARE_HOME] iip latest]
#@         if {[file exists $dw_home_latest]} {
#@           set_activity_parameter AddSubsystemComponents SearchPath $dw_home_latest
#@           unset components
#@           array set components [get_installed_component_names]
#@         }
#@       }
#@     }
#@ 
#@     if {![info exists components(DW_ahb)] ||
#@         ![info exists components(DW_apb)]} {
#@       if {[info exists ::env(DESIGNWARE_HOME)]} {
#@         msg_box -icon exclamation                 -msgType okcancel "The DesignWare AMBA components cannot be found using the current setting of the
#@ DESIGNWARE_HOME variable. This probably means the variable is set to point at the
#@ wrong directory. When set correctly, the specified directory will contain the
#@ sub-directory 'iip'.
#@ Current value: [getenv DESIGNWARE_HOME]"
#@       } else {
#@         msg_box -icon exclamation                 -msgType okcancel "The DesignWare AMBA components cannot be found using the existing component search path.
#@ Please set the environment variable DESIGNWARE_HOME to point at the DesignWare
#@ installation area and then launch the wizard again. This can be done within
#@ coreAssembler using the builtin 'setenv' command."
#@       }
#@ 
#@       return 0
#@     }
#@     
#@     return 1
#@   }
#@ 
#@   proc AddComponents {} {
#@     set result {}
#@ 
#@     set orderedIndex {DW_ahb/AHB_Master DW_ahb/AHB_Slave DW_apb/APB_Slave}
#@     set labels(DW_ahb/AHB_Master) {AHB Master}
#@     set labels(DW_ahb/AHB_Slave)  {AHB Slave}
#@     set labels(DW_apb/APB_Slave)  {APB Slave}
#@ 
#@     # Determine available components.
#@     GetAvailableComponents $orderedIndex components
#@ 
#@     foreach entry $orderedIndex {
#@       set data [split $entry "/"]
#@       set bus [lindex $data 0]
#@       set interface [lindex $data 1]
#@       set busInstances [getInstances $bus]
#@       if {[sizeof_collection $busInstances]} {
#@         append result "<UL>\n"
#@         foreach_in_collection busInstance $busInstances {
#@           set instanceName [get_attribute $busInstance -attr Name]
#@           set columns 3
#@           set index 0
#@           append result "<li>Add new $labels($entry) to <b>$instanceName</b>\n"
#@           append result "<TABLE WIDTH=\"100%\">\n"
#@           foreach component $components($entry) {
#@             incr index
#@             if {[expr {$index % $columns}] == 1} {
#@               if {$index > 1} {
#@                 append result "</TR>\n"
#@               }
#@               append result "<TR>\n"
#@             }
#@             regsub {^<} $component {\&lt } htmlComponent
#@             regsub {>$} $htmlComponent {\&gt } htmlComponent
#@             set ref [sHtml::quote_url                "cgi:AMBA::AddComponentToBus $component $instanceName $bus $interface"]
#@             append result "<TD><UL><LI><A HREF=\"$ref\">$htmlComponent</A></LI></UL></TD>\n"
#@           }
#@           append result "</TR></TABLE>\n"
#@         }
#@         append result "</UL>\n"
#@       }
#@     }
#@ 
#@     if {[string equal $result {}]} {
#@       set result {<P>Not available until initial subsystem has been defined in the Initialize Subsystem section\n.}
#@     } else {
#@       # Prepend link to add new AHB to the subsystem.
#@       set cmd {instantiate_component DW_ahb -name [sAssemblerKb::generate_instance_name DW_ahb]; ::AMBA::refreshHtml}
#@       set ref [sHtml::quote_url cgi:$cmd]
#@       set tmpResult "<UL><LI><A HREF=\"$ref\">Add</A> another AHB bus (DW_ahb) to the subsystem</LI></UL>"
#@       set result [format "%s\n<PRE>\n</PRE>%s" $tmpResult $result]
#@     }
#@ 
#@     return $result
#@   }
#@ 
#@   proc AddComponentToBus {componentName busInstanceName busComponentName interfaceName} {
#@     if {[string equal $componentName "DW_ahb_icm"] &&
#@         ([sizeof_collection [getInstances DW_ahb]] < 2)} {
#@       msg_box -msgType ok             -icon exclamation             -title "DW_ahb_icm unavailable"             "You have chosen to add a DW_ahb_icm to a single AHB system.
#@ This is not supported. You cannot instantiate the DW_ahb_icm 
#@ until you have at least 2 DW_ahb instances in your subsystem."
#@     } elseif {[string equal $componentName "<Exported>"]} {
#@       set name [sAssemblerKb::generate_exported_interface_name                    $busInstanceName $interfaceName]
#@       export_interface -name $name                        -prefix                        -component $busInstanceName                        -interface $interfaceName
#@     } else { 
#@       set instanceName [sAssemblerKb::generate_instance_name $componentName]
#@       instantiate_component $componentName -name $instanceName
#@       if {[string equal $componentName DW_ahb_icm]} {
#@         MakeIcmLayerConnections $instanceName $busInstanceName
#@       } else {
#@         connect_interface -from_component $busInstanceName -from_interface $interfaceName -to_component $instanceName
#@       }
#@     }
#@     refreshHtml
#@   }
#@   
#@   proc getInstances {name} {
#@     set instances {}
#@     set designs [find_item -quiet                            -type design                            *$name                            -filter UnelabName==$name]
#@     set designs [add_to_collection $designs                     [find_item -quiet -type design $name]]
#@     foreach_in_collection design $designs {
#@       set instances [add_to_collection $instances                         [get_attribute $design -attr CellReferences]]
#@     }
#@     
#@     return $instances
#@   }
#@ 
#@   proc SpecifyAddressMaps {} {
#@     set result {}
#@     set busses(DW_ahb) {{Normal Mode Address Map} {Boot Mode Address Map}}
#@     set busses(DW_apb) {{Address Map}}
#@     foreach busComponent {DW_ahb DW_apb} {
#@       foreach_in_collection instance [getInstances $busComponent] {
#@         set name [get_attribute $instance -attr Name]
#@         foreach addrMap $busses($busComponent) {
#@           set ref [sHtml::quote_url "cgi:sAssemblerKb::show_configuration_dialog_page $name {$addrMap}"]
#@           append result "<LI><A HREF=\"$ref\">Define $addrMap for $name ($busComponent)</A></LI>\n"
#@         }
#@       }
#@     }
#@ 
#@     if {[string equal $result {}]} {
#@       set result "<P>There are not currently any components in the subsystem requiring address map definition.</P>"
#@     } else {
#@       set result [format "<UL>%s</UL>" $result]
#@     }
#@ 
#@     return $result
#@   }
#@ 
#@   proc DefineInterrupts {} {
#@     set result {}
#@ 
#@     set instances [getInstances DW_apb_ictl]
#@     if {![sizeof_collection $instances]} {
#@       set instances [getInstances DW_ahb_ictl]
#@     }
#@     if {[sizeof_collection $instances]} {
#@       set result "<P><A HREF=\"cgi:sAssemblerKb::showSpreadsheetConnectionDialog\">Click here</A> to define interrupts.</P>\n"
#@     } else {
#@       set result "<P>There are not currently any interrupt controllers in the subsystem</P>\n"
#@     } 
#@ 
#@     return $result
#@   }
#@ 
#@   proc GetAvailableComponents {compTypes compData} {
#@     
#@     upvar $compData components
#@ 
#@     array set busComponents {}
#@     array set interfaceToBusMap {}
#@ 
#@     # Initialize available components lists.
#@     foreach compType $compTypes {
#@       set components($compType) {}
#@ 
#@       # Store map from interface name to bus component.
#@       set pieces [split $compType "/"]
#@       set busComponent [lindex $pieces 0]
#@       set interfaceName [lindex $pieces 1]
#@       set busComponents($busComponent) 1
#@       set interfaceToBusMap($interfaceName) $busComponent
#@     }
#@ 
#@     # Determine list of all available components.
#@     array set availableComponents [get_installed_component_names]
#@     array set availableInterfaces {}
#@     
#@     foreach componentName [array names availableComponents] {
#@       # Read interface data file.
#@       set interfaceFile [file join [lindex $availableComponents($componentName) 0] .interfaces]
#@       if {[file exists $interfaceFile]} {
#@         unset availableInterfaces 
#@         array set availableInterfaces [exec cat $interfaceFile]
#@ 
#@         # Iterate over interfaces from the current component.
#@         foreach interfaceName [array names availableInterfaces] {
#@ 
#@           if {[info exists interfaceToBusMap($interfaceName)] &&
#@               ![string equal $componentName $interfaceToBusMap($interfaceName)] &&
#@               [info exists components($interfaceToBusMap($interfaceName)/$interfaceName)]} {
#@             # Found a component that attaches to the current bus. Remember the name.
#@             lappend components($interfaceToBusMap($interfaceName)/$interfaceName) $componentName
#@           }
#@         }
#@       }
#@     }
#@ 
#@     # Sort components and add <Exported> entry.
#@     foreach compType $compTypes {
#@       set components($compType) [lsort -dictionary $components($compType)]
#@       lappend components($compType) {<Exported>}
#@     }
#@   }
#@ 
#@ 
#@   proc SubsystemContents {} {
#@     if {[string equal [all_components] ""]} {
#@       set result {Subsystem is currently uninitialized (empty).}
#@     } else {
#@ 
#@       # Gather tree data.
#@       array set data {}
#@       foreach busType {DW_ahb DW_apb DW_ahb_icm} intfList {{AHB_Master AHB_Slave} APB_Slave AHB_Slave} {
#@         foreach_in_collection instance [getInstances $busType] {
#@ 
#@           set instanceName [get_attribute $instance -attr Name]
#@           foreach intfName $intfList {
#@           
#@             regsub {A.B_} $intfName {} intfLabel
#@             append intfLabel "s"
#@ 
#@             set key "$instanceName $intfLabel"
#@             set data($key) {}
#@ 
#@             set provider [find_item $intfName                                -type interfaceInstance                                -filter ComponentName==$instanceName/$intfName]
#@             set consumers [get_attribute $provider -attr Consumers]
#@             set consumers [find_item -quiet $consumers -sort SlotOrder]
#@             foreach_in_collection consumer $consumers {
#@               set slot [get_attribute $consumer -attr SlotOrder]
#@               set componentName [split [get_attribute $consumer                                                       -attr ComponentName] "/"]
#@               if {[llength $componentName] == 1} {
#@                 lappend data($key) "$slot $componentName Exported"
#@               } else {
#@                 set componentName [lindex $componentName 0]
#@                 set refDesignName [ReferenceDesignName $componentName]
#@                 lappend data($key) "$slot $componentName $refDesignName"
#@               }
#@             }
#@ 
#@             # Don't recurse on the ICM unless it's attached to an APB.
#@             if {[string equal $busType DW_ahb_icm] &&
#@                 ![string match {*DW_apb*} $data($key)]} {
#@               unset data($key)
#@             }
#@           }
#@         }
#@       }
#@ 
#@       # Determine type of top-level nodes in status tree.
#@       set topBusType [expr {[sizeof_collection [getInstances DW_ahb]] ? 
#@                                                "DW_ahb" : "DW_apb"}]
#@ 
#@       array set processed {}
#@ 
#@       # Generate HTML for the tree.
#@       set result {<UL>}
#@       foreach_in_collection instance [getInstances $topBusType] {
#@         set refDesignName [ReferenceDesignName "" $instance]
#@         append result {<LI>}
#@         append result "[get_attribute $instance -attr Name] ($refDesignName)"
#@         PrintTreeNodes $instance data processed result
#@         append result {</LI>}
#@       }
#@       append result {</UL>}
#@     }
#@ 
#@     return $result
#@   }
#@ 
#@   proc PrintTreeNodes {instance data processed result} {
#@     upvar $data _data
#@     upvar $result _result
#@     upvar $processed _processed
#@ 
#@     set instanceName [get_attribute $instance -attr Name]
#@     set refDesignName [ReferenceDesignName "" $instance]
#@ 
#@     if {[info exists _processed($instanceName)]} {
#@       return  ;# Already saw this cell
#@     } elseif {[string equal $refDesignName DW_ahb]} {
#@       # Prevent recursion for AHB only.
#@       set _processed($instanceName) 1
#@     }
#@ 
#@     set skipLabel [string equal $refDesignName DW_ahb_icm]
#@     set listStarted $skipLabel
#@ 
#@     foreach key [array names _data] {
#@       if {[string match "$instanceName *" $key]} {
#@         set label [lindex [split $key " "] 1]
#@         if {!$listStarted} {
#@           append _result "<UL>"
#@           set listStarted 1
#@         }
#@         if {!$skipLabel} {
#@           append _result "<LI>$label<UL>\n"
#@         } else {
#@           append _result "<UL>\n"
#@         }
#@         foreach entry $_data($key) {
#@           set slot [lindex $entry 0]
#@           set component [lindex $entry 1]
#@           set design [lindex $entry 2]
#@           set customText [CustomTextForComponent $component $design]
#@ 
#@           append _result "<LI>"
#@           append _result "$slot: $component ($design) $customText\n"
#@           if {![string equal $design Exported]} {
#@             PrintTreeNodes [find_item -type cell $component] _data _processed _result
#@           }
#@           append _result "</LI>"
#@         }
#@         append _result "</UL>"
#@         if {!$skipLabel} { append _result "</LI>" }
#@       }
#@     }
#@     if {$listStarted && !$skipLabel} {
#@       append _result "</UL>"
#@     }
#@   }
#@ 
#@   proc CustomTextForComponent {component design} {
#@   
#@     if {![string equal $design DW_ahb_icm]} {
#@       # No extra text.
#@       set result ""
#@     } else {
#@       # Show component on other side of the ICM.
#@       set intf [find_item -type interfaceInstance                           AHB_Slave                           -filter ComponentName==$component/AHB_Slave]
#@       set slaveIntf [get_attribute $intf -attr Consumers]
#@       if {[sizeof_collection $slaveIntf]} {
#@         set slaveCompName [split               [get_attribute $slaveIntf -attr ComponentName] \ "/"]
#@         if {[llength $slaveCompName] == 1} {
#@           set result                 "<b>&nbsp;&nbsp;-->&nbsp;&nbsp;</b>$slaveCompName (Exported)"
#@         } else {
#@           set slaveCompName [lindex $slaveCompName 0]
#@           set refDesignName [ReferenceDesignName $slaveCompName]
#@           if {[string equal $refDesignName ""]} {
#@             set refDesignName [get_attribute $refDesign -attr Name]
#@           }
#@           set result             "<b>&nbsp;&nbsp;-->&nbsp;&nbsp;</b>$slaveCompName ($refDesignName)"
#@         }
#@       } else {
#@         # There is nothing attached to the ICM yet.
#@         set result ""
#@       }
#@     }
#@ 
#@     return $result
#@   }
#@ 
#@   proc ReferenceDesignName {componentName {component ""}} {
#@     if {[string equal $componentName ""]} {
#@       set cell $component
#@     } else {
#@       set cell [find_item -type cell $componentName]
#@     }
#@     set refDesign [get_attribute $cell -attr ReferenceDesign]
#@     set refDesignName [get_attribute $refDesign -attr UnelabName]
#@     if {[string equal $refDesignName ""]} {
#@       set refDesignName [get_attribute $refDesign -attr Name]
#@     }
#@     return $refDesignName
#@   }
#@ 
#@   proc MakeIcmLayerConnections {icmName ahbName} {
#@     set ahbs [getInstances DW_ahb]
#@     set numberOfAhbs [sizeof_collection $ahbs]
#@ 
#@     # Need to query user about which layers to attach.
#@     set dlg {}
#@     set dlgSuffix AmbaWizardQuery
#@     sUtils::try {
#@ 
#@       # Build the dialog.
#@       set dlg [create_item -type dialog ${dlgSuffix}Dlg]
#@       set_attribute $dlg -attr ShowHelpBtn -value false
#@       set_attribute $dlg -attr ShowCancelBtn -value false
#@       set_attribute $dlg -attr CheckCmd -value {::AMBA::layer_check %item}
#@       set_attribute $dlg -attr Title -value "AHB Interconnect Matrix Definition"
#@       set text {
#@ Please specify which AHBs you would like attached to this DW_ahb_icm.
#@       }
#@       if {$numberOfAhbs > 4} { append text "\nAt most 4 AHBs can be chosen." }
#@       set xPos 7
#@       set yPos 7
#@       set items [sDlg::createLabel $dlgSuffix $text "" $dlg $xPos $yPos]
#@       set yPos [sDlg::calcNewYPos $items]
#@       set boxes {}
#@       set groupItems $items
#@       foreach_in_collection ahb $ahbs {
#@         set name [get_attribute $ahb -attr Name]
#@         set default [string equal $name $ahbName]
#@         set enabled [expr {![string equal $name $ahbName]}]
#@         set text "Attach to $name"
#@         set help {If checked, indicates that the new DW_ahb_icm should
#@ be attached to the indicated AHB bus.}
#@         set items [sDlg::labeledCheckBox ${dlgSuffix}$name                                            $text                                            $help                                            $dlg                                            $default                                            $xPos $yPos]
#@         set_attribute $items -attr Enabled -value $enabled
#@         set yPos [sDlg::calcNewYPos $items]
#@ 
#@         set boxes [add_to_collection $boxes [index_collection $items 0]]
#@         set groupItems [add_to_collection $groupItems $items]
#@       }
#@ 
#@       # Make all check boxes the same size.
#@       set boxes [find_item $boxes -sort -SizeX]
#@       set maxWidth [get_attribute [index_collection $boxes 0] -attr SizeX]
#@       set_attribute $boxes -attr SizeX -value $maxWidth
#@ 
#@       # Put group box around the check boxes.
#@       set items [sDlg::groupDlgItems ${dlgSuffix}Layers                                      "AHB Selection"                                      $groupItems]
#@       set groupSize [get_attribute $items -attr SizeX]
#@       set yPos [sDlg::calcNewYPos $items]
#@ 
#@       # Add label and a drop-down for what's attached to the other side 
#@       # of the ICM.
#@       set text "Choose AHB slave to attach to the DW_ahb_icm."
#@       set items [sDlg::createLabel $dlgSuffix $text "" $dlg $xPos $yPos]
#@       set yPos [sDlg::calcNewYPos $items]
#@       set groupItems $items
#@ 
#@       set help "Choose which AHB slave is to be connected to multiple
#@ AHB busses via the DW_ahb_icm."
#@ 
#@       # Determine available slaves (excluding the ICM).
#@       GetAvailableComponents DW_ahb/AHB_Slave components
#@       set index [lsearch $components(DW_ahb/AHB_Slave) DW_ahb_icm]
#@       if {$index >= 0} {
#@         set components(DW_ahb/AHB_Slave)               [lreplace $components(DW_ahb/AHB_Slave) $index $index]
#@       }
#@ 
#@       set items [sDlg::labeledStringCombo ${dlgSuffix}Slave                                           "AHB Slave"                                           $help                                           $dlg                                           $components(DW_ahb/AHB_Slave)                                           $xPos $yPos]
#@       set combo [find_item $items -type dlgStringsCombo]
#@       set groupItems [add_to_collection $groupItems $items]
#@ 
#@       # Put group box around the drop-down.
#@       set items [sDlg::groupDlgItems ${dlgSuffix}Slave                                      "Slave Selection"                                      $groupItems]
#@       # Force size to be the same as the first group box.
#@       # Grow combo by same amount the group box grows.
#@       set group2Size [get_attribute $items -attr SizeX]
#@       set delta [expr {$groupSize - $group2Size}]
#@       set_attribute $items -attr SizeX -value $groupSize
#@       set comboSize [get_attribute $combo -attr SizeX]
#@       set_attribute $combo -attr SizeX -value [expr {$comboSize + $delta}]
#@ 
#@       sDlg::sizeDlgToContents $dlg
#@         
#@       # Show the dialog
#@       show_dialog $dlg
#@ 
#@       # Gather results.
#@       set dlg [find_item -type dialog ${dlgSuffix}Dlg]
#@       set children [get_attribute $dlg -attr Children]
#@       set boxes [find_item $children -type dlgCheckBox                                      -filter "Value==1"                                      -sort ItemId]
#@ 
#@       # Make the interface connections.
#@       set_configuration_parameter -component $icmName                                     ICM_NUM_LAYERS                                     [sizeof_collection $boxes]
#@       set layer 0
#@       foreach_in_collection box $boxes {
#@         set text [get_attribute $box -attr Text]
#@         set ahbName [lindex $text 2]
#@         connect_interface -from_component $ahbName                             -from_interface AHB_Slave                             -to_component $icmName                             -to_interface Layer[incr layer]
#@       }
#@ 
#@       # Instantiate the AHB slave.
#@       set combo [find_item $children -type dlgStringsCombo]
#@       set slaveName [get_attribute $combo -attr Value]
#@       if {[string equal $slaveName "<Exported>"]} {
#@         set name [sAssemblerKb::generate_exported_interface_name                      $icmName AHB_Slave]
#@         export_interface -name $name                          -prefix                          -component $icmName                          -interface AHB_Slave
#@       } else {
#@         set instanceName [sAssemblerKb::generate_instance_name $slaveName]
#@         instantiate_component $slaveName -name $instanceName
#@ 
#@         # Connect the slave to the ICM.
#@         connect_interface -from_component $icmName                           -from_interface AHB_Slave                           -to_component $instanceName                           -to_interface AHB_Slave
#@       }
#@     } catch-throw {
#@     } finally {
#@       # Clean up.
#@       set dlg [find_item -quiet -type dialog ${dlgSuffix}Dlg]
#@       if {[sizeof_collection $dlg]} {remove_item -quiet $dlg}
#@     }
#@   }
#@ 
#@   proc layer_check {dialog} {
#@     set children [get_attribute $dialog -attr Children]
#@     set boxes [find_item $children -type dlgCheckBox                                      -filter "Value==1"                                      -sort ItemId]
#@     set msg {}
#@     set count [sizeof_collection $boxes]
#@ 
#@     if {$count > 4} {
#@       set msg "deselect at least [expr {$count - 4}] DW_ahb instance"
#@       set suffix [expr {($count - 4) > 1 ? "s" : ""}]
#@       append msg $suffix
#@     } elseif {$count < 2} {
#@       set msg "select at least 1 more DW_ahb instance"
#@     }
#@ 
#@     if {![string equal $msg ""]} {
#@       msg_box -msgType ok             -icon exclamation             -title "Illegal AHB Selection" "You must choose between 2 and 4 DW_ahb instances to attach 
#@ to the DW_ahb_icm (including the instance you initially chose
#@ to add the DW_ahb_icm to).
#@ 
#@ In this case you must ${msg}."
#@       return -code error
#@     }
#@   }
#@   
#@   #
#@   # Generate HTML page containing links to docs for installed cores.
#@   #
#@   proc generate_doc_page {} {
#@     if {[get_workspace_name -quiet] eq ""} {
#@       array set componentData [get_installed_component_names -update]
#@     } else {
#@       array set componentData [get_installed_component_names]
#@     }
#@               
#@     set text {<HTML>
#@ <HEAD>
#@ <TITLE>Documentation For Installed Components</TITLE>
#@ <BODY><H1><CENTER>Documentation For Installed Components</CENTER></H1>}
#@     foreach entry [lsort [array names componentData]] {
#@       set path [lindex $componentData($entry) 0]
#@       set version [lindex $componentData($entry) 1]
#@       
#@       # HTML header for current component
#@       append text "<H2>$entry ($version)</H2>\n"
#@       
#@       set docTypes "rn db an"
#@       set docTitles(rn) "Release Notes"
#@       set docTitles(db) "Data Book"
#@       set docTitles(an) "Application Notes"
#@       set startList 1
#@       
#@       # Locate docs for this component
#@       foreach docType $docTypes {
#@         set document [glob -nocomplain -- $path/doc/*_${docType}.pdf]
#@         if {[llength $document] == 0} {
#@           set document [glob -nocomplain -- $path/docs/*_${docType}.pdf]
#@         }
#@         if {[llength $document] == 1} {
#@           if {$startList} {
#@             append text "<UL>"
#@             set startList 0
#@           }
#@           append text             "<LI><A HREF=\"file:$document\">$docTitles($docType)</A></LI>"
#@         }
#@       }
#@       
#@       if {!$startList} {append text {</UL>}}
#@ 
#@     }
#@     append text {</BODY></HTML>}
#@     
#@     set text
#@   }
#@   
#@   # Show directory browser for specifying DESIGNWARE_HOME.
#@   proc specify_designware_home {} {
#@     
#@     set dw_home {}
#@     while {[string equal $dw_home ""]} {
#@       set dw_home [show_dir_dialog -title "Specify DESIGNWARE_HOME"]
#@       if {[string equal $dw_home ""]} {
#@         set dw_home "-" ;# User cancelled dialog
#@       } elseif {![file exists $dw_home/iip/latest]} {
#@         set response [msg_box -msgType yesno                               -icon question                               -title "Invalid DESIGNWARE_HOME"                               "The specified value for DESIGNWARE_HOME
#@ ($dw_home)
#@ is illegal. It does not contain an iip/latest sub-directory.
#@ Would you like to try again?"]
#@         if {[string equal $response No]} {
#@           set dw_home "-"
#@         }
#@       }
#@     }
#@     if {![string equal $dw_home ""] && ![string equal $dw_home "-"]} {
#@       # Update DESIGNWARE_HOME
#@       setenv DESIGNWARE_HOME $dw_home
#@       set ::component_search_path [file join $dw_home iip latest]
#@       set browser [find_item -type dlgBrowser HelpBrowser]
#@       sUtils::evalInGuiScratchKb {
#@         set_attribute $browser -attr Value -value             $::synopsys_root/doc/dware/coretools.html
#@       }
#@     }
#@   }
#@ 
#@   proc template {templateName} {
#@     set template [getenv DESIGNWARE_HOME]/iip/data/quickstart_templates/latest/$templateName.template
#@     if {![file exists $template]} {
#@       set template [getenv DESIGNWARE_HOME]/iip/QuickStart/$templateName.template
#@     }
#@     create_workspace -template $template
#@   }
#@ 
#@   proc create_amba_workspace {installdir componentName {script {}}} {
#@ 
#@     set configDir [file join $installdir auxiliary configs]
#@     set configFile [file join $configDir configurations.html]
#@     if {$script eq "" && [file exists $configFile]} {
#@       set ::dwh_component_installation $installdir
#@       set ::dwh_component_name $componentName
#@       set browser [find_item -type dlgBrowser HelpBrowser -search system]
#@       sUtils::evalInGuiScratchKb {
#@         set_attribute $browser -attr Value -value $configFile
#@       }
#@     } else {
#@       set name $componentName
#@       if {![regsub {^DW_apb_} $name {i_} name] &&
#@           ![regsub {^DW_ahb_} $name {i_} name] &&
#@           ![regsub {^DW_amba_} $name {i_} name] &&
#@           ![regsub {^DW_} $name {i_} name]} {
#@         set name "i_$name"
#@       }
#@       if {[file exists $name]} {
#@         set index 0
#@         set tmpName $name
#@         while {[file exists $tmpName] && ($index < 10000)} {
#@           set tmpName ${name}_[incr index]
#@         }
#@         set name $tmpName
#@       }
#@    
#@       create_workspace -gui -name $name -install $installdir 
#@       if {$script ne ""} {
#@         if {![file exists $script]} {
#@           set script [file join $configDir $script]
#@         }
#@         if {[file exists $script]} {
#@           echo "Sourcing configuration script: $script"
#@           catch {source $script}
#@         }
#@       }
#@     }
#@   }
#@ }
#@ # -- End source /edatools/synopsys/coretools/K-2015.06-SP5/doc/dware/AMBA/amba.tcl

set_attribute -attr [find_item -exacttype stringAttrDefn StringValue -limit  -search BuiltIn] -value {This workspace has a ".lock" file and may be already in use by another
user. A lock file is created when the workspace is opened and removed when
it is properly closed.

It is possible to have a lock file that does not get removed if the
application did not exit properly. If you believe the workspace is not
in use then click on the remove button to remove the lock file and continue
opening the workspace.

The workspace is in use by:
   User : mzm
   Host : wusystem-eda
   PID  : 20392

} [find_item -exacttype dlgLabel LockFileLbl -search GUIScratch]
set_attribute -attr [find_item -exacttype stringAttrDefn StringValue -limit  -search BuiltIn] -value {Remove Lock File and Continue} [find_item -exacttype dlgButton LockFileBtn -search GUIScratch]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {Remove Lock File and Continue} [find_item -exacttype dlgButton LockFileBtn -search GUIScratch]
send_event -activate [find_item -exacttype dlgButton LockFileBtn -search GUIScratch]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_PipelingingOptions_MultiCycleArbitrationSelectNumberofArbitrationCyclesforSlavePortArbitersDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_PipelingingOptions_MultiCycleArbitrationSelectNumberofArbitrationCyclesforSlavePortArbitersDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_PipelingingOptions_MultiCycleArbitrationSelectNumberofArbitrationCyclesforMasterPortArbitersDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_PipelingingOptions_MultiCycleArbitrationSelectNumberofArbitrationCyclesforMasterPortArbitersDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_BicmdConfig_hasMasterNumbersMasterNumbersDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_BicmdConfig_hasMasterNumbersMasterNumbersDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_BicmdConfig_ICSlavePortsSlaveNumbersDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_BicmdConfig_ICSlavePortsSlaveNumbersDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_BicmdConfig_hasICMMasterICMMasterDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_BicmdConfig_hasICMMasterICMMasterDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_Arbitration_ArbTypeSlavePortArbitersDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_Arbitration_ArbTypeSlavePortArbitersDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_Arbitration_ArbTypeMasterPortArbitersDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_Arbitration_ArbTypeMasterPortArbitersDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_Arbitration_ArbTypeSharedLayerArbitersDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_Arbitration_ArbTypeSharedLayerArbitersDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_Arbitration_PriorityMasterPriorityDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_Arbitration_PriorityMasterPriorityDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_Arbitration_PrioritySlavePriorityDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_Arbitration_PrioritySlavePriorityDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_HasSidebandSideBandConfigDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_HasSidebandSideBandConfigDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_SlaveVisibilitySlaveVisibilityNormalDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_SlaveVisibilitySlaveVisibilityNormalDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_SlaveVisibilitySlaveVisibilityBootDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_SlaveVisibilitySlaveVisibilityBootDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_BusArchitecture_ArchTypesWriteAddressChannelArchitectureDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_BusArchitecture_ArchTypesWriteAddressChannelArchitectureDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_BusArchitecture_ArchTypesWriteDataChannelArchitectureDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_BusArchitecture_ArchTypesWriteDataChannelArchitectureDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_BusArchitecture_ArchTypesBurstResponseChannelArchitectureDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_BusArchitecture_ArchTypesBurstResponseChannelArchitectureDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_BusArchitecture_ArchTypesReadAddressChannelArchitectureDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_BusArchitecture_ArchTypesReadAddressChannelArchitectureDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_BusArchitecture_ArchTypesReadDataChannelArchitectureDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_BusArchitecture_ArchTypesReadDataChannelArchitectureDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_SlaveAddressMapNormalModeSlaveAddressMapDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_SlaveAddressMapNormalModeSlaveAddressMapDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_SlaveAddressMapBootModeSlaveAddressMapDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_SlaveAddressMapBootModeSlaveAddressMapDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_MasterPortParamsMasterLimitsDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_MasterPortParamsMasterLimitsDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_SlavePortParamsSlaveLimitsDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_SlavePortParamsSlaveLimitsDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_MasterPortParamsMasterLimitsDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_MasterPortParamsMasterLimitsDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_SlaveAddressMapNormalModeSlaveAddressMapDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_SlaveAddressMapNormalModeSlaveAddressMapDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_SlaveAddressMapBootModeSlaveAddressMapDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_SlaveAddressMapBootModeSlaveAddressMapDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_BusArchitecture_ArchTypesWriteAddressChannelArchitectureDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_BusArchitecture_ArchTypesWriteAddressChannelArchitectureDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_BusArchitecture_ArchTypesWriteDataChannelArchitectureDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_BusArchitecture_ArchTypesWriteDataChannelArchitectureDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_BusArchitecture_ArchTypesBurstResponseChannelArchitectureDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_BusArchitecture_ArchTypesBurstResponseChannelArchitectureDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_BusArchitecture_ArchTypesReadAddressChannelArchitectureDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_BusArchitecture_ArchTypesReadAddressChannelArchitectureDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_BusArchitecture_ArchTypesReadDataChannelArchitectureDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_BusArchitecture_ArchTypesReadDataChannelArchitectureDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_SlaveVisibilitySlaveVisibilityNormalDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_SlaveVisibilitySlaveVisibilityNormalDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_SlaveVisibilitySlaveVisibilityBootDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_SlaveVisibilitySlaveVisibilityBootDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_HasSidebandSideBandConfigDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_HasSidebandSideBandConfigDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_Arbitration_PriorityMasterPriorityDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_Arbitration_PriorityMasterPriorityDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_Arbitration_PrioritySlavePriorityDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_Arbitration_PrioritySlavePriorityDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_PipelingingOptions_MultiCycleArbitrationSelectNumberofArbitrationCyclesforSlavePortArbitersDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_PipelingingOptions_MultiCycleArbitrationSelectNumberofArbitrationCyclesforSlavePortArbitersDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_PipelingingOptions_MultiCycleArbitrationSelectNumberofArbitrationCyclesforMasterPortArbitersDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_PipelingingOptions_MultiCycleArbitrationSelectNumberofArbitrationCyclesforMasterPortArbitersDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_BicmdConfig_hasMasterNumbersMasterNumbersDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_BicmdConfig_hasMasterNumbersMasterNumbersDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_BicmdConfig_ICSlavePortsSlaveNumbersDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_BicmdConfig_ICSlavePortsSlaveNumbersDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_BicmdConfig_hasICMMasterICMMasterDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_BicmdConfig_hasICMMasterICMMasterDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_Arbitration_ArbTypeSlavePortArbitersDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_Arbitration_ArbTypeSlavePortArbitersDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_Arbitration_ArbTypeMasterPortArbitersDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_Arbitration_ArbTypeMasterPortArbitersDlgView -search library.work]
set_attribute -attr [find_item -exacttype stringAttrDefn Value -limit  -search BuiltIn] -value {} [find_item -exacttype dlgEditableView DW_axiParam_Arbitration_ArbTypeSharedLayerArbitersDlgView -search library.work]
send_event -activate [find_item -exacttype dlgEditableView DW_axiParam_Arbitration_ArbTypeSharedLayerArbitersDlgView -search library.work]
send_event -cancel [find_item -exacttype Dialog HelpWindow -search System]
send_event -cancel [find_item -exacttype Dialog ReportWindow -search System]
send_event -cancel [find_item -exacttype Sheet DW_axiParamDlg -search library.work]
send_event -cancel [find_item -exacttype Dialog ActivityWindow -search System]
